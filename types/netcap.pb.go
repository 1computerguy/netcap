// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: netcap.proto

package types

/*
	generated protocol buffer code will be put into the "types" package
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_NC_Header                      Type = 0
	Type_NC_Batch                       Type = 1
	Type_NC_Flow                        Type = 2
	Type_NC_Connection                  Type = 3
	Type_NC_LinkFlow                    Type = 4
	Type_NC_NetworkFlow                 Type = 5
	Type_NC_TransportFlow               Type = 6
	Type_NC_Ethernet                    Type = 7
	Type_NC_ARP                         Type = 8
	Type_NC_Dot1Q                       Type = 9
	Type_NC_Dot11                       Type = 10
	Type_NC_Dot11QOS                    Type = 11
	Type_NC_Dot11HTControl              Type = 12
	Type_NC_Dot11HTControlVHT           Type = 13
	Type_NC_Dot11HTControlHT            Type = 14
	Type_NC_Dot11HTControlMFB           Type = 15
	Type_NC_Dot11LinkAdapationControl   Type = 16
	Type_NC_Dot11ASEL                   Type = 17
	Type_NC_LinkLayerDiscovery          Type = 18
	Type_NC_LLDPChassisID               Type = 19
	Type_NC_LLDPPortID                  Type = 20
	Type_NC_LinkLayerDiscoveryValue     Type = 21
	Type_NC_EthernetCTP                 Type = 22
	Type_NC_EthernetCTPReply            Type = 23
	Type_NC_LinkLayerDiscoveryInfo      Type = 24
	Type_NC_LLDPSysCapabilities         Type = 25
	Type_NC_LLDPCapabilities            Type = 26
	Type_NC_LLDPMgmtAddress             Type = 27
	Type_NC_LLDPOrgSpecificTLV          Type = 28
	Type_NC_IPv4                        Type = 29
	Type_NC_IPv4Option                  Type = 30
	Type_NC_IPv6                        Type = 31
	Type_NC_ICMPv4                      Type = 32
	Type_NC_ICMPv6                      Type = 33
	Type_NC_ICMPv6NeighborAdvertisement Type = 34
	Type_NC_ICMPv6RouterAdvertisement   Type = 35
	Type_NC_ICMPv6Option                Type = 36
	Type_NC_UDP                         Type = 37
	Type_NC_TCP                         Type = 38
	Type_NC_TCPOption                   Type = 39
	Type_NC_SCTP                        Type = 40
	Type_NC_DNS                         Type = 41
	Type_NC_DNSResourceRecord           Type = 42
	Type_NC_DNSSOA                      Type = 43
	Type_NC_DNSSRV                      Type = 44
	Type_NC_DNSMX                       Type = 45
	Type_NC_DNSQuestion                 Type = 46
	Type_NC_DHCPv4                      Type = 47
	Type_NC_DHCPOption                  Type = 48
	Type_NC_DHCPv6                      Type = 49
	Type_NC_DHCPv6Option                Type = 50
	Type_NC_LLC                         Type = 51
	Type_NC_NTP                         Type = 52
	Type_NC_SIP                         Type = 53
	Type_NC_IGMP                        Type = 54
	Type_NC_IGMPv3GroupRecord           Type = 55
	Type_NC_IPv6HopByHop                Type = 56
	Type_NC_IPv6HopByHopOption          Type = 57
	Type_NC_IPv6HopByHopOptionAlignment Type = 58
	Type_NC_SNAP                        Type = 59
	Type_NC_ICMPv6Echo                  Type = 60
	Type_NC_ICMPv6NeighborSolicitation  Type = 61
	Type_NC_ICMPv6RouterSolicitation    Type = 62
	Type_NC_HTTP                        Type = 63
	Type_NC_TLSClientHello              Type = 64
	Type_NC_IPSecAH                     Type = 65
	Type_NC_IPSecESP                    Type = 66
	Type_NC_Geneve                      Type = 67
	Type_NC_IPv6Fragment                Type = 68
	Type_NC_VXLAN                       Type = 69
	Type_NC_USB                         Type = 70
	Type_NC_LCM                         Type = 71
	Type_NC_MPLS                        Type = 72
	Type_NC_ModbusTCP                   Type = 73
	Type_NC_OSPFv2                      Type = 74
	Type_NC_OSPFv3                      Type = 75
	Type_NC_BFD                         Type = 76
	Type_NC_GRE                         Type = 77
	Type_NC_FDDI                        Type = 78
	Type_NC_EAP                         Type = 79
	Type_NC_VRRPv2                      Type = 80
	Type_NC_EAPOL                       Type = 81
	Type_NC_EAPOLKey                    Type = 82
	Type_NC_CiscoDiscovery              Type = 83
	Type_NC_CiscoDiscoveryInfo          Type = 84
	Type_NC_USBRequestBlockSetup        Type = 85
	Type_NC_NortelDiscovery             Type = 86
)

var Type_name = map[int32]string{
	0:  "NC_Header",
	1:  "NC_Batch",
	2:  "NC_Flow",
	3:  "NC_Connection",
	4:  "NC_LinkFlow",
	5:  "NC_NetworkFlow",
	6:  "NC_TransportFlow",
	7:  "NC_Ethernet",
	8:  "NC_ARP",
	9:  "NC_Dot1Q",
	10: "NC_Dot11",
	11: "NC_Dot11QOS",
	12: "NC_Dot11HTControl",
	13: "NC_Dot11HTControlVHT",
	14: "NC_Dot11HTControlHT",
	15: "NC_Dot11HTControlMFB",
	16: "NC_Dot11LinkAdapationControl",
	17: "NC_Dot11ASEL",
	18: "NC_LinkLayerDiscovery",
	19: "NC_LLDPChassisID",
	20: "NC_LLDPPortID",
	21: "NC_LinkLayerDiscoveryValue",
	22: "NC_EthernetCTP",
	23: "NC_EthernetCTPReply",
	24: "NC_LinkLayerDiscoveryInfo",
	25: "NC_LLDPSysCapabilities",
	26: "NC_LLDPCapabilities",
	27: "NC_LLDPMgmtAddress",
	28: "NC_LLDPOrgSpecificTLV",
	29: "NC_IPv4",
	30: "NC_IPv4Option",
	31: "NC_IPv6",
	32: "NC_ICMPv4",
	33: "NC_ICMPv6",
	34: "NC_ICMPv6NeighborAdvertisement",
	35: "NC_ICMPv6RouterAdvertisement",
	36: "NC_ICMPv6Option",
	37: "NC_UDP",
	38: "NC_TCP",
	39: "NC_TCPOption",
	40: "NC_SCTP",
	41: "NC_DNS",
	42: "NC_DNSResourceRecord",
	43: "NC_DNSSOA",
	44: "NC_DNSSRV",
	45: "NC_DNSMX",
	46: "NC_DNSQuestion",
	47: "NC_DHCPv4",
	48: "NC_DHCPOption",
	49: "NC_DHCPv6",
	50: "NC_DHCPv6Option",
	51: "NC_LLC",
	52: "NC_NTP",
	53: "NC_SIP",
	54: "NC_IGMP",
	55: "NC_IGMPv3GroupRecord",
	56: "NC_IPv6HopByHop",
	57: "NC_IPv6HopByHopOption",
	58: "NC_IPv6HopByHopOptionAlignment",
	59: "NC_SNAP",
	60: "NC_ICMPv6Echo",
	61: "NC_ICMPv6NeighborSolicitation",
	62: "NC_ICMPv6RouterSolicitation",
	63: "NC_HTTP",
	64: "NC_TLSClientHello",
	65: "NC_IPSecAH",
	66: "NC_IPSecESP",
	67: "NC_Geneve",
	68: "NC_IPv6Fragment",
	69: "NC_VXLAN",
	70: "NC_USB",
	71: "NC_LCM",
	72: "NC_MPLS",
	73: "NC_ModbusTCP",
	74: "NC_OSPFv2",
	75: "NC_OSPFv3",
	76: "NC_BFD",
	77: "NC_GRE",
	78: "NC_FDDI",
	79: "NC_EAP",
	80: "NC_VRRPv2",
	81: "NC_EAPOL",
	82: "NC_EAPOLKey",
	83: "NC_CiscoDiscovery",
	84: "NC_CiscoDiscoveryInfo",
	85: "NC_USBRequestBlockSetup",
	86: "NC_NortelDiscovery",
}
var Type_value = map[string]int32{
	"NC_Header":                      0,
	"NC_Batch":                       1,
	"NC_Flow":                        2,
	"NC_Connection":                  3,
	"NC_LinkFlow":                    4,
	"NC_NetworkFlow":                 5,
	"NC_TransportFlow":               6,
	"NC_Ethernet":                    7,
	"NC_ARP":                         8,
	"NC_Dot1Q":                       9,
	"NC_Dot11":                       10,
	"NC_Dot11QOS":                    11,
	"NC_Dot11HTControl":              12,
	"NC_Dot11HTControlVHT":           13,
	"NC_Dot11HTControlHT":            14,
	"NC_Dot11HTControlMFB":           15,
	"NC_Dot11LinkAdapationControl":   16,
	"NC_Dot11ASEL":                   17,
	"NC_LinkLayerDiscovery":          18,
	"NC_LLDPChassisID":               19,
	"NC_LLDPPortID":                  20,
	"NC_LinkLayerDiscoveryValue":     21,
	"NC_EthernetCTP":                 22,
	"NC_EthernetCTPReply":            23,
	"NC_LinkLayerDiscoveryInfo":      24,
	"NC_LLDPSysCapabilities":         25,
	"NC_LLDPCapabilities":            26,
	"NC_LLDPMgmtAddress":             27,
	"NC_LLDPOrgSpecificTLV":          28,
	"NC_IPv4":                        29,
	"NC_IPv4Option":                  30,
	"NC_IPv6":                        31,
	"NC_ICMPv4":                      32,
	"NC_ICMPv6":                      33,
	"NC_ICMPv6NeighborAdvertisement": 34,
	"NC_ICMPv6RouterAdvertisement":   35,
	"NC_ICMPv6Option":                36,
	"NC_UDP":                         37,
	"NC_TCP":                         38,
	"NC_TCPOption":                   39,
	"NC_SCTP":                        40,
	"NC_DNS":                         41,
	"NC_DNSResourceRecord":           42,
	"NC_DNSSOA":                      43,
	"NC_DNSSRV":                      44,
	"NC_DNSMX":                       45,
	"NC_DNSQuestion":                 46,
	"NC_DHCPv4":                      47,
	"NC_DHCPOption":                  48,
	"NC_DHCPv6":                      49,
	"NC_DHCPv6Option":                50,
	"NC_LLC":                         51,
	"NC_NTP":                         52,
	"NC_SIP":                         53,
	"NC_IGMP":                        54,
	"NC_IGMPv3GroupRecord":           55,
	"NC_IPv6HopByHop":                56,
	"NC_IPv6HopByHopOption":          57,
	"NC_IPv6HopByHopOptionAlignment": 58,
	"NC_SNAP":                        59,
	"NC_ICMPv6Echo":                  60,
	"NC_ICMPv6NeighborSolicitation":  61,
	"NC_ICMPv6RouterSolicitation":    62,
	"NC_HTTP":                        63,
	"NC_TLSClientHello":              64,
	"NC_IPSecAH":                     65,
	"NC_IPSecESP":                    66,
	"NC_Geneve":                      67,
	"NC_IPv6Fragment":                68,
	"NC_VXLAN":                       69,
	"NC_USB":                         70,
	"NC_LCM":                         71,
	"NC_MPLS":                        72,
	"NC_ModbusTCP":                   73,
	"NC_OSPFv2":                      74,
	"NC_OSPFv3":                      75,
	"NC_BFD":                         76,
	"NC_GRE":                         77,
	"NC_FDDI":                        78,
	"NC_EAP":                         79,
	"NC_VRRPv2":                      80,
	"NC_EAPOL":                       81,
	"NC_EAPOLKey":                    82,
	"NC_CiscoDiscovery":              83,
	"NC_CiscoDiscoveryInfo":          84,
	"NC_USBRequestBlockSetup":        85,
	"NC_NortelDiscovery":             86,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{0}
}

type Header struct {
	Created          string `protobuf:"bytes,1,opt,name=Created,proto3" json:"Created,omitempty"`
	InputSource      string `protobuf:"bytes,2,opt,name=InputSource,proto3" json:"InputSource,omitempty"`
	Type             Type   `protobuf:"varint,3,opt,name=Type,proto3,enum=types.Type" json:"Type,omitempty"`
	Version          string `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	ContainsPayloads bool   `protobuf:"varint,5,opt,name=ContainsPayloads,proto3" json:"ContainsPayloads,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{0}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(dst, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *Header) GetInputSource() string {
	if m != nil {
		return m.InputSource
	}
	return ""
}

func (m *Header) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NC_Header
}

func (m *Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Header) GetContainsPayloads() bool {
	if m != nil {
		return m.ContainsPayloads
	}
	return false
}

type Batch struct {
	ClientID         string `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	MessageType      Type   `protobuf:"varint,2,opt,name=MessageType,proto3,enum=types.Type" json:"MessageType,omitempty"`
	TotalSize        int32  `protobuf:"varint,3,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	Data             []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	ContainsPayloads bool   `protobuf:"varint,5,opt,name=ContainsPayloads,proto3" json:"ContainsPayloads,omitempty"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{1}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(dst, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Batch) GetMessageType() Type {
	if m != nil {
		return m.MessageType
	}
	return Type_NC_Header
}

func (m *Batch) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Batch) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Batch) GetContainsPayloads() bool {
	if m != nil {
		return m.ContainsPayloads
	}
	return false
}

// a flow is identified by its network layer and transport layer flows separated by a colon
// format: <networkFlow>:<tranportFlow>
// e.g: 172.16.11.104->201.11.212.81:2673->1511
type Flow struct {
	TimestampFirst   string `protobuf:"bytes,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	LinkProto        string `protobuf:"bytes,2,opt,name=LinkProto,proto3" json:"LinkProto,omitempty"`
	NetworkProto     string `protobuf:"bytes,3,opt,name=NetworkProto,proto3" json:"NetworkProto,omitempty"`
	TransportProto   string `protobuf:"bytes,4,opt,name=TransportProto,proto3" json:"TransportProto,omitempty"`
	ApplicationProto string `protobuf:"bytes,5,opt,name=ApplicationProto,proto3" json:"ApplicationProto,omitempty"`
	SrcMAC           string `protobuf:"bytes,6,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC           string `protobuf:"bytes,7,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcIP            string `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	SrcPort          string `protobuf:"bytes,9,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstIP            string `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	DstPort          string `protobuf:"bytes,11,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	TotalSize        int32  `protobuf:"varint,12,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	AppPayloadSize   int32  `protobuf:"varint,13,opt,name=AppPayloadSize,proto3" json:"AppPayloadSize,omitempty"`
	NumPackets       int32  `protobuf:"varint,14,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID              string `protobuf:"bytes,15,opt,name=UID,proto3" json:"UID,omitempty"`
	TimestampLast    string `protobuf:"bytes,16,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Duration         int64  `protobuf:"varint,17,opt,name=Duration,proto3" json:"Duration,omitempty"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{2}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(dst, src)
}
func (m *Flow) XXX_Size() int {
	return m.Size()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetTimestampFirst() string {
	if m != nil {
		return m.TimestampFirst
	}
	return ""
}

func (m *Flow) GetLinkProto() string {
	if m != nil {
		return m.LinkProto
	}
	return ""
}

func (m *Flow) GetNetworkProto() string {
	if m != nil {
		return m.NetworkProto
	}
	return ""
}

func (m *Flow) GetTransportProto() string {
	if m != nil {
		return m.TransportProto
	}
	return ""
}

func (m *Flow) GetApplicationProto() string {
	if m != nil {
		return m.ApplicationProto
	}
	return ""
}

func (m *Flow) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *Flow) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *Flow) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Flow) GetSrcPort() string {
	if m != nil {
		return m.SrcPort
	}
	return ""
}

func (m *Flow) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Flow) GetDstPort() string {
	if m != nil {
		return m.DstPort
	}
	return ""
}

func (m *Flow) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Flow) GetAppPayloadSize() int32 {
	if m != nil {
		return m.AppPayloadSize
	}
	return 0
}

func (m *Flow) GetNumPackets() int32 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *Flow) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *Flow) GetTimestampLast() string {
	if m != nil {
		return m.TimestampLast
	}
	return ""
}

func (m *Flow) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// a connection has the following attributes:
// Mac <-> Mac bidirectional Mac
// IP <-> IP bisdirectional IP
// Port <-> Port bidirectional Port
type Connection struct {
	TimestampFirst   string `protobuf:"bytes,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	LinkProto        string `protobuf:"bytes,2,opt,name=LinkProto,proto3" json:"LinkProto,omitempty"`
	NetworkProto     string `protobuf:"bytes,3,opt,name=NetworkProto,proto3" json:"NetworkProto,omitempty"`
	TransportProto   string `protobuf:"bytes,4,opt,name=TransportProto,proto3" json:"TransportProto,omitempty"`
	ApplicationProto string `protobuf:"bytes,5,opt,name=ApplicationProto,proto3" json:"ApplicationProto,omitempty"`
	SrcMAC           string `protobuf:"bytes,6,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC           string `protobuf:"bytes,7,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcIP            string `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	SrcPort          string `protobuf:"bytes,9,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstIP            string `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	DstPort          string `protobuf:"bytes,11,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	TotalSize        int32  `protobuf:"varint,12,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	AppPayloadSize   int32  `protobuf:"varint,13,opt,name=AppPayloadSize,proto3" json:"AppPayloadSize,omitempty"`
	NumPackets       int32  `protobuf:"varint,14,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID              string `protobuf:"bytes,15,opt,name=UID,proto3" json:"UID,omitempty"`
	TimestampLast    string `protobuf:"bytes,16,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Duration         int64  `protobuf:"varint,17,opt,name=Duration,proto3" json:"Duration,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{3}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(dst, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetTimestampFirst() string {
	if m != nil {
		return m.TimestampFirst
	}
	return ""
}

func (m *Connection) GetLinkProto() string {
	if m != nil {
		return m.LinkProto
	}
	return ""
}

func (m *Connection) GetNetworkProto() string {
	if m != nil {
		return m.NetworkProto
	}
	return ""
}

func (m *Connection) GetTransportProto() string {
	if m != nil {
		return m.TransportProto
	}
	return ""
}

func (m *Connection) GetApplicationProto() string {
	if m != nil {
		return m.ApplicationProto
	}
	return ""
}

func (m *Connection) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *Connection) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *Connection) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Connection) GetSrcPort() string {
	if m != nil {
		return m.SrcPort
	}
	return ""
}

func (m *Connection) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Connection) GetDstPort() string {
	if m != nil {
		return m.DstPort
	}
	return ""
}

func (m *Connection) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Connection) GetAppPayloadSize() int32 {
	if m != nil {
		return m.AppPayloadSize
	}
	return 0
}

func (m *Connection) GetNumPackets() int32 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *Connection) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *Connection) GetTimestampLast() string {
	if m != nil {
		return m.TimestampLast
	}
	return ""
}

func (m *Connection) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

type LinkFlow struct {
	TimestampFirst string `protobuf:"bytes,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	TimestampLast  string `protobuf:"bytes,2,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Proto          string `protobuf:"bytes,3,opt,name=Proto,proto3" json:"Proto,omitempty"`
	SrcMAC         string `protobuf:"bytes,4,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC         string `protobuf:"bytes,5,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	TotalSize      int64  `protobuf:"varint,6,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	NumPackets     int64  `protobuf:"varint,7,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID            uint64 `protobuf:"varint,8,opt,name=UID,proto3" json:"UID,omitempty"`
	Duration       int64  `protobuf:"varint,9,opt,name=Duration,proto3" json:"Duration,omitempty"`
}

func (m *LinkFlow) Reset()         { *m = LinkFlow{} }
func (m *LinkFlow) String() string { return proto.CompactTextString(m) }
func (*LinkFlow) ProtoMessage()    {}
func (*LinkFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{4}
}
func (m *LinkFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinkFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkFlow.Merge(dst, src)
}
func (m *LinkFlow) XXX_Size() int {
	return m.Size()
}
func (m *LinkFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkFlow.DiscardUnknown(m)
}

var xxx_messageInfo_LinkFlow proto.InternalMessageInfo

func (m *LinkFlow) GetTimestampFirst() string {
	if m != nil {
		return m.TimestampFirst
	}
	return ""
}

func (m *LinkFlow) GetTimestampLast() string {
	if m != nil {
		return m.TimestampLast
	}
	return ""
}

func (m *LinkFlow) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *LinkFlow) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *LinkFlow) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *LinkFlow) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *LinkFlow) GetNumPackets() int64 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *LinkFlow) GetUID() uint64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *LinkFlow) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

type NetworkFlow struct {
	TimestampFirst string `protobuf:"bytes,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	TimestampLast  string `protobuf:"bytes,2,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Proto          string `protobuf:"bytes,3,opt,name=Proto,proto3" json:"Proto,omitempty"`
	SrcIP          string `protobuf:"bytes,4,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string `protobuf:"bytes,5,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	TotalSize      int64  `protobuf:"varint,6,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	NumPackets     int64  `protobuf:"varint,7,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID            uint64 `protobuf:"varint,8,opt,name=UID,proto3" json:"UID,omitempty"`
	Duration       int64  `protobuf:"varint,9,opt,name=Duration,proto3" json:"Duration,omitempty"`
}

func (m *NetworkFlow) Reset()         { *m = NetworkFlow{} }
func (m *NetworkFlow) String() string { return proto.CompactTextString(m) }
func (*NetworkFlow) ProtoMessage()    {}
func (*NetworkFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{5}
}
func (m *NetworkFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetworkFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkFlow.Merge(dst, src)
}
func (m *NetworkFlow) XXX_Size() int {
	return m.Size()
}
func (m *NetworkFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkFlow.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkFlow proto.InternalMessageInfo

func (m *NetworkFlow) GetTimestampFirst() string {
	if m != nil {
		return m.TimestampFirst
	}
	return ""
}

func (m *NetworkFlow) GetTimestampLast() string {
	if m != nil {
		return m.TimestampLast
	}
	return ""
}

func (m *NetworkFlow) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *NetworkFlow) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *NetworkFlow) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *NetworkFlow) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *NetworkFlow) GetNumPackets() int64 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *NetworkFlow) GetUID() uint64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *NetworkFlow) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

type TransportFlow struct {
	TimestampFirst string `protobuf:"bytes,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	TimestampLast  string `protobuf:"bytes,2,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Proto          string `protobuf:"bytes,3,opt,name=Proto,proto3" json:"Proto,omitempty"`
	SrcPort        int32  `protobuf:"varint,4,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32  `protobuf:"varint,5,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	TotalSize      int64  `protobuf:"varint,6,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	NumPackets     int64  `protobuf:"varint,7,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID            uint64 `protobuf:"varint,8,opt,name=UID,proto3" json:"UID,omitempty"`
	Duration       int64  `protobuf:"varint,9,opt,name=Duration,proto3" json:"Duration,omitempty"`
}

func (m *TransportFlow) Reset()         { *m = TransportFlow{} }
func (m *TransportFlow) String() string { return proto.CompactTextString(m) }
func (*TransportFlow) ProtoMessage()    {}
func (*TransportFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{6}
}
func (m *TransportFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransportFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransportFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransportFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransportFlow.Merge(dst, src)
}
func (m *TransportFlow) XXX_Size() int {
	return m.Size()
}
func (m *TransportFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_TransportFlow.DiscardUnknown(m)
}

var xxx_messageInfo_TransportFlow proto.InternalMessageInfo

func (m *TransportFlow) GetTimestampFirst() string {
	if m != nil {
		return m.TimestampFirst
	}
	return ""
}

func (m *TransportFlow) GetTimestampLast() string {
	if m != nil {
		return m.TimestampLast
	}
	return ""
}

func (m *TransportFlow) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *TransportFlow) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TransportFlow) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TransportFlow) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *TransportFlow) GetNumPackets() int64 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *TransportFlow) GetUID() uint64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *TransportFlow) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

type Ethernet struct {
	Timestamp      string  `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcMAC         string  `protobuf:"bytes,2,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC         string  `protobuf:"bytes,3,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	EthernetType   int32   `protobuf:"varint,4,opt,name=EthernetType,proto3" json:"EthernetType,omitempty"`
	PayloadEntropy float64 `protobuf:"fixed64,5,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32   `protobuf:"varint,6,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
}

func (m *Ethernet) Reset()         { *m = Ethernet{} }
func (m *Ethernet) String() string { return proto.CompactTextString(m) }
func (*Ethernet) ProtoMessage()    {}
func (*Ethernet) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{7}
}
func (m *Ethernet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ethernet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ethernet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Ethernet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ethernet.Merge(dst, src)
}
func (m *Ethernet) XXX_Size() int {
	return m.Size()
}
func (m *Ethernet) XXX_DiscardUnknown() {
	xxx_messageInfo_Ethernet.DiscardUnknown(m)
}

var xxx_messageInfo_Ethernet proto.InternalMessageInfo

func (m *Ethernet) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Ethernet) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *Ethernet) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *Ethernet) GetEthernetType() int32 {
	if m != nil {
		return m.EthernetType
	}
	return 0
}

func (m *Ethernet) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *Ethernet) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

type ARP struct {
	Timestamp       string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	AddrType        int32  `protobuf:"varint,2,opt,name=AddrType,proto3" json:"AddrType,omitempty"`
	Protocol        int32  `protobuf:"varint,3,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	HwAddressSize   int32  `protobuf:"varint,4,opt,name=HwAddressSize,proto3" json:"HwAddressSize,omitempty"`
	ProtAddressSize int32  `protobuf:"varint,5,opt,name=ProtAddressSize,proto3" json:"ProtAddressSize,omitempty"`
	Operation       int32  `protobuf:"varint,6,opt,name=Operation,proto3" json:"Operation,omitempty"`
	SrcHwAddress    []byte `protobuf:"bytes,7,opt,name=SrcHwAddress,proto3" json:"SrcHwAddress,omitempty"`
	SrcProtAddress  []byte `protobuf:"bytes,8,opt,name=SrcProtAddress,proto3" json:"SrcProtAddress,omitempty"`
	DstHwAddress    []byte `protobuf:"bytes,9,opt,name=DstHwAddress,proto3" json:"DstHwAddress,omitempty"`
	DstProtAddress  []byte `protobuf:"bytes,10,opt,name=DstProtAddress,proto3" json:"DstProtAddress,omitempty"`
}

func (m *ARP) Reset()         { *m = ARP{} }
func (m *ARP) String() string { return proto.CompactTextString(m) }
func (*ARP) ProtoMessage()    {}
func (*ARP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{8}
}
func (m *ARP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ARP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ARP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ARP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ARP.Merge(dst, src)
}
func (m *ARP) XXX_Size() int {
	return m.Size()
}
func (m *ARP) XXX_DiscardUnknown() {
	xxx_messageInfo_ARP.DiscardUnknown(m)
}

var xxx_messageInfo_ARP proto.InternalMessageInfo

func (m *ARP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ARP) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *ARP) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *ARP) GetHwAddressSize() int32 {
	if m != nil {
		return m.HwAddressSize
	}
	return 0
}

func (m *ARP) GetProtAddressSize() int32 {
	if m != nil {
		return m.ProtAddressSize
	}
	return 0
}

func (m *ARP) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

func (m *ARP) GetSrcHwAddress() []byte {
	if m != nil {
		return m.SrcHwAddress
	}
	return nil
}

func (m *ARP) GetSrcProtAddress() []byte {
	if m != nil {
		return m.SrcProtAddress
	}
	return nil
}

func (m *ARP) GetDstHwAddress() []byte {
	if m != nil {
		return m.DstHwAddress
	}
	return nil
}

func (m *ARP) GetDstProtAddress() []byte {
	if m != nil {
		return m.DstProtAddress
	}
	return nil
}

// Dot1Q is the packet layer for 802.1Q VLAN headers.
type Dot1Q struct {
	Timestamp      string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Priority       int32  `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty"`
	DropEligible   bool   `protobuf:"varint,3,opt,name=DropEligible,proto3" json:"DropEligible,omitempty"`
	VLANIdentifier int32  `protobuf:"varint,4,opt,name=VLANIdentifier,proto3" json:"VLANIdentifier,omitempty"`
	Type           int32  `protobuf:"varint,5,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *Dot1Q) Reset()         { *m = Dot1Q{} }
func (m *Dot1Q) String() string { return proto.CompactTextString(m) }
func (*Dot1Q) ProtoMessage()    {}
func (*Dot1Q) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{9}
}
func (m *Dot1Q) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot1Q) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot1Q.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot1Q) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot1Q.Merge(dst, src)
}
func (m *Dot1Q) XXX_Size() int {
	return m.Size()
}
func (m *Dot1Q) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot1Q.DiscardUnknown(m)
}

var xxx_messageInfo_Dot1Q proto.InternalMessageInfo

func (m *Dot1Q) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Dot1Q) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Dot1Q) GetDropEligible() bool {
	if m != nil {
		return m.DropEligible
	}
	return false
}

func (m *Dot1Q) GetVLANIdentifier() int32 {
	if m != nil {
		return m.VLANIdentifier
	}
	return 0
}

func (m *Dot1Q) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// Dot11 provides an IEEE 802.11 base packet header.
// See http://standards.ieee.org/findstds/standard/802.11-2012.html for excruciating detail.
type Dot11 struct {
	Timestamp      string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type           int32           `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Proto          int32           `protobuf:"varint,3,opt,name=Proto,proto3" json:"Proto,omitempty"`
	Flags          int32           `protobuf:"varint,4,opt,name=Flags,proto3" json:"Flags,omitempty"`
	DurationID     int32           `protobuf:"varint,5,opt,name=DurationID,proto3" json:"DurationID,omitempty"`
	Address1       string          `protobuf:"bytes,6,opt,name=Address1,proto3" json:"Address1,omitempty"`
	Address2       string          `protobuf:"bytes,7,opt,name=Address2,proto3" json:"Address2,omitempty"`
	Address3       string          `protobuf:"bytes,8,opt,name=Address3,proto3" json:"Address3,omitempty"`
	Address4       string          `protobuf:"bytes,9,opt,name=Address4,proto3" json:"Address4,omitempty"`
	SequenceNumber int32           `protobuf:"varint,10,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	FragmentNumber int32           `protobuf:"varint,11,opt,name=FragmentNumber,proto3" json:"FragmentNumber,omitempty"`
	Checksum       uint32          `protobuf:"varint,12,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	QOS            *Dot11QOS       `protobuf:"bytes,13,opt,name=QOS" json:"QOS,omitempty"`
	HTControl      *Dot11HTControl `protobuf:"bytes,14,opt,name=HTControl" json:"HTControl,omitempty"`
}

func (m *Dot11) Reset()         { *m = Dot11{} }
func (m *Dot11) String() string { return proto.CompactTextString(m) }
func (*Dot11) ProtoMessage()    {}
func (*Dot11) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{10}
}
func (m *Dot11) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11.Merge(dst, src)
}
func (m *Dot11) XXX_Size() int {
	return m.Size()
}
func (m *Dot11) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11 proto.InternalMessageInfo

func (m *Dot11) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Dot11) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Dot11) GetProto() int32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *Dot11) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Dot11) GetDurationID() int32 {
	if m != nil {
		return m.DurationID
	}
	return 0
}

func (m *Dot11) GetAddress1() string {
	if m != nil {
		return m.Address1
	}
	return ""
}

func (m *Dot11) GetAddress2() string {
	if m != nil {
		return m.Address2
	}
	return ""
}

func (m *Dot11) GetAddress3() string {
	if m != nil {
		return m.Address3
	}
	return ""
}

func (m *Dot11) GetAddress4() string {
	if m != nil {
		return m.Address4
	}
	return ""
}

func (m *Dot11) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Dot11) GetFragmentNumber() int32 {
	if m != nil {
		return m.FragmentNumber
	}
	return 0
}

func (m *Dot11) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *Dot11) GetQOS() *Dot11QOS {
	if m != nil {
		return m.QOS
	}
	return nil
}

func (m *Dot11) GetHTControl() *Dot11HTControl {
	if m != nil {
		return m.HTControl
	}
	return nil
}

type Dot11QOS struct {
	TID       int32 `protobuf:"varint,1,opt,name=TID,proto3" json:"TID,omitempty"`
	EOSP      bool  `protobuf:"varint,2,opt,name=EOSP,proto3" json:"EOSP,omitempty"`
	AckPolicy int32 `protobuf:"varint,3,opt,name=AckPolicy,proto3" json:"AckPolicy,omitempty"`
	TXOP      int32 `protobuf:"varint,4,opt,name=TXOP,proto3" json:"TXOP,omitempty"`
}

func (m *Dot11QOS) Reset()         { *m = Dot11QOS{} }
func (m *Dot11QOS) String() string { return proto.CompactTextString(m) }
func (*Dot11QOS) ProtoMessage()    {}
func (*Dot11QOS) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{11}
}
func (m *Dot11QOS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11QOS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11QOS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11QOS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11QOS.Merge(dst, src)
}
func (m *Dot11QOS) XXX_Size() int {
	return m.Size()
}
func (m *Dot11QOS) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11QOS.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11QOS proto.InternalMessageInfo

func (m *Dot11QOS) GetTID() int32 {
	if m != nil {
		return m.TID
	}
	return 0
}

func (m *Dot11QOS) GetEOSP() bool {
	if m != nil {
		return m.EOSP
	}
	return false
}

func (m *Dot11QOS) GetAckPolicy() int32 {
	if m != nil {
		return m.AckPolicy
	}
	return 0
}

func (m *Dot11QOS) GetTXOP() int32 {
	if m != nil {
		return m.TXOP
	}
	return 0
}

type Dot11HTControl struct {
	ACConstraint bool               `protobuf:"varint,1,opt,name=ACConstraint,proto3" json:"ACConstraint,omitempty"`
	RDGMorePPDU  bool               `protobuf:"varint,2,opt,name=RDGMorePPDU,proto3" json:"RDGMorePPDU,omitempty"`
	VHT          *Dot11HTControlVHT `protobuf:"bytes,3,opt,name=VHT" json:"VHT,omitempty"`
	HT           *Dot11HTControlHT  `protobuf:"bytes,4,opt,name=HT" json:"HT,omitempty"`
}

func (m *Dot11HTControl) Reset()         { *m = Dot11HTControl{} }
func (m *Dot11HTControl) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControl) ProtoMessage()    {}
func (*Dot11HTControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{12}
}
func (m *Dot11HTControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11HTControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControl.Merge(dst, src)
}
func (m *Dot11HTControl) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControl) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControl.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControl proto.InternalMessageInfo

func (m *Dot11HTControl) GetACConstraint() bool {
	if m != nil {
		return m.ACConstraint
	}
	return false
}

func (m *Dot11HTControl) GetRDGMorePPDU() bool {
	if m != nil {
		return m.RDGMorePPDU
	}
	return false
}

func (m *Dot11HTControl) GetVHT() *Dot11HTControlVHT {
	if m != nil {
		return m.VHT
	}
	return nil
}

func (m *Dot11HTControl) GetHT() *Dot11HTControlHT {
	if m != nil {
		return m.HT
	}
	return nil
}

type Dot11HTControlVHT struct {
	MRQ            bool               `protobuf:"varint,1,opt,name=MRQ,proto3" json:"MRQ,omitempty"`
	UnsolicitedMFB bool               `protobuf:"varint,2,opt,name=UnsolicitedMFB,proto3" json:"UnsolicitedMFB,omitempty"`
	MSI            int32              `protobuf:"varint,3,opt,name=MSI,proto3" json:"MSI,omitempty"`
	MFB            *Dot11HTControlMFB `protobuf:"bytes,4,opt,name=MFB" json:"MFB,omitempty"`
	CompressedMSI  int32              `protobuf:"varint,5,opt,name=CompressedMSI,proto3" json:"CompressedMSI,omitempty"`
	STBCIndication bool               `protobuf:"varint,6,opt,name=STBCIndication,proto3" json:"STBCIndication,omitempty"`
	MFSI           int32              `protobuf:"varint,7,opt,name=MFSI,proto3" json:"MFSI,omitempty"`
	GID            int32              `protobuf:"varint,8,opt,name=GID,proto3" json:"GID,omitempty"`
	CodingType     int32              `protobuf:"varint,9,opt,name=CodingType,proto3" json:"CodingType,omitempty"`
	FbTXBeamformed bool               `protobuf:"varint,10,opt,name=FbTXBeamformed,proto3" json:"FbTXBeamformed,omitempty"`
}

func (m *Dot11HTControlVHT) Reset()         { *m = Dot11HTControlVHT{} }
func (m *Dot11HTControlVHT) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlVHT) ProtoMessage()    {}
func (*Dot11HTControlVHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{13}
}
func (m *Dot11HTControlVHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlVHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlVHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11HTControlVHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlVHT.Merge(dst, src)
}
func (m *Dot11HTControlVHT) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlVHT) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlVHT.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlVHT proto.InternalMessageInfo

func (m *Dot11HTControlVHT) GetMRQ() bool {
	if m != nil {
		return m.MRQ
	}
	return false
}

func (m *Dot11HTControlVHT) GetUnsolicitedMFB() bool {
	if m != nil {
		return m.UnsolicitedMFB
	}
	return false
}

func (m *Dot11HTControlVHT) GetMSI() int32 {
	if m != nil {
		return m.MSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetMFB() *Dot11HTControlMFB {
	if m != nil {
		return m.MFB
	}
	return nil
}

func (m *Dot11HTControlVHT) GetCompressedMSI() int32 {
	if m != nil {
		return m.CompressedMSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetSTBCIndication() bool {
	if m != nil {
		return m.STBCIndication
	}
	return false
}

func (m *Dot11HTControlVHT) GetMFSI() int32 {
	if m != nil {
		return m.MFSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetGID() int32 {
	if m != nil {
		return m.GID
	}
	return 0
}

func (m *Dot11HTControlVHT) GetCodingType() int32 {
	if m != nil {
		return m.CodingType
	}
	return 0
}

func (m *Dot11HTControlVHT) GetFbTXBeamformed() bool {
	if m != nil {
		return m.FbTXBeamformed
	}
	return false
}

type Dot11HTControlHT struct {
	LinkAdapationControl *Dot11LinkAdapationControl `protobuf:"bytes,1,opt,name=LinkAdapationControl" json:"LinkAdapationControl,omitempty"`
	CalibrationPosition  int32                      `protobuf:"varint,2,opt,name=CalibrationPosition,proto3" json:"CalibrationPosition,omitempty"`
	CalibrationSequence  int32                      `protobuf:"varint,3,opt,name=CalibrationSequence,proto3" json:"CalibrationSequence,omitempty"`
	CSISteering          int32                      `protobuf:"varint,4,opt,name=CSISteering,proto3" json:"CSISteering,omitempty"`
	NDPAnnouncement      bool                       `protobuf:"varint,5,opt,name=NDPAnnouncement,proto3" json:"NDPAnnouncement,omitempty"`
	DEI                  bool                       `protobuf:"varint,6,opt,name=DEI,proto3" json:"DEI,omitempty"`
}

func (m *Dot11HTControlHT) Reset()         { *m = Dot11HTControlHT{} }
func (m *Dot11HTControlHT) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlHT) ProtoMessage()    {}
func (*Dot11HTControlHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{14}
}
func (m *Dot11HTControlHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11HTControlHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlHT.Merge(dst, src)
}
func (m *Dot11HTControlHT) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlHT) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlHT.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlHT proto.InternalMessageInfo

func (m *Dot11HTControlHT) GetLinkAdapationControl() *Dot11LinkAdapationControl {
	if m != nil {
		return m.LinkAdapationControl
	}
	return nil
}

func (m *Dot11HTControlHT) GetCalibrationPosition() int32 {
	if m != nil {
		return m.CalibrationPosition
	}
	return 0
}

func (m *Dot11HTControlHT) GetCalibrationSequence() int32 {
	if m != nil {
		return m.CalibrationSequence
	}
	return 0
}

func (m *Dot11HTControlHT) GetCSISteering() int32 {
	if m != nil {
		return m.CSISteering
	}
	return 0
}

func (m *Dot11HTControlHT) GetNDPAnnouncement() bool {
	if m != nil {
		return m.NDPAnnouncement
	}
	return false
}

func (m *Dot11HTControlHT) GetDEI() bool {
	if m != nil {
		return m.DEI
	}
	return false
}

type Dot11HTControlMFB struct {
	NumSTS int32 `protobuf:"varint,1,opt,name=NumSTS,proto3" json:"NumSTS,omitempty"`
	VHTMCS int32 `protobuf:"varint,2,opt,name=VHTMCS,proto3" json:"VHTMCS,omitempty"`
	BW     int32 `protobuf:"varint,3,opt,name=BW,proto3" json:"BW,omitempty"`
	SNR    int32 `protobuf:"varint,4,opt,name=SNR,proto3" json:"SNR,omitempty"`
}

func (m *Dot11HTControlMFB) Reset()         { *m = Dot11HTControlMFB{} }
func (m *Dot11HTControlMFB) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlMFB) ProtoMessage()    {}
func (*Dot11HTControlMFB) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{15}
}
func (m *Dot11HTControlMFB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlMFB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlMFB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11HTControlMFB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlMFB.Merge(dst, src)
}
func (m *Dot11HTControlMFB) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlMFB) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlMFB.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlMFB proto.InternalMessageInfo

func (m *Dot11HTControlMFB) GetNumSTS() int32 {
	if m != nil {
		return m.NumSTS
	}
	return 0
}

func (m *Dot11HTControlMFB) GetVHTMCS() int32 {
	if m != nil {
		return m.VHTMCS
	}
	return 0
}

func (m *Dot11HTControlMFB) GetBW() int32 {
	if m != nil {
		return m.BW
	}
	return 0
}

func (m *Dot11HTControlMFB) GetSNR() int32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

type Dot11LinkAdapationControl struct {
	TRQ  bool       `protobuf:"varint,1,opt,name=TRQ,proto3" json:"TRQ,omitempty"`
	MRQ  bool       `protobuf:"varint,2,opt,name=MRQ,proto3" json:"MRQ,omitempty"`
	MSI  int32      `protobuf:"varint,3,opt,name=MSI,proto3" json:"MSI,omitempty"`
	MFSI int32      `protobuf:"varint,4,opt,name=MFSI,proto3" json:"MFSI,omitempty"`
	MFB  int32      `protobuf:"varint,6,opt,name=MFB,proto3" json:"MFB,omitempty"`
	ASEL *Dot11ASEL `protobuf:"bytes,5,opt,name=ASEL" json:"ASEL,omitempty"`
}

func (m *Dot11LinkAdapationControl) Reset()         { *m = Dot11LinkAdapationControl{} }
func (m *Dot11LinkAdapationControl) String() string { return proto.CompactTextString(m) }
func (*Dot11LinkAdapationControl) ProtoMessage()    {}
func (*Dot11LinkAdapationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{16}
}
func (m *Dot11LinkAdapationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11LinkAdapationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11LinkAdapationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11LinkAdapationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11LinkAdapationControl.Merge(dst, src)
}
func (m *Dot11LinkAdapationControl) XXX_Size() int {
	return m.Size()
}
func (m *Dot11LinkAdapationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11LinkAdapationControl.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11LinkAdapationControl proto.InternalMessageInfo

func (m *Dot11LinkAdapationControl) GetTRQ() bool {
	if m != nil {
		return m.TRQ
	}
	return false
}

func (m *Dot11LinkAdapationControl) GetMRQ() bool {
	if m != nil {
		return m.MRQ
	}
	return false
}

func (m *Dot11LinkAdapationControl) GetMSI() int32 {
	if m != nil {
		return m.MSI
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetMFSI() int32 {
	if m != nil {
		return m.MFSI
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetMFB() int32 {
	if m != nil {
		return m.MFB
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetASEL() *Dot11ASEL {
	if m != nil {
		return m.ASEL
	}
	return nil
}

type Dot11ASEL struct {
	Command int32 `protobuf:"varint,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Data    int32 `protobuf:"varint,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Dot11ASEL) Reset()         { *m = Dot11ASEL{} }
func (m *Dot11ASEL) String() string { return proto.CompactTextString(m) }
func (*Dot11ASEL) ProtoMessage()    {}
func (*Dot11ASEL) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{17}
}
func (m *Dot11ASEL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11ASEL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11ASEL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Dot11ASEL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11ASEL.Merge(dst, src)
}
func (m *Dot11ASEL) XXX_Size() int {
	return m.Size()
}
func (m *Dot11ASEL) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11ASEL.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11ASEL proto.InternalMessageInfo

func (m *Dot11ASEL) GetCommand() int32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *Dot11ASEL) GetData() int32 {
	if m != nil {
		return m.Data
	}
	return 0
}

type LinkLayerDiscovery struct {
	Timestamp string                     `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ChassisID *LLDPChassisID             `protobuf:"bytes,2,opt,name=ChassisID" json:"ChassisID,omitempty"`
	PortID    *LLDPPortID                `protobuf:"bytes,3,opt,name=PortID" json:"PortID,omitempty"`
	TTL       int32                      `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Values    []*LinkLayerDiscoveryValue `protobuf:"bytes,5,rep,name=Values" json:"Values,omitempty"`
}

func (m *LinkLayerDiscovery) Reset()         { *m = LinkLayerDiscovery{} }
func (m *LinkLayerDiscovery) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscovery) ProtoMessage()    {}
func (*LinkLayerDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{18}
}
func (m *LinkLayerDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinkLayerDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscovery.Merge(dst, src)
}
func (m *LinkLayerDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscovery proto.InternalMessageInfo

func (m *LinkLayerDiscovery) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LinkLayerDiscovery) GetChassisID() *LLDPChassisID {
	if m != nil {
		return m.ChassisID
	}
	return nil
}

func (m *LinkLayerDiscovery) GetPortID() *LLDPPortID {
	if m != nil {
		return m.PortID
	}
	return nil
}

func (m *LinkLayerDiscovery) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *LinkLayerDiscovery) GetValues() []*LinkLayerDiscoveryValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type LLDPChassisID struct {
	Subtype int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	ID      []byte `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *LLDPChassisID) Reset()         { *m = LLDPChassisID{} }
func (m *LLDPChassisID) String() string { return proto.CompactTextString(m) }
func (*LLDPChassisID) ProtoMessage()    {}
func (*LLDPChassisID) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{19}
}
func (m *LLDPChassisID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPChassisID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPChassisID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPChassisID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPChassisID.Merge(dst, src)
}
func (m *LLDPChassisID) XXX_Size() int {
	return m.Size()
}
func (m *LLDPChassisID) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPChassisID.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPChassisID proto.InternalMessageInfo

func (m *LLDPChassisID) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPChassisID) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type LLDPPortID struct {
	Subtype int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	ID      []byte `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *LLDPPortID) Reset()         { *m = LLDPPortID{} }
func (m *LLDPPortID) String() string { return proto.CompactTextString(m) }
func (*LLDPPortID) ProtoMessage()    {}
func (*LLDPPortID) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{20}
}
func (m *LLDPPortID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPPortID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPPortID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPPortID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPPortID.Merge(dst, src)
}
func (m *LLDPPortID) XXX_Size() int {
	return m.Size()
}
func (m *LLDPPortID) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPPortID.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPPortID proto.InternalMessageInfo

func (m *LLDPPortID) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPPortID) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type LinkLayerDiscoveryValue struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LinkLayerDiscoveryValue) Reset()         { *m = LinkLayerDiscoveryValue{} }
func (m *LinkLayerDiscoveryValue) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscoveryValue) ProtoMessage()    {}
func (*LinkLayerDiscoveryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{21}
}
func (m *LinkLayerDiscoveryValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscoveryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscoveryValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinkLayerDiscoveryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscoveryValue.Merge(dst, src)
}
func (m *LinkLayerDiscoveryValue) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscoveryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscoveryValue.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscoveryValue proto.InternalMessageInfo

func (m *LinkLayerDiscoveryValue) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *LinkLayerDiscoveryValue) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *LinkLayerDiscoveryValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type EthernetCTP struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SkipCount int32  `protobuf:"varint,2,opt,name=SkipCount,proto3" json:"SkipCount,omitempty"`
}

func (m *EthernetCTP) Reset()         { *m = EthernetCTP{} }
func (m *EthernetCTP) String() string { return proto.CompactTextString(m) }
func (*EthernetCTP) ProtoMessage()    {}
func (*EthernetCTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{22}
}
func (m *EthernetCTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetCTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthernetCTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EthernetCTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetCTP.Merge(dst, src)
}
func (m *EthernetCTP) XXX_Size() int {
	return m.Size()
}
func (m *EthernetCTP) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetCTP.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetCTP proto.InternalMessageInfo

func (m *EthernetCTP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EthernetCTP) GetSkipCount() int32 {
	if m != nil {
		return m.SkipCount
	}
	return 0
}

type EthernetCTPReply struct {
	Timestamp     string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Function      int32  `protobuf:"varint,2,opt,name=Function,proto3" json:"Function,omitempty"`
	ReceiptNumber int32  `protobuf:"varint,3,opt,name=ReceiptNumber,proto3" json:"ReceiptNumber,omitempty"`
	Data          []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *EthernetCTPReply) Reset()         { *m = EthernetCTPReply{} }
func (m *EthernetCTPReply) String() string { return proto.CompactTextString(m) }
func (*EthernetCTPReply) ProtoMessage()    {}
func (*EthernetCTPReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{23}
}
func (m *EthernetCTPReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetCTPReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthernetCTPReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EthernetCTPReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetCTPReply.Merge(dst, src)
}
func (m *EthernetCTPReply) XXX_Size() int {
	return m.Size()
}
func (m *EthernetCTPReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetCTPReply.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetCTPReply proto.InternalMessageInfo

func (m *EthernetCTPReply) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EthernetCTPReply) GetFunction() int32 {
	if m != nil {
		return m.Function
	}
	return 0
}

func (m *EthernetCTPReply) GetReceiptNumber() int32 {
	if m != nil {
		return m.ReceiptNumber
	}
	return 0
}

func (m *EthernetCTPReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type LinkLayerDiscoveryInfo struct {
	Timestamp       string                     `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	PortDescription string                     `protobuf:"bytes,2,opt,name=PortDescription,proto3" json:"PortDescription,omitempty"`
	SysName         string                     `protobuf:"bytes,3,opt,name=SysName,proto3" json:"SysName,omitempty"`
	SysDescription  string                     `protobuf:"bytes,4,opt,name=SysDescription,proto3" json:"SysDescription,omitempty"`
	SysCapabilities *LLDPSysCapabilities       `protobuf:"bytes,5,opt,name=SysCapabilities" json:"SysCapabilities,omitempty"`
	MgmtAddress     *LLDPMgmtAddress           `protobuf:"bytes,6,opt,name=MgmtAddress" json:"MgmtAddress,omitempty"`
	OrgTLVs         []*LLDPOrgSpecificTLV      `protobuf:"bytes,7,rep,name=OrgTLVs" json:"OrgTLVs,omitempty"`
	Unknown         []*LinkLayerDiscoveryValue `protobuf:"bytes,8,rep,name=Unknown" json:"Unknown,omitempty"`
}

func (m *LinkLayerDiscoveryInfo) Reset()         { *m = LinkLayerDiscoveryInfo{} }
func (m *LinkLayerDiscoveryInfo) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscoveryInfo) ProtoMessage()    {}
func (*LinkLayerDiscoveryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{24}
}
func (m *LinkLayerDiscoveryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscoveryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinkLayerDiscoveryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscoveryInfo.Merge(dst, src)
}
func (m *LinkLayerDiscoveryInfo) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscoveryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscoveryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscoveryInfo proto.InternalMessageInfo

func (m *LinkLayerDiscoveryInfo) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetPortDescription() string {
	if m != nil {
		return m.PortDescription
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysDescription() string {
	if m != nil {
		return m.SysDescription
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysCapabilities() *LLDPSysCapabilities {
	if m != nil {
		return m.SysCapabilities
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetMgmtAddress() *LLDPMgmtAddress {
	if m != nil {
		return m.MgmtAddress
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetOrgTLVs() []*LLDPOrgSpecificTLV {
	if m != nil {
		return m.OrgTLVs
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetUnknown() []*LinkLayerDiscoveryValue {
	if m != nil {
		return m.Unknown
	}
	return nil
}

type LLDPSysCapabilities struct {
	SystemCap  *LLDPCapabilities `protobuf:"bytes,1,opt,name=SystemCap" json:"SystemCap,omitempty"`
	EnabledCap *LLDPCapabilities `protobuf:"bytes,2,opt,name=EnabledCap" json:"EnabledCap,omitempty"`
}

func (m *LLDPSysCapabilities) Reset()         { *m = LLDPSysCapabilities{} }
func (m *LLDPSysCapabilities) String() string { return proto.CompactTextString(m) }
func (*LLDPSysCapabilities) ProtoMessage()    {}
func (*LLDPSysCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{25}
}
func (m *LLDPSysCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPSysCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPSysCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPSysCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPSysCapabilities.Merge(dst, src)
}
func (m *LLDPSysCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *LLDPSysCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPSysCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPSysCapabilities proto.InternalMessageInfo

func (m *LLDPSysCapabilities) GetSystemCap() *LLDPCapabilities {
	if m != nil {
		return m.SystemCap
	}
	return nil
}

func (m *LLDPSysCapabilities) GetEnabledCap() *LLDPCapabilities {
	if m != nil {
		return m.EnabledCap
	}
	return nil
}

type LLDPCapabilities struct {
	Other       bool `protobuf:"varint,1,opt,name=Other,proto3" json:"Other,omitempty"`
	Repeater    bool `protobuf:"varint,2,opt,name=Repeater,proto3" json:"Repeater,omitempty"`
	Bridge      bool `protobuf:"varint,3,opt,name=Bridge,proto3" json:"Bridge,omitempty"`
	WLANAP      bool `protobuf:"varint,4,opt,name=WLANAP,proto3" json:"WLANAP,omitempty"`
	Router      bool `protobuf:"varint,5,opt,name=Router,proto3" json:"Router,omitempty"`
	Phone       bool `protobuf:"varint,6,opt,name=Phone,proto3" json:"Phone,omitempty"`
	DocSis      bool `protobuf:"varint,7,opt,name=DocSis,proto3" json:"DocSis,omitempty"`
	StationOnly bool `protobuf:"varint,8,opt,name=StationOnly,proto3" json:"StationOnly,omitempty"`
	CVLAN       bool `protobuf:"varint,9,opt,name=CVLAN,proto3" json:"CVLAN,omitempty"`
	SVLAN       bool `protobuf:"varint,10,opt,name=SVLAN,proto3" json:"SVLAN,omitempty"`
	TMPR        bool `protobuf:"varint,11,opt,name=TMPR,proto3" json:"TMPR,omitempty"`
}

func (m *LLDPCapabilities) Reset()         { *m = LLDPCapabilities{} }
func (m *LLDPCapabilities) String() string { return proto.CompactTextString(m) }
func (*LLDPCapabilities) ProtoMessage()    {}
func (*LLDPCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{26}
}
func (m *LLDPCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPCapabilities.Merge(dst, src)
}
func (m *LLDPCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *LLDPCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPCapabilities proto.InternalMessageInfo

func (m *LLDPCapabilities) GetOther() bool {
	if m != nil {
		return m.Other
	}
	return false
}

func (m *LLDPCapabilities) GetRepeater() bool {
	if m != nil {
		return m.Repeater
	}
	return false
}

func (m *LLDPCapabilities) GetBridge() bool {
	if m != nil {
		return m.Bridge
	}
	return false
}

func (m *LLDPCapabilities) GetWLANAP() bool {
	if m != nil {
		return m.WLANAP
	}
	return false
}

func (m *LLDPCapabilities) GetRouter() bool {
	if m != nil {
		return m.Router
	}
	return false
}

func (m *LLDPCapabilities) GetPhone() bool {
	if m != nil {
		return m.Phone
	}
	return false
}

func (m *LLDPCapabilities) GetDocSis() bool {
	if m != nil {
		return m.DocSis
	}
	return false
}

func (m *LLDPCapabilities) GetStationOnly() bool {
	if m != nil {
		return m.StationOnly
	}
	return false
}

func (m *LLDPCapabilities) GetCVLAN() bool {
	if m != nil {
		return m.CVLAN
	}
	return false
}

func (m *LLDPCapabilities) GetSVLAN() bool {
	if m != nil {
		return m.SVLAN
	}
	return false
}

func (m *LLDPCapabilities) GetTMPR() bool {
	if m != nil {
		return m.TMPR
	}
	return false
}

type LLDPMgmtAddress struct {
	Subtype          int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	Address          []byte `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	InterfaceSubtype int32  `protobuf:"varint,3,opt,name=InterfaceSubtype,proto3" json:"InterfaceSubtype,omitempty"`
	InterfaceNumber  uint32 `protobuf:"varint,4,opt,name=InterfaceNumber,proto3" json:"InterfaceNumber,omitempty"`
	OID              string `protobuf:"bytes,5,opt,name=OID,proto3" json:"OID,omitempty"`
}

func (m *LLDPMgmtAddress) Reset()         { *m = LLDPMgmtAddress{} }
func (m *LLDPMgmtAddress) String() string { return proto.CompactTextString(m) }
func (*LLDPMgmtAddress) ProtoMessage()    {}
func (*LLDPMgmtAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{27}
}
func (m *LLDPMgmtAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPMgmtAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPMgmtAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPMgmtAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPMgmtAddress.Merge(dst, src)
}
func (m *LLDPMgmtAddress) XXX_Size() int {
	return m.Size()
}
func (m *LLDPMgmtAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPMgmtAddress.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPMgmtAddress proto.InternalMessageInfo

func (m *LLDPMgmtAddress) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPMgmtAddress) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *LLDPMgmtAddress) GetInterfaceSubtype() int32 {
	if m != nil {
		return m.InterfaceSubtype
	}
	return 0
}

func (m *LLDPMgmtAddress) GetInterfaceNumber() uint32 {
	if m != nil {
		return m.InterfaceNumber
	}
	return 0
}

func (m *LLDPMgmtAddress) GetOID() string {
	if m != nil {
		return m.OID
	}
	return ""
}

type LLDPOrgSpecificTLV struct {
	OUI     uint32 `protobuf:"varint,1,opt,name=OUI,proto3" json:"OUI,omitempty"`
	SubType int32  `protobuf:"varint,2,opt,name=SubType,proto3" json:"SubType,omitempty"`
	Info    []byte `protobuf:"bytes,3,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *LLDPOrgSpecificTLV) Reset()         { *m = LLDPOrgSpecificTLV{} }
func (m *LLDPOrgSpecificTLV) String() string { return proto.CompactTextString(m) }
func (*LLDPOrgSpecificTLV) ProtoMessage()    {}
func (*LLDPOrgSpecificTLV) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{28}
}
func (m *LLDPOrgSpecificTLV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPOrgSpecificTLV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPOrgSpecificTLV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLDPOrgSpecificTLV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPOrgSpecificTLV.Merge(dst, src)
}
func (m *LLDPOrgSpecificTLV) XXX_Size() int {
	return m.Size()
}
func (m *LLDPOrgSpecificTLV) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPOrgSpecificTLV.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPOrgSpecificTLV proto.InternalMessageInfo

func (m *LLDPOrgSpecificTLV) GetOUI() uint32 {
	if m != nil {
		return m.OUI
	}
	return 0
}

func (m *LLDPOrgSpecificTLV) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *LLDPOrgSpecificTLV) GetInfo() []byte {
	if m != nil {
		return m.Info
	}
	return nil
}

type IPv4 struct {
	Timestamp      string        `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32         `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	IHL            int32         `protobuf:"varint,3,opt,name=IHL,proto3" json:"IHL,omitempty"`
	TOS            int32         `protobuf:"varint,4,opt,name=TOS,proto3" json:"TOS,omitempty"`
	Length         int32         `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
	Id             int32         `protobuf:"varint,6,opt,name=Id,proto3" json:"Id,omitempty"`
	Flags          int32         `protobuf:"varint,7,opt,name=Flags,proto3" json:"Flags,omitempty"`
	FragOffset     int32         `protobuf:"varint,8,opt,name=FragOffset,proto3" json:"FragOffset,omitempty"`
	TTL            int32         `protobuf:"varint,9,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Protocol       int32         `protobuf:"varint,10,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Checksum       int32         `protobuf:"varint,11,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	SrcIP          string        `protobuf:"bytes,12,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string        `protobuf:"bytes,13,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	Padding        []byte        `protobuf:"bytes,14,opt,name=Padding,proto3" json:"Padding,omitempty"`
	Options        []*IPv4Option `protobuf:"bytes,15,rep,name=Options" json:"Options,omitempty"`
	PayloadEntropy float64       `protobuf:"fixed64,16,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32         `protobuf:"varint,17,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
}

func (m *IPv4) Reset()         { *m = IPv4{} }
func (m *IPv4) String() string { return proto.CompactTextString(m) }
func (*IPv4) ProtoMessage()    {}
func (*IPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{29}
}
func (m *IPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4.Merge(dst, src)
}
func (m *IPv4) XXX_Size() int {
	return m.Size()
}
func (m *IPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4 proto.InternalMessageInfo

func (m *IPv4) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPv4) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IPv4) GetIHL() int32 {
	if m != nil {
		return m.IHL
	}
	return 0
}

func (m *IPv4) GetTOS() int32 {
	if m != nil {
		return m.TOS
	}
	return 0
}

func (m *IPv4) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *IPv4) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IPv4) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *IPv4) GetFragOffset() int32 {
	if m != nil {
		return m.FragOffset
	}
	return 0
}

func (m *IPv4) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *IPv4) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *IPv4) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *IPv4) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv4) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *IPv4) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

func (m *IPv4) GetOptions() []*IPv4Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *IPv4) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *IPv4) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

type IPv4Option struct {
	OptionType   int32  `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength int32  `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	OptionData   []byte `protobuf:"bytes,3,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
}

func (m *IPv4Option) Reset()         { *m = IPv4Option{} }
func (m *IPv4Option) String() string { return proto.CompactTextString(m) }
func (*IPv4Option) ProtoMessage()    {}
func (*IPv4Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{30}
}
func (m *IPv4Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv4Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4Option.Merge(dst, src)
}
func (m *IPv4Option) XXX_Size() int {
	return m.Size()
}
func (m *IPv4Option) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4Option.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4Option proto.InternalMessageInfo

func (m *IPv4Option) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *IPv4Option) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *IPv4Option) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

type IPv6 struct {
	Timestamp      string        `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32         `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	TrafficClass   int32         `protobuf:"varint,3,opt,name=TrafficClass,proto3" json:"TrafficClass,omitempty"`
	FlowLabel      uint32        `protobuf:"varint,4,opt,name=FlowLabel,proto3" json:"FlowLabel,omitempty"`
	Length         int32         `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
	NextHeader     int32         `protobuf:"varint,6,opt,name=NextHeader,proto3" json:"NextHeader,omitempty"`
	HopLimit       int32         `protobuf:"varint,7,opt,name=HopLimit,proto3" json:"HopLimit,omitempty"`
	SrcIP          string        `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string        `protobuf:"bytes,9,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	PayloadEntropy float64       `protobuf:"fixed64,10,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32         `protobuf:"varint,11,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	HopByHop       *IPv6HopByHop `protobuf:"bytes,12,opt,name=HopByHop" json:"HopByHop,omitempty"`
}

func (m *IPv6) Reset()         { *m = IPv6{} }
func (m *IPv6) String() string { return proto.CompactTextString(m) }
func (*IPv6) ProtoMessage()    {}
func (*IPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{31}
}
func (m *IPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6.Merge(dst, src)
}
func (m *IPv6) XXX_Size() int {
	return m.Size()
}
func (m *IPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6 proto.InternalMessageInfo

func (m *IPv6) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPv6) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IPv6) GetTrafficClass() int32 {
	if m != nil {
		return m.TrafficClass
	}
	return 0
}

func (m *IPv6) GetFlowLabel() uint32 {
	if m != nil {
		return m.FlowLabel
	}
	return 0
}

func (m *IPv6) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *IPv6) GetNextHeader() int32 {
	if m != nil {
		return m.NextHeader
	}
	return 0
}

func (m *IPv6) GetHopLimit() int32 {
	if m != nil {
		return m.HopLimit
	}
	return 0
}

func (m *IPv6) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv6) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *IPv6) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *IPv6) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *IPv6) GetHopByHop() *IPv6HopByHop {
	if m != nil {
		return m.HopByHop
	}
	return nil
}

type IPv6Fragment struct {
	Timestamp      string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	NextHeader     int32  `protobuf:"varint,2,opt,name=NextHeader,proto3" json:"NextHeader,omitempty"`
	Reserved1      int32  `protobuf:"varint,3,opt,name=Reserved1,proto3" json:"Reserved1,omitempty"`
	FragmentOffset int32  `protobuf:"varint,4,opt,name=FragmentOffset,proto3" json:"FragmentOffset,omitempty"`
	Reserved2      int32  `protobuf:"varint,5,opt,name=Reserved2,proto3" json:"Reserved2,omitempty"`
	MoreFragments  bool   `protobuf:"varint,6,opt,name=MoreFragments,proto3" json:"MoreFragments,omitempty"`
	Identification uint32 `protobuf:"varint,7,opt,name=Identification,proto3" json:"Identification,omitempty"`
}

func (m *IPv6Fragment) Reset()         { *m = IPv6Fragment{} }
func (m *IPv6Fragment) String() string { return proto.CompactTextString(m) }
func (*IPv6Fragment) ProtoMessage()    {}
func (*IPv6Fragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{32}
}
func (m *IPv6Fragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6Fragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6Fragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv6Fragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6Fragment.Merge(dst, src)
}
func (m *IPv6Fragment) XXX_Size() int {
	return m.Size()
}
func (m *IPv6Fragment) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6Fragment.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6Fragment proto.InternalMessageInfo

func (m *IPv6Fragment) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPv6Fragment) GetNextHeader() int32 {
	if m != nil {
		return m.NextHeader
	}
	return 0
}

func (m *IPv6Fragment) GetReserved1() int32 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

func (m *IPv6Fragment) GetFragmentOffset() int32 {
	if m != nil {
		return m.FragmentOffset
	}
	return 0
}

func (m *IPv6Fragment) GetReserved2() int32 {
	if m != nil {
		return m.Reserved2
	}
	return 0
}

func (m *IPv6Fragment) GetMoreFragments() bool {
	if m != nil {
		return m.MoreFragments
	}
	return false
}

func (m *IPv6Fragment) GetIdentification() uint32 {
	if m != nil {
		return m.Identification
	}
	return 0
}

type ICMPv4 struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TypeCode  int32  `protobuf:"varint,2,opt,name=TypeCode,proto3" json:"TypeCode,omitempty"`
	Checksum  int32  `protobuf:"varint,3,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Id        int32  `protobuf:"varint,4,opt,name=Id,proto3" json:"Id,omitempty"`
	Seq       int32  `protobuf:"varint,5,opt,name=Seq,proto3" json:"Seq,omitempty"`
}

func (m *ICMPv4) Reset()         { *m = ICMPv4{} }
func (m *ICMPv4) String() string { return proto.CompactTextString(m) }
func (*ICMPv4) ProtoMessage()    {}
func (*ICMPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{33}
}
func (m *ICMPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv4.Merge(dst, src)
}
func (m *ICMPv4) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv4.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv4 proto.InternalMessageInfo

func (m *ICMPv4) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv4) GetTypeCode() int32 {
	if m != nil {
		return m.TypeCode
	}
	return 0
}

func (m *ICMPv4) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *ICMPv4) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ICMPv4) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type ICMPv6 struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TypeCode  int32  `protobuf:"varint,2,opt,name=TypeCode,proto3" json:"TypeCode,omitempty"`
	Checksum  int32  `protobuf:"varint,3,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
}

func (m *ICMPv6) Reset()         { *m = ICMPv6{} }
func (m *ICMPv6) String() string { return proto.CompactTextString(m) }
func (*ICMPv6) ProtoMessage()    {}
func (*ICMPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{34}
}
func (m *ICMPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6.Merge(dst, src)
}
func (m *ICMPv6) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6 proto.InternalMessageInfo

func (m *ICMPv6) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6) GetTypeCode() int32 {
	if m != nil {
		return m.TypeCode
	}
	return 0
}

func (m *ICMPv6) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

type ICMPv6NeighborAdvertisement struct {
	Timestamp     string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Flags         int32           `protobuf:"varint,2,opt,name=Flags,proto3" json:"Flags,omitempty"`
	TargetAddress string          `protobuf:"bytes,3,opt,name=TargetAddress,proto3" json:"TargetAddress,omitempty"`
	Options       []*ICMPv6Option `protobuf:"bytes,4,rep,name=Options" json:"Options,omitempty"`
}

func (m *ICMPv6NeighborAdvertisement) Reset()         { *m = ICMPv6NeighborAdvertisement{} }
func (m *ICMPv6NeighborAdvertisement) String() string { return proto.CompactTextString(m) }
func (*ICMPv6NeighborAdvertisement) ProtoMessage()    {}
func (*ICMPv6NeighborAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{35}
}
func (m *ICMPv6NeighborAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6NeighborAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6NeighborAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6NeighborAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6NeighborAdvertisement.Merge(dst, src)
}
func (m *ICMPv6NeighborAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6NeighborAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6NeighborAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6NeighborAdvertisement proto.InternalMessageInfo

func (m *ICMPv6NeighborAdvertisement) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6NeighborAdvertisement) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ICMPv6NeighborAdvertisement) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *ICMPv6NeighborAdvertisement) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type ICMPv6RouterAdvertisement struct {
	Timestamp      string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	HopLimit       int32           `protobuf:"varint,2,opt,name=HopLimit,proto3" json:"HopLimit,omitempty"`
	Flags          int32           `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	RouterLifetime int32           `protobuf:"varint,4,opt,name=RouterLifetime,proto3" json:"RouterLifetime,omitempty"`
	ReachableTime  uint32          `protobuf:"varint,5,opt,name=ReachableTime,proto3" json:"ReachableTime,omitempty"`
	RetransTimer   uint32          `protobuf:"varint,6,opt,name=RetransTimer,proto3" json:"RetransTimer,omitempty"`
	Options        []*ICMPv6Option `protobuf:"bytes,7,rep,name=Options" json:"Options,omitempty"`
}

func (m *ICMPv6RouterAdvertisement) Reset()         { *m = ICMPv6RouterAdvertisement{} }
func (m *ICMPv6RouterAdvertisement) String() string { return proto.CompactTextString(m) }
func (*ICMPv6RouterAdvertisement) ProtoMessage()    {}
func (*ICMPv6RouterAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{36}
}
func (m *ICMPv6RouterAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6RouterAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6RouterAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6RouterAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6RouterAdvertisement.Merge(dst, src)
}
func (m *ICMPv6RouterAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6RouterAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6RouterAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6RouterAdvertisement proto.InternalMessageInfo

func (m *ICMPv6RouterAdvertisement) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6RouterAdvertisement) GetHopLimit() int32 {
	if m != nil {
		return m.HopLimit
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetRouterLifetime() int32 {
	if m != nil {
		return m.RouterLifetime
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetReachableTime() uint32 {
	if m != nil {
		return m.ReachableTime
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetRetransTimer() uint32 {
	if m != nil {
		return m.RetransTimer
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type ICMPv6Option struct {
	Type int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ICMPv6Option) Reset()         { *m = ICMPv6Option{} }
func (m *ICMPv6Option) String() string { return proto.CompactTextString(m) }
func (*ICMPv6Option) ProtoMessage()    {}
func (*ICMPv6Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{37}
}
func (m *ICMPv6Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6Option.Merge(dst, src)
}
func (m *ICMPv6Option) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6Option) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6Option.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6Option proto.InternalMessageInfo

func (m *ICMPv6Option) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv6Option) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UDP struct {
	Timestamp      string  `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort        int32   `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32   `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	Length         int32   `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Checksum       int32   `protobuf:"varint,5,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	PayloadEntropy float64 `protobuf:"fixed64,6,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32   `protobuf:"varint,7,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	Payload        []byte  `protobuf:"bytes,8,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *UDP) Reset()         { *m = UDP{} }
func (m *UDP) String() string { return proto.CompactTextString(m) }
func (*UDP) ProtoMessage()    {}
func (*UDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{38}
}
func (m *UDP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UDP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDP.Merge(dst, src)
}
func (m *UDP) XXX_Size() int {
	return m.Size()
}
func (m *UDP) XXX_DiscardUnknown() {
	xxx_messageInfo_UDP.DiscardUnknown(m)
}

var xxx_messageInfo_UDP proto.InternalMessageInfo

func (m *UDP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *UDP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *UDP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *UDP) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *UDP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *UDP) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *UDP) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *UDP) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type TCP struct {
	Timestamp      string       `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort        int32        `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32        `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	SeqNum         uint32       `protobuf:"varint,4,opt,name=SeqNum,proto3" json:"SeqNum,omitempty"`
	AckNum         uint32       `protobuf:"varint,5,opt,name=AckNum,proto3" json:"AckNum,omitempty"`
	DataOffset     int32        `protobuf:"varint,6,opt,name=DataOffset,proto3" json:"DataOffset,omitempty"`
	FIN            bool         `protobuf:"varint,7,opt,name=FIN,proto3" json:"FIN,omitempty"`
	SYN            bool         `protobuf:"varint,8,opt,name=SYN,proto3" json:"SYN,omitempty"`
	RST            bool         `protobuf:"varint,9,opt,name=RST,proto3" json:"RST,omitempty"`
	PSH            bool         `protobuf:"varint,10,opt,name=PSH,proto3" json:"PSH,omitempty"`
	ACK            bool         `protobuf:"varint,11,opt,name=ACK,proto3" json:"ACK,omitempty"`
	URG            bool         `protobuf:"varint,12,opt,name=URG,proto3" json:"URG,omitempty"`
	ECE            bool         `protobuf:"varint,13,opt,name=ECE,proto3" json:"ECE,omitempty"`
	CWR            bool         `protobuf:"varint,14,opt,name=CWR,proto3" json:"CWR,omitempty"`
	NS             bool         `protobuf:"varint,15,opt,name=NS,proto3" json:"NS,omitempty"`
	Window         int32        `protobuf:"varint,16,opt,name=Window,proto3" json:"Window,omitempty"`
	Checksum       int32        `protobuf:"varint,17,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Urgent         int32        `protobuf:"varint,18,opt,name=Urgent,proto3" json:"Urgent,omitempty"`
	Padding        []byte       `protobuf:"bytes,19,opt,name=Padding,proto3" json:"Padding,omitempty"`
	Options        []*TCPOption `protobuf:"bytes,20,rep,name=Options" json:"Options,omitempty"`
	PayloadEntropy float64      `protobuf:"fixed64,21,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32        `protobuf:"varint,22,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	Payload        []byte       `protobuf:"bytes,23,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *TCP) Reset()         { *m = TCP{} }
func (m *TCP) String() string { return proto.CompactTextString(m) }
func (*TCP) ProtoMessage()    {}
func (*TCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{39}
}
func (m *TCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCP.Merge(dst, src)
}
func (m *TCP) XXX_Size() int {
	return m.Size()
}
func (m *TCP) XXX_DiscardUnknown() {
	xxx_messageInfo_TCP.DiscardUnknown(m)
}

var xxx_messageInfo_TCP proto.InternalMessageInfo

func (m *TCP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *TCP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TCP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TCP) GetSeqNum() uint32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *TCP) GetAckNum() uint32 {
	if m != nil {
		return m.AckNum
	}
	return 0
}

func (m *TCP) GetDataOffset() int32 {
	if m != nil {
		return m.DataOffset
	}
	return 0
}

func (m *TCP) GetFIN() bool {
	if m != nil {
		return m.FIN
	}
	return false
}

func (m *TCP) GetSYN() bool {
	if m != nil {
		return m.SYN
	}
	return false
}

func (m *TCP) GetRST() bool {
	if m != nil {
		return m.RST
	}
	return false
}

func (m *TCP) GetPSH() bool {
	if m != nil {
		return m.PSH
	}
	return false
}

func (m *TCP) GetACK() bool {
	if m != nil {
		return m.ACK
	}
	return false
}

func (m *TCP) GetURG() bool {
	if m != nil {
		return m.URG
	}
	return false
}

func (m *TCP) GetECE() bool {
	if m != nil {
		return m.ECE
	}
	return false
}

func (m *TCP) GetCWR() bool {
	if m != nil {
		return m.CWR
	}
	return false
}

func (m *TCP) GetNS() bool {
	if m != nil {
		return m.NS
	}
	return false
}

func (m *TCP) GetWindow() int32 {
	if m != nil {
		return m.Window
	}
	return 0
}

func (m *TCP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *TCP) GetUrgent() int32 {
	if m != nil {
		return m.Urgent
	}
	return 0
}

func (m *TCP) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

func (m *TCP) GetOptions() []*TCPOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *TCP) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *TCP) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *TCP) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type TCPOption struct {
	OptionType   int32  `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength int32  `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	OptionData   []byte `protobuf:"bytes,3,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
}

func (m *TCPOption) Reset()         { *m = TCPOption{} }
func (m *TCPOption) String() string { return proto.CompactTextString(m) }
func (*TCPOption) ProtoMessage()    {}
func (*TCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{40}
}
func (m *TCPOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPOption.Merge(dst, src)
}
func (m *TCPOption) XXX_Size() int {
	return m.Size()
}
func (m *TCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_TCPOption proto.InternalMessageInfo

func (m *TCPOption) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *TCPOption) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *TCPOption) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

type SCTP struct {
	Timestamp       string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort         uint32 `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort         uint32 `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	VerificationTag uint32 `protobuf:"varint,4,opt,name=VerificationTag,proto3" json:"VerificationTag,omitempty"`
	Checksum        uint32 `protobuf:"varint,5,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
}

func (m *SCTP) Reset()         { *m = SCTP{} }
func (m *SCTP) String() string { return proto.CompactTextString(m) }
func (*SCTP) ProtoMessage()    {}
func (*SCTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{41}
}
func (m *SCTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SCTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCTP.Merge(dst, src)
}
func (m *SCTP) XXX_Size() int {
	return m.Size()
}
func (m *SCTP) XXX_DiscardUnknown() {
	xxx_messageInfo_SCTP.DiscardUnknown(m)
}

var xxx_messageInfo_SCTP proto.InternalMessageInfo

func (m *SCTP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *SCTP) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SCTP) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SCTP) GetVerificationTag() uint32 {
	if m != nil {
		return m.VerificationTag
	}
	return 0
}

func (m *SCTP) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

type DNS struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	// Header fields
	ID           int32 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	QR           bool  `protobuf:"varint,3,opt,name=QR,proto3" json:"QR,omitempty"`
	OpCode       int32 `protobuf:"varint,4,opt,name=OpCode,proto3" json:"OpCode,omitempty"`
	AA           bool  `protobuf:"varint,5,opt,name=AA,proto3" json:"AA,omitempty"`
	TC           bool  `protobuf:"varint,6,opt,name=TC,proto3" json:"TC,omitempty"`
	RD           bool  `protobuf:"varint,7,opt,name=RD,proto3" json:"RD,omitempty"`
	RA           bool  `protobuf:"varint,8,opt,name=RA,proto3" json:"RA,omitempty"`
	Z            int32 `protobuf:"varint,9,opt,name=Z,proto3" json:"Z,omitempty"`
	ResponseCode int32 `protobuf:"varint,10,opt,name=ResponseCode,proto3" json:"ResponseCode,omitempty"`
	QDCount      int32 `protobuf:"varint,11,opt,name=QDCount,proto3" json:"QDCount,omitempty"`
	ANCount      int32 `protobuf:"varint,12,opt,name=ANCount,proto3" json:"ANCount,omitempty"`
	NSCount      int32 `protobuf:"varint,13,opt,name=NSCount,proto3" json:"NSCount,omitempty"`
	ARCount      int32 `protobuf:"varint,14,opt,name=ARCount,proto3" json:"ARCount,omitempty"`
	// Entries
	Questions   []*DNSQuestion       `protobuf:"bytes,15,rep,name=Questions" json:"Questions,omitempty"`
	Answers     []*DNSResourceRecord `protobuf:"bytes,16,rep,name=Answers" json:"Answers,omitempty"`
	Authorities []*DNSResourceRecord `protobuf:"bytes,17,rep,name=Authorities" json:"Authorities,omitempty"`
	Additionals []*DNSResourceRecord `protobuf:"bytes,18,rep,name=Additionals" json:"Additionals,omitempty"`
}

func (m *DNS) Reset()         { *m = DNS{} }
func (m *DNS) String() string { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()    {}
func (*DNS) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{42}
}
func (m *DNS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNS.Merge(dst, src)
}
func (m *DNS) XXX_Size() int {
	return m.Size()
}
func (m *DNS) XXX_DiscardUnknown() {
	xxx_messageInfo_DNS.DiscardUnknown(m)
}

var xxx_messageInfo_DNS proto.InternalMessageInfo

func (m *DNS) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *DNS) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DNS) GetQR() bool {
	if m != nil {
		return m.QR
	}
	return false
}

func (m *DNS) GetOpCode() int32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *DNS) GetAA() bool {
	if m != nil {
		return m.AA
	}
	return false
}

func (m *DNS) GetTC() bool {
	if m != nil {
		return m.TC
	}
	return false
}

func (m *DNS) GetRD() bool {
	if m != nil {
		return m.RD
	}
	return false
}

func (m *DNS) GetRA() bool {
	if m != nil {
		return m.RA
	}
	return false
}

func (m *DNS) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *DNS) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *DNS) GetQDCount() int32 {
	if m != nil {
		return m.QDCount
	}
	return 0
}

func (m *DNS) GetANCount() int32 {
	if m != nil {
		return m.ANCount
	}
	return 0
}

func (m *DNS) GetNSCount() int32 {
	if m != nil {
		return m.NSCount
	}
	return 0
}

func (m *DNS) GetARCount() int32 {
	if m != nil {
		return m.ARCount
	}
	return 0
}

func (m *DNS) GetQuestions() []*DNSQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *DNS) GetAnswers() []*DNSResourceRecord {
	if m != nil {
		return m.Answers
	}
	return nil
}

func (m *DNS) GetAuthorities() []*DNSResourceRecord {
	if m != nil {
		return m.Authorities
	}
	return nil
}

func (m *DNS) GetAdditionals() []*DNSResourceRecord {
	if m != nil {
		return m.Additionals
	}
	return nil
}

type DNSResourceRecord struct {
	// Header
	Name  []byte `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type  int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Class int32  `protobuf:"varint,3,opt,name=Class,proto3" json:"Class,omitempty"`
	TTL   uint32 `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	// RDATA Raw Values
	DataLength int32  `protobuf:"varint,5,opt,name=DataLength,proto3" json:"DataLength,omitempty"`
	Data       []byte `protobuf:"bytes,6,opt,name=Data,proto3" json:"Data,omitempty"`
	// RDATA Decoded Values
	IP    string   `protobuf:"bytes,7,opt,name=IP,proto3" json:"IP,omitempty"`
	NS    []byte   `protobuf:"bytes,8,opt,name=NS,proto3" json:"NS,omitempty"`
	CNAME []byte   `protobuf:"bytes,9,opt,name=CNAME,proto3" json:"CNAME,omitempty"`
	PTR   []byte   `protobuf:"bytes,10,opt,name=PTR,proto3" json:"PTR,omitempty"`
	SOA   *DNSSOA  `protobuf:"bytes,11,opt,name=SOA" json:"SOA,omitempty"`
	SRV   *DNSSRV  `protobuf:"bytes,12,opt,name=SRV" json:"SRV,omitempty"`
	MX    *DNSMX   `protobuf:"bytes,13,opt,name=MX" json:"MX,omitempty"`
	TXTs  [][]byte `protobuf:"bytes,14,rep,name=TXTs" json:"TXTs,omitempty"`
}

func (m *DNSResourceRecord) Reset()         { *m = DNSResourceRecord{} }
func (m *DNSResourceRecord) String() string { return proto.CompactTextString(m) }
func (*DNSResourceRecord) ProtoMessage()    {}
func (*DNSResourceRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{43}
}
func (m *DNSResourceRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSResourceRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSResourceRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNSResourceRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSResourceRecord.Merge(dst, src)
}
func (m *DNSResourceRecord) XXX_Size() int {
	return m.Size()
}
func (m *DNSResourceRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSResourceRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DNSResourceRecord proto.InternalMessageInfo

func (m *DNSResourceRecord) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *DNSResourceRecord) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DNSResourceRecord) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

func (m *DNSResourceRecord) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *DNSResourceRecord) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *DNSResourceRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DNSResourceRecord) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *DNSResourceRecord) GetNS() []byte {
	if m != nil {
		return m.NS
	}
	return nil
}

func (m *DNSResourceRecord) GetCNAME() []byte {
	if m != nil {
		return m.CNAME
	}
	return nil
}

func (m *DNSResourceRecord) GetPTR() []byte {
	if m != nil {
		return m.PTR
	}
	return nil
}

func (m *DNSResourceRecord) GetSOA() *DNSSOA {
	if m != nil {
		return m.SOA
	}
	return nil
}

func (m *DNSResourceRecord) GetSRV() *DNSSRV {
	if m != nil {
		return m.SRV
	}
	return nil
}

func (m *DNSResourceRecord) GetMX() *DNSMX {
	if m != nil {
		return m.MX
	}
	return nil
}

func (m *DNSResourceRecord) GetTXTs() [][]byte {
	if m != nil {
		return m.TXTs
	}
	return nil
}

// DNSSOA is a Start of Authority record.
// Each domain requires a SOA record at the cutover where a domain is delegated from its parent.
type DNSSOA struct {
	MName   []byte `protobuf:"bytes,1,opt,name=MName,proto3" json:"MName,omitempty"`
	RName   []byte `protobuf:"bytes,2,opt,name=RName,proto3" json:"RName,omitempty"`
	Serial  uint32 `protobuf:"varint,3,opt,name=Serial,proto3" json:"Serial,omitempty"`
	Refresh uint32 `protobuf:"varint,4,opt,name=Refresh,proto3" json:"Refresh,omitempty"`
	Retry   uint32 `protobuf:"varint,5,opt,name=Retry,proto3" json:"Retry,omitempty"`
	Expire  uint32 `protobuf:"varint,6,opt,name=Expire,proto3" json:"Expire,omitempty"`
	Minimum uint32 `protobuf:"varint,7,opt,name=Minimum,proto3" json:"Minimum,omitempty"`
}

func (m *DNSSOA) Reset()         { *m = DNSSOA{} }
func (m *DNSSOA) String() string { return proto.CompactTextString(m) }
func (*DNSSOA) ProtoMessage()    {}
func (*DNSSOA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{44}
}
func (m *DNSSOA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSSOA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSSOA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNSSOA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSSOA.Merge(dst, src)
}
func (m *DNSSOA) XXX_Size() int {
	return m.Size()
}
func (m *DNSSOA) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSSOA.DiscardUnknown(m)
}

var xxx_messageInfo_DNSSOA proto.InternalMessageInfo

func (m *DNSSOA) GetMName() []byte {
	if m != nil {
		return m.MName
	}
	return nil
}

func (m *DNSSOA) GetRName() []byte {
	if m != nil {
		return m.RName
	}
	return nil
}

func (m *DNSSOA) GetSerial() uint32 {
	if m != nil {
		return m.Serial
	}
	return 0
}

func (m *DNSSOA) GetRefresh() uint32 {
	if m != nil {
		return m.Refresh
	}
	return 0
}

func (m *DNSSOA) GetRetry() uint32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *DNSSOA) GetExpire() uint32 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *DNSSOA) GetMinimum() uint32 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

// DNSSRV is a Service record, defining a location (hostname/port) of a server/service.
type DNSSRV struct {
	Priority int32  `protobuf:"varint,1,opt,name=Priority,proto3" json:"Priority,omitempty"`
	Weight   int32  `protobuf:"varint,2,opt,name=Weight,proto3" json:"Weight,omitempty"`
	Port     int32  `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
	Name     []byte `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *DNSSRV) Reset()         { *m = DNSSRV{} }
func (m *DNSSRV) String() string { return proto.CompactTextString(m) }
func (*DNSSRV) ProtoMessage()    {}
func (*DNSSRV) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{45}
}
func (m *DNSSRV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSSRV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSSRV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNSSRV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSSRV.Merge(dst, src)
}
func (m *DNSSRV) XXX_Size() int {
	return m.Size()
}
func (m *DNSSRV) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSSRV.DiscardUnknown(m)
}

var xxx_messageInfo_DNSSRV proto.InternalMessageInfo

func (m *DNSSRV) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *DNSSRV) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *DNSSRV) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DNSSRV) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// DNSMX is a mail exchange record, defining a mail server for a recipient's domain.
type DNSMX struct {
	Preference int32  `protobuf:"varint,1,opt,name=Preference,proto3" json:"Preference,omitempty"`
	Name       []byte `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *DNSMX) Reset()         { *m = DNSMX{} }
func (m *DNSMX) String() string { return proto.CompactTextString(m) }
func (*DNSMX) ProtoMessage()    {}
func (*DNSMX) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{46}
}
func (m *DNSMX) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSMX) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSMX.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNSMX) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSMX.Merge(dst, src)
}
func (m *DNSMX) XXX_Size() int {
	return m.Size()
}
func (m *DNSMX) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSMX.DiscardUnknown(m)
}

var xxx_messageInfo_DNSMX proto.InternalMessageInfo

func (m *DNSMX) GetPreference() int32 {
	if m != nil {
		return m.Preference
	}
	return 0
}

func (m *DNSMX) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// DNSQuestion wraps a single request (question) within a DNS query.
type DNSQuestion struct {
	Name  []byte `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type  int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Class int32  `protobuf:"varint,3,opt,name=Class,proto3" json:"Class,omitempty"`
}

func (m *DNSQuestion) Reset()         { *m = DNSQuestion{} }
func (m *DNSQuestion) String() string { return proto.CompactTextString(m) }
func (*DNSQuestion) ProtoMessage()    {}
func (*DNSQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{47}
}
func (m *DNSQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DNSQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSQuestion.Merge(dst, src)
}
func (m *DNSQuestion) XXX_Size() int {
	return m.Size()
}
func (m *DNSQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_DNSQuestion proto.InternalMessageInfo

func (m *DNSQuestion) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *DNSQuestion) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DNSQuestion) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

type DHCPv4 struct {
	Timestamp    string        `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Operation    int32         `protobuf:"varint,2,opt,name=Operation,proto3" json:"Operation,omitempty"`
	HardwareType int32         `protobuf:"varint,3,opt,name=HardwareType,proto3" json:"HardwareType,omitempty"`
	HardwareLen  int32         `protobuf:"varint,4,opt,name=HardwareLen,proto3" json:"HardwareLen,omitempty"`
	HardwareOpts int32         `protobuf:"varint,5,opt,name=HardwareOpts,proto3" json:"HardwareOpts,omitempty"`
	Xid          uint32        `protobuf:"varint,6,opt,name=Xid,proto3" json:"Xid,omitempty"`
	Secs         int32         `protobuf:"varint,7,opt,name=Secs,proto3" json:"Secs,omitempty"`
	Flags        int32         `protobuf:"varint,8,opt,name=Flags,proto3" json:"Flags,omitempty"`
	ClientIP     string        `protobuf:"bytes,9,opt,name=ClientIP,proto3" json:"ClientIP,omitempty"`
	YourClientIP string        `protobuf:"bytes,10,opt,name=YourClientIP,proto3" json:"YourClientIP,omitempty"`
	NextServerIP string        `protobuf:"bytes,11,opt,name=NextServerIP,proto3" json:"NextServerIP,omitempty"`
	RelayAgentIP string        `protobuf:"bytes,12,opt,name=RelayAgentIP,proto3" json:"RelayAgentIP,omitempty"`
	ClientHWAddr string        `protobuf:"bytes,13,opt,name=ClientHWAddr,proto3" json:"ClientHWAddr,omitempty"`
	ServerName   []byte        `protobuf:"bytes,14,opt,name=ServerName,proto3" json:"ServerName,omitempty"`
	File         []byte        `protobuf:"bytes,15,opt,name=File,proto3" json:"File,omitempty"`
	Options      []*DHCPOption `protobuf:"bytes,16,rep,name=Options" json:"Options,omitempty"`
}

func (m *DHCPv4) Reset()         { *m = DHCPv4{} }
func (m *DHCPv4) String() string { return proto.CompactTextString(m) }
func (*DHCPv4) ProtoMessage()    {}
func (*DHCPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{48}
}
func (m *DHCPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHCPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv4.Merge(dst, src)
}
func (m *DHCPv4) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv4.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv4 proto.InternalMessageInfo

func (m *DHCPv4) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *DHCPv4) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

func (m *DHCPv4) GetHardwareType() int32 {
	if m != nil {
		return m.HardwareType
	}
	return 0
}

func (m *DHCPv4) GetHardwareLen() int32 {
	if m != nil {
		return m.HardwareLen
	}
	return 0
}

func (m *DHCPv4) GetHardwareOpts() int32 {
	if m != nil {
		return m.HardwareOpts
	}
	return 0
}

func (m *DHCPv4) GetXid() uint32 {
	if m != nil {
		return m.Xid
	}
	return 0
}

func (m *DHCPv4) GetSecs() int32 {
	if m != nil {
		return m.Secs
	}
	return 0
}

func (m *DHCPv4) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *DHCPv4) GetClientIP() string {
	if m != nil {
		return m.ClientIP
	}
	return ""
}

func (m *DHCPv4) GetYourClientIP() string {
	if m != nil {
		return m.YourClientIP
	}
	return ""
}

func (m *DHCPv4) GetNextServerIP() string {
	if m != nil {
		return m.NextServerIP
	}
	return ""
}

func (m *DHCPv4) GetRelayAgentIP() string {
	if m != nil {
		return m.RelayAgentIP
	}
	return ""
}

func (m *DHCPv4) GetClientHWAddr() string {
	if m != nil {
		return m.ClientHWAddr
	}
	return ""
}

func (m *DHCPv4) GetServerName() []byte {
	if m != nil {
		return m.ServerName
	}
	return nil
}

func (m *DHCPv4) GetFile() []byte {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DHCPv4) GetOptions() []*DHCPOption {
	if m != nil {
		return m.Options
	}
	return nil
}

type DHCPOption struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *DHCPOption) Reset()         { *m = DHCPOption{} }
func (m *DHCPOption) String() string { return proto.CompactTextString(m) }
func (*DHCPOption) ProtoMessage()    {}
func (*DHCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{49}
}
func (m *DHCPOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPOption.Merge(dst, src)
}
func (m *DHCPOption) XXX_Size() int {
	return m.Size()
}
func (m *DHCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPOption proto.InternalMessageInfo

func (m *DHCPOption) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DHCPOption) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DHCPOption) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DHCPv6 struct {
	Timestamp     string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	MsgType       int32           `protobuf:"varint,2,opt,name=MsgType,proto3" json:"MsgType,omitempty"`
	HopCount      int32           `protobuf:"varint,3,opt,name=HopCount,proto3" json:"HopCount,omitempty"`
	LinkAddr      string          `protobuf:"bytes,4,opt,name=LinkAddr,proto3" json:"LinkAddr,omitempty"`
	PeerAddr      string          `protobuf:"bytes,5,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty"`
	TransactionID []byte          `protobuf:"bytes,6,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	Options       []*DHCPv6Option `protobuf:"bytes,7,rep,name=Options" json:"Options,omitempty"`
}

func (m *DHCPv6) Reset()         { *m = DHCPv6{} }
func (m *DHCPv6) String() string { return proto.CompactTextString(m) }
func (*DHCPv6) ProtoMessage()    {}
func (*DHCPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{50}
}
func (m *DHCPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHCPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv6.Merge(dst, src)
}
func (m *DHCPv6) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv6.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv6 proto.InternalMessageInfo

func (m *DHCPv6) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *DHCPv6) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *DHCPv6) GetHopCount() int32 {
	if m != nil {
		return m.HopCount
	}
	return 0
}

func (m *DHCPv6) GetLinkAddr() string {
	if m != nil {
		return m.LinkAddr
	}
	return ""
}

func (m *DHCPv6) GetPeerAddr() string {
	if m != nil {
		return m.PeerAddr
	}
	return ""
}

func (m *DHCPv6) GetTransactionID() []byte {
	if m != nil {
		return m.TransactionID
	}
	return nil
}

func (m *DHCPv6) GetOptions() []*DHCPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type DHCPv6Option struct {
	Code   int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *DHCPv6Option) Reset()         { *m = DHCPv6Option{} }
func (m *DHCPv6Option) String() string { return proto.CompactTextString(m) }
func (*DHCPv6Option) ProtoMessage()    {}
func (*DHCPv6Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{51}
}
func (m *DHCPv6Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv6Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv6Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DHCPv6Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv6Option.Merge(dst, src)
}
func (m *DHCPv6Option) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv6Option) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv6Option.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv6Option proto.InternalMessageInfo

func (m *DHCPv6Option) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DHCPv6Option) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DHCPv6Option) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// LLC is the layer used for 802.2 Logical Link Control headers.
// See http://standards.ieee.org/getieee802/download/802.2-1998.pdf
type LLC struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	DSAP      int32  `protobuf:"varint,2,opt,name=DSAP,proto3" json:"DSAP,omitempty"`
	IG        bool   `protobuf:"varint,3,opt,name=IG,proto3" json:"IG,omitempty"`
	SSAP      int32  `protobuf:"varint,4,opt,name=SSAP,proto3" json:"SSAP,omitempty"`
	CR        bool   `protobuf:"varint,5,opt,name=CR,proto3" json:"CR,omitempty"`
	Control   int32  `protobuf:"varint,6,opt,name=Control,proto3" json:"Control,omitempty"`
}

func (m *LLC) Reset()         { *m = LLC{} }
func (m *LLC) String() string { return proto.CompactTextString(m) }
func (*LLC) ProtoMessage()    {}
func (*LLC) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{52}
}
func (m *LLC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LLC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLC.Merge(dst, src)
}
func (m *LLC) XXX_Size() int {
	return m.Size()
}
func (m *LLC) XXX_DiscardUnknown() {
	xxx_messageInfo_LLC.DiscardUnknown(m)
}

var xxx_messageInfo_LLC proto.InternalMessageInfo

func (m *LLC) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LLC) GetDSAP() int32 {
	if m != nil {
		return m.DSAP
	}
	return 0
}

func (m *LLC) GetIG() bool {
	if m != nil {
		return m.IG
	}
	return false
}

func (m *LLC) GetSSAP() int32 {
	if m != nil {
		return m.SSAP
	}
	return 0
}

func (m *LLC) GetCR() bool {
	if m != nil {
		return m.CR
	}
	return false
}

func (m *LLC) GetControl() int32 {
	if m != nil {
		return m.Control
	}
	return 0
}

type NTP struct {
	Timestamp          string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	LeapIndicator      int32  `protobuf:"varint,2,opt,name=LeapIndicator,proto3" json:"LeapIndicator,omitempty"`
	Version            int32  `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Mode               int32  `protobuf:"varint,4,opt,name=Mode,proto3" json:"Mode,omitempty"`
	Stratum            int32  `protobuf:"varint,5,opt,name=Stratum,proto3" json:"Stratum,omitempty"`
	Poll               int32  `protobuf:"varint,6,opt,name=Poll,proto3" json:"Poll,omitempty"`
	Precision          int32  `protobuf:"varint,7,opt,name=Precision,proto3" json:"Precision,omitempty"`
	RootDelay          uint32 `protobuf:"varint,8,opt,name=RootDelay,proto3" json:"RootDelay,omitempty"`
	RootDispersion     uint32 `protobuf:"varint,9,opt,name=RootDispersion,proto3" json:"RootDispersion,omitempty"`
	ReferenceID        uint32 `protobuf:"varint,10,opt,name=ReferenceID,proto3" json:"ReferenceID,omitempty"`
	ReferenceTimestamp uint64 `protobuf:"varint,11,opt,name=ReferenceTimestamp,proto3" json:"ReferenceTimestamp,omitempty"`
	OriginTimestamp    uint64 `protobuf:"varint,12,opt,name=OriginTimestamp,proto3" json:"OriginTimestamp,omitempty"`
	ReceiveTimestamp   uint64 `protobuf:"varint,13,opt,name=ReceiveTimestamp,proto3" json:"ReceiveTimestamp,omitempty"`
	TransmitTimestamp  uint64 `protobuf:"varint,14,opt,name=TransmitTimestamp,proto3" json:"TransmitTimestamp,omitempty"`
	ExtensionBytes     []byte `protobuf:"bytes,15,opt,name=ExtensionBytes,proto3" json:"ExtensionBytes,omitempty"`
}

func (m *NTP) Reset()         { *m = NTP{} }
func (m *NTP) String() string { return proto.CompactTextString(m) }
func (*NTP) ProtoMessage()    {}
func (*NTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{53}
}
func (m *NTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTP.Merge(dst, src)
}
func (m *NTP) XXX_Size() int {
	return m.Size()
}
func (m *NTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NTP.DiscardUnknown(m)
}

var xxx_messageInfo_NTP proto.InternalMessageInfo

func (m *NTP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *NTP) GetLeapIndicator() int32 {
	if m != nil {
		return m.LeapIndicator
	}
	return 0
}

func (m *NTP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *NTP) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *NTP) GetStratum() int32 {
	if m != nil {
		return m.Stratum
	}
	return 0
}

func (m *NTP) GetPoll() int32 {
	if m != nil {
		return m.Poll
	}
	return 0
}

func (m *NTP) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *NTP) GetRootDelay() uint32 {
	if m != nil {
		return m.RootDelay
	}
	return 0
}

func (m *NTP) GetRootDispersion() uint32 {
	if m != nil {
		return m.RootDispersion
	}
	return 0
}

func (m *NTP) GetReferenceID() uint32 {
	if m != nil {
		return m.ReferenceID
	}
	return 0
}

func (m *NTP) GetReferenceTimestamp() uint64 {
	if m != nil {
		return m.ReferenceTimestamp
	}
	return 0
}

func (m *NTP) GetOriginTimestamp() uint64 {
	if m != nil {
		return m.OriginTimestamp
	}
	return 0
}

func (m *NTP) GetReceiveTimestamp() uint64 {
	if m != nil {
		return m.ReceiveTimestamp
	}
	return 0
}

func (m *NTP) GetTransmitTimestamp() uint64 {
	if m != nil {
		return m.TransmitTimestamp
	}
	return 0
}

func (m *NTP) GetExtensionBytes() []byte {
	if m != nil {
		return m.ExtensionBytes
	}
	return nil
}

// The Session Initiation Protocol (SIP) is a signalling protocol used for initiating, maintaining, and terminating real-time sessions that include voice, video and messaging applications
type SIP struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	// Base information
	Version int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Method  int32 `protobuf:"varint,3,opt,name=Method,proto3" json:"Method,omitempty"`
	// map[string][]string Headers
	Headers []string `protobuf:"bytes,4,rep,name=Headers" json:"Headers,omitempty"`
	// Response
	IsResponse     bool   `protobuf:"varint,5,opt,name=IsResponse,proto3" json:"IsResponse,omitempty"`
	ResponseCode   int32  `protobuf:"varint,6,opt,name=ResponseCode,proto3" json:"ResponseCode,omitempty"`
	ResponseStatus string `protobuf:"bytes,7,opt,name=ResponseStatus,proto3" json:"ResponseStatus,omitempty"`
}

func (m *SIP) Reset()         { *m = SIP{} }
func (m *SIP) String() string { return proto.CompactTextString(m) }
func (*SIP) ProtoMessage()    {}
func (*SIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{54}
}
func (m *SIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SIP.Merge(dst, src)
}
func (m *SIP) XXX_Size() int {
	return m.Size()
}
func (m *SIP) XXX_DiscardUnknown() {
	xxx_messageInfo_SIP.DiscardUnknown(m)
}

var xxx_messageInfo_SIP proto.InternalMessageInfo

func (m *SIP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *SIP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SIP) GetMethod() int32 {
	if m != nil {
		return m.Method
	}
	return 0
}

func (m *SIP) GetHeaders() []string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *SIP) GetIsResponse() bool {
	if m != nil {
		return m.IsResponse
	}
	return false
}

func (m *SIP) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *SIP) GetResponseStatus() string {
	if m != nil {
		return m.ResponseStatus
	}
	return ""
}

type IGMP struct {
	Timestamp               string               `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type                    int32                `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	MaxResponseTime         uint64               `protobuf:"varint,3,opt,name=MaxResponseTime,proto3" json:"MaxResponseTime,omitempty"`
	Checksum                int32                `protobuf:"varint,4,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	GroupAddress            []byte               `protobuf:"bytes,5,opt,name=GroupAddress,proto3" json:"GroupAddress,omitempty"`
	SupressRouterProcessing bool                 `protobuf:"varint,6,opt,name=SupressRouterProcessing,proto3" json:"SupressRouterProcessing,omitempty"`
	RobustnessValue         int32                `protobuf:"varint,7,opt,name=RobustnessValue,proto3" json:"RobustnessValue,omitempty"`
	IntervalTime            uint64               `protobuf:"varint,8,opt,name=IntervalTime,proto3" json:"IntervalTime,omitempty"`
	SourceAddresses         []string             `protobuf:"bytes,9,rep,name=SourceAddresses" json:"SourceAddresses,omitempty"`
	NumberOfGroupRecords    int32                `protobuf:"varint,10,opt,name=NumberOfGroupRecords,proto3" json:"NumberOfGroupRecords,omitempty"`
	NumberOfSources         int32                `protobuf:"varint,11,opt,name=NumberOfSources,proto3" json:"NumberOfSources,omitempty"`
	GroupRecords            []*IGMPv3GroupRecord `protobuf:"bytes,12,rep,name=GroupRecords" json:"GroupRecords,omitempty"`
	Version                 int32                `protobuf:"varint,13,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *IGMP) Reset()         { *m = IGMP{} }
func (m *IGMP) String() string { return proto.CompactTextString(m) }
func (*IGMP) ProtoMessage()    {}
func (*IGMP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{55}
}
func (m *IGMP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IGMP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IGMP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IGMP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IGMP.Merge(dst, src)
}
func (m *IGMP) XXX_Size() int {
	return m.Size()
}
func (m *IGMP) XXX_DiscardUnknown() {
	xxx_messageInfo_IGMP.DiscardUnknown(m)
}

var xxx_messageInfo_IGMP proto.InternalMessageInfo

func (m *IGMP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IGMP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IGMP) GetMaxResponseTime() uint64 {
	if m != nil {
		return m.MaxResponseTime
	}
	return 0
}

func (m *IGMP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *IGMP) GetGroupAddress() []byte {
	if m != nil {
		return m.GroupAddress
	}
	return nil
}

func (m *IGMP) GetSupressRouterProcessing() bool {
	if m != nil {
		return m.SupressRouterProcessing
	}
	return false
}

func (m *IGMP) GetRobustnessValue() int32 {
	if m != nil {
		return m.RobustnessValue
	}
	return 0
}

func (m *IGMP) GetIntervalTime() uint64 {
	if m != nil {
		return m.IntervalTime
	}
	return 0
}

func (m *IGMP) GetSourceAddresses() []string {
	if m != nil {
		return m.SourceAddresses
	}
	return nil
}

func (m *IGMP) GetNumberOfGroupRecords() int32 {
	if m != nil {
		return m.NumberOfGroupRecords
	}
	return 0
}

func (m *IGMP) GetNumberOfSources() int32 {
	if m != nil {
		return m.NumberOfSources
	}
	return 0
}

func (m *IGMP) GetGroupRecords() []*IGMPv3GroupRecord {
	if m != nil {
		return m.GroupRecords
	}
	return nil
}

func (m *IGMP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type IGMPv3GroupRecord struct {
	Type             int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	AuxDataLen       int32    `protobuf:"varint,2,opt,name=AuxDataLen,proto3" json:"AuxDataLen,omitempty"`
	NumberOfSources  int32    `protobuf:"varint,3,opt,name=NumberOfSources,proto3" json:"NumberOfSources,omitempty"`
	MulticastAddress string   `protobuf:"bytes,4,opt,name=MulticastAddress,proto3" json:"MulticastAddress,omitempty"`
	SourceAddresses  []string `protobuf:"bytes,5,rep,name=SourceAddresses" json:"SourceAddresses,omitempty"`
}

func (m *IGMPv3GroupRecord) Reset()         { *m = IGMPv3GroupRecord{} }
func (m *IGMPv3GroupRecord) String() string { return proto.CompactTextString(m) }
func (*IGMPv3GroupRecord) ProtoMessage()    {}
func (*IGMPv3GroupRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{56}
}
func (m *IGMPv3GroupRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IGMPv3GroupRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IGMPv3GroupRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IGMPv3GroupRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IGMPv3GroupRecord.Merge(dst, src)
}
func (m *IGMPv3GroupRecord) XXX_Size() int {
	return m.Size()
}
func (m *IGMPv3GroupRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_IGMPv3GroupRecord.DiscardUnknown(m)
}

var xxx_messageInfo_IGMPv3GroupRecord proto.InternalMessageInfo

func (m *IGMPv3GroupRecord) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetAuxDataLen() int32 {
	if m != nil {
		return m.AuxDataLen
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetNumberOfSources() int32 {
	if m != nil {
		return m.NumberOfSources
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetMulticastAddress() string {
	if m != nil {
		return m.MulticastAddress
	}
	return ""
}

func (m *IGMPv3GroupRecord) GetSourceAddresses() []string {
	if m != nil {
		return m.SourceAddresses
	}
	return nil
}

type IPv6HopByHop struct {
	Timestamp string                `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Options   []*IPv6HopByHopOption `protobuf:"bytes,2,rep,name=Options" json:"Options,omitempty"`
}

func (m *IPv6HopByHop) Reset()         { *m = IPv6HopByHop{} }
func (m *IPv6HopByHop) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHop) ProtoMessage()    {}
func (*IPv6HopByHop) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{57}
}
func (m *IPv6HopByHop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv6HopByHop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHop.Merge(dst, src)
}
func (m *IPv6HopByHop) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHop) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHop.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHop proto.InternalMessageInfo

func (m *IPv6HopByHop) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPv6HopByHop) GetOptions() []*IPv6HopByHopOption {
	if m != nil {
		return m.Options
	}
	return nil
}

type IPv6HopByHopOption struct {
	OptionType      int32                        `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength    int32                        `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	ActualLength    int32                        `protobuf:"varint,3,opt,name=ActualLength,proto3" json:"ActualLength,omitempty"`
	OptionData      []byte                       `protobuf:"bytes,4,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
	OptionAlignment *IPv6HopByHopOptionAlignment `protobuf:"bytes,5,opt,name=OptionAlignment" json:"OptionAlignment,omitempty"`
}

func (m *IPv6HopByHopOption) Reset()         { *m = IPv6HopByHopOption{} }
func (m *IPv6HopByHopOption) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHopOption) ProtoMessage()    {}
func (*IPv6HopByHopOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{58}
}
func (m *IPv6HopByHopOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHopOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHopOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv6HopByHopOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHopOption.Merge(dst, src)
}
func (m *IPv6HopByHopOption) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHopOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHopOption.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHopOption proto.InternalMessageInfo

func (m *IPv6HopByHopOption) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *IPv6HopByHopOption) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *IPv6HopByHopOption) GetActualLength() int32 {
	if m != nil {
		return m.ActualLength
	}
	return 0
}

func (m *IPv6HopByHopOption) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

func (m *IPv6HopByHopOption) GetOptionAlignment() *IPv6HopByHopOptionAlignment {
	if m != nil {
		return m.OptionAlignment
	}
	return nil
}

type IPv6HopByHopOptionAlignment struct {
	One int32 `protobuf:"varint,1,opt,name=One,proto3" json:"One,omitempty"`
	Two int32 `protobuf:"varint,2,opt,name=Two,proto3" json:"Two,omitempty"`
}

func (m *IPv6HopByHopOptionAlignment) Reset()         { *m = IPv6HopByHopOptionAlignment{} }
func (m *IPv6HopByHopOptionAlignment) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHopOptionAlignment) ProtoMessage()    {}
func (*IPv6HopByHopOptionAlignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{59}
}
func (m *IPv6HopByHopOptionAlignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHopOptionAlignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHopOptionAlignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPv6HopByHopOptionAlignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHopOptionAlignment.Merge(dst, src)
}
func (m *IPv6HopByHopOptionAlignment) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHopOptionAlignment) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHopOptionAlignment.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHopOptionAlignment proto.InternalMessageInfo

func (m *IPv6HopByHopOptionAlignment) GetOne() int32 {
	if m != nil {
		return m.One
	}
	return 0
}

func (m *IPv6HopByHopOptionAlignment) GetTwo() int32 {
	if m != nil {
		return m.Two
	}
	return 0
}

// SNAP is used inside LLC. See http://standards.ieee.org/getieee802/download/802-2001.pdf. From http://en.wikipedia.org/wiki/Subnetwork_Access_Protocol:
// "[T]he Subnetwork Access Protocol (SNAP) is a mechanism for multiplexing,
// on networks using IEEE 802.2 LLC, more protocols than can be distinguished
// by the 8-bit 802.2 Service Access Point (SAP) fields."
type SNAP struct {
	Timestamp          string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	OrganizationalCode []byte `protobuf:"bytes,2,opt,name=OrganizationalCode,proto3" json:"OrganizationalCode,omitempty"`
	Type               int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *SNAP) Reset()         { *m = SNAP{} }
func (m *SNAP) String() string { return proto.CompactTextString(m) }
func (*SNAP) ProtoMessage()    {}
func (*SNAP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{60}
}
func (m *SNAP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SNAP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SNAP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SNAP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SNAP.Merge(dst, src)
}
func (m *SNAP) XXX_Size() int {
	return m.Size()
}
func (m *SNAP) XXX_DiscardUnknown() {
	xxx_messageInfo_SNAP.DiscardUnknown(m)
}

var xxx_messageInfo_SNAP proto.InternalMessageInfo

func (m *SNAP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *SNAP) GetOrganizationalCode() []byte {
	if m != nil {
		return m.OrganizationalCode
	}
	return nil
}

func (m *SNAP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type ICMPv6Echo struct {
	Timestamp  string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Identifier int32  `protobuf:"varint,2,opt,name=Identifier,proto3" json:"Identifier,omitempty"`
	SeqNumber  int32  `protobuf:"varint,3,opt,name=SeqNumber,proto3" json:"SeqNumber,omitempty"`
}

func (m *ICMPv6Echo) Reset()         { *m = ICMPv6Echo{} }
func (m *ICMPv6Echo) String() string { return proto.CompactTextString(m) }
func (*ICMPv6Echo) ProtoMessage()    {}
func (*ICMPv6Echo) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{61}
}
func (m *ICMPv6Echo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6Echo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6Echo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6Echo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6Echo.Merge(dst, src)
}
func (m *ICMPv6Echo) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6Echo) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6Echo.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6Echo proto.InternalMessageInfo

func (m *ICMPv6Echo) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6Echo) GetIdentifier() int32 {
	if m != nil {
		return m.Identifier
	}
	return 0
}

func (m *ICMPv6Echo) GetSeqNumber() int32 {
	if m != nil {
		return m.SeqNumber
	}
	return 0
}

type ICMPv6NeighborSolicitation struct {
	Timestamp     string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TargetAddress string          `protobuf:"bytes,2,opt,name=TargetAddress,proto3" json:"TargetAddress,omitempty"`
	Options       []*ICMPv6Option `protobuf:"bytes,3,rep,name=Options" json:"Options,omitempty"`
}

func (m *ICMPv6NeighborSolicitation) Reset()         { *m = ICMPv6NeighborSolicitation{} }
func (m *ICMPv6NeighborSolicitation) String() string { return proto.CompactTextString(m) }
func (*ICMPv6NeighborSolicitation) ProtoMessage()    {}
func (*ICMPv6NeighborSolicitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{62}
}
func (m *ICMPv6NeighborSolicitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6NeighborSolicitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6NeighborSolicitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6NeighborSolicitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6NeighborSolicitation.Merge(dst, src)
}
func (m *ICMPv6NeighborSolicitation) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6NeighborSolicitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6NeighborSolicitation.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6NeighborSolicitation proto.InternalMessageInfo

func (m *ICMPv6NeighborSolicitation) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6NeighborSolicitation) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *ICMPv6NeighborSolicitation) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type ICMPv6RouterSolicitation struct {
	Timestamp string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Options   []*ICMPv6Option `protobuf:"bytes,2,rep,name=Options" json:"Options,omitempty"`
}

func (m *ICMPv6RouterSolicitation) Reset()         { *m = ICMPv6RouterSolicitation{} }
func (m *ICMPv6RouterSolicitation) String() string { return proto.CompactTextString(m) }
func (*ICMPv6RouterSolicitation) ProtoMessage()    {}
func (*ICMPv6RouterSolicitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{63}
}
func (m *ICMPv6RouterSolicitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6RouterSolicitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6RouterSolicitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ICMPv6RouterSolicitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6RouterSolicitation.Merge(dst, src)
}
func (m *ICMPv6RouterSolicitation) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6RouterSolicitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6RouterSolicitation.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6RouterSolicitation proto.InternalMessageInfo

func (m *ICMPv6RouterSolicitation) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ICMPv6RouterSolicitation) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type HTTP struct {
	Timestamp        string   `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Proto            string   `protobuf:"bytes,2,opt,name=Proto,proto3" json:"Proto,omitempty"`
	Method           string   `protobuf:"bytes,3,opt,name=Method,proto3" json:"Method,omitempty"`
	Host             string   `protobuf:"bytes,4,opt,name=Host,proto3" json:"Host,omitempty"`
	UserAgent        string   `protobuf:"bytes,5,opt,name=UserAgent,proto3" json:"UserAgent,omitempty"`
	Referer          string   `protobuf:"bytes,6,opt,name=Referer,proto3" json:"Referer,omitempty"`
	ReqCookies       []string `protobuf:"bytes,7,rep,name=ReqCookies" json:"ReqCookies,omitempty"`
	ReqContentLength int32    `protobuf:"varint,8,opt,name=ReqContentLength,proto3" json:"ReqContentLength,omitempty"`
	URL              string   `protobuf:"bytes,9,opt,name=URL,proto3" json:"URL,omitempty"`
	ResContentLength int32    `protobuf:"varint,10,opt,name=ResContentLength,proto3" json:"ResContentLength,omitempty"`
	ContentType      string   `protobuf:"bytes,11,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	StatusCode       int32    `protobuf:"varint,12,opt,name=StatusCode,proto3" json:"StatusCode,omitempty"`
	SrcIP            string   `protobuf:"bytes,13,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP            string   `protobuf:"bytes,14,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *HTTP) Reset()         { *m = HTTP{} }
func (m *HTTP) String() string { return proto.CompactTextString(m) }
func (*HTTP) ProtoMessage()    {}
func (*HTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{64}
}
func (m *HTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTP.Merge(dst, src)
}
func (m *HTTP) XXX_Size() int {
	return m.Size()
}
func (m *HTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTP.DiscardUnknown(m)
}

var xxx_messageInfo_HTTP proto.InternalMessageInfo

func (m *HTTP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *HTTP) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *HTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HTTP) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HTTP) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *HTTP) GetReferer() string {
	if m != nil {
		return m.Referer
	}
	return ""
}

func (m *HTTP) GetReqCookies() []string {
	if m != nil {
		return m.ReqCookies
	}
	return nil
}

func (m *HTTP) GetReqContentLength() int32 {
	if m != nil {
		return m.ReqContentLength
	}
	return 0
}

func (m *HTTP) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *HTTP) GetResContentLength() int32 {
	if m != nil {
		return m.ResContentLength
	}
	return 0
}

func (m *HTTP) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *HTTP) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *HTTP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *HTTP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type TLSClientHello struct {
	Timestamp        string   `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type             int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Version          int32    `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	MessageLen       int32    `protobuf:"varint,4,opt,name=MessageLen,proto3" json:"MessageLen,omitempty"`
	HandshakeType    int32    `protobuf:"varint,5,opt,name=HandshakeType,proto3" json:"HandshakeType,omitempty"`
	HandshakeLen     uint32   `protobuf:"varint,6,opt,name=HandshakeLen,proto3" json:"HandshakeLen,omitempty"`
	HandshakeVersion int32    `protobuf:"varint,7,opt,name=HandshakeVersion,proto3" json:"HandshakeVersion,omitempty"`
	Random           []byte   `protobuf:"bytes,8,opt,name=Random,proto3" json:"Random,omitempty"`
	SessionIDLen     uint32   `protobuf:"varint,9,opt,name=SessionIDLen,proto3" json:"SessionIDLen,omitempty"`
	SessionID        []byte   `protobuf:"bytes,10,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	CipherSuiteLen   int32    `protobuf:"varint,11,opt,name=CipherSuiteLen,proto3" json:"CipherSuiteLen,omitempty"`
	ExtensionLen     int32    `protobuf:"varint,12,opt,name=ExtensionLen,proto3" json:"ExtensionLen,omitempty"`
	SNI              string   `protobuf:"bytes,13,opt,name=SNI,proto3" json:"SNI,omitempty"`
	OSCP             bool     `protobuf:"varint,14,opt,name=OSCP,proto3" json:"OSCP,omitempty"`
	CipherSuites     []int32  `protobuf:"varint,15,rep,packed,name=CipherSuites" json:"CipherSuites,omitempty"`
	CompressMethods  []int32  `protobuf:"varint,16,rep,packed,name=CompressMethods" json:"CompressMethods,omitempty"`
	SignatureAlgs    []int32  `protobuf:"varint,17,rep,packed,name=SignatureAlgs" json:"SignatureAlgs,omitempty"`
	SupportedGroups  []int32  `protobuf:"varint,18,rep,packed,name=SupportedGroups" json:"SupportedGroups,omitempty"`
	SupportedPoints  []int32  `protobuf:"varint,19,rep,packed,name=SupportedPoints" json:"SupportedPoints,omitempty"`
	ALPNs            []string `protobuf:"bytes,20,rep,name=ALPNs" json:"ALPNs,omitempty"`
	// map[Extension]uint16 // [Type]Length Extensions
	Ja3        string  `protobuf:"bytes,21,opt,name=Ja3,proto3" json:"Ja3,omitempty"`
	SrcIP      string  `protobuf:"bytes,22,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP      string  `protobuf:"bytes,23,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcMAC     string  `protobuf:"bytes,24,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC     string  `protobuf:"bytes,25,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcPort    int32   `protobuf:"varint,26,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort    int32   `protobuf:"varint,27,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	Extensions []int32 `protobuf:"varint,28,rep,packed,name=Extensions" json:"Extensions,omitempty"`
}

func (m *TLSClientHello) Reset()         { *m = TLSClientHello{} }
func (m *TLSClientHello) String() string { return proto.CompactTextString(m) }
func (*TLSClientHello) ProtoMessage()    {}
func (*TLSClientHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{65}
}
func (m *TLSClientHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSClientHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSClientHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSClientHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSClientHello.Merge(dst, src)
}
func (m *TLSClientHello) XXX_Size() int {
	return m.Size()
}
func (m *TLSClientHello) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSClientHello.DiscardUnknown(m)
}

var xxx_messageInfo_TLSClientHello proto.InternalMessageInfo

func (m *TLSClientHello) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *TLSClientHello) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TLSClientHello) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TLSClientHello) GetMessageLen() int32 {
	if m != nil {
		return m.MessageLen
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeType() int32 {
	if m != nil {
		return m.HandshakeType
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeLen() uint32 {
	if m != nil {
		return m.HandshakeLen
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeVersion() int32 {
	if m != nil {
		return m.HandshakeVersion
	}
	return 0
}

func (m *TLSClientHello) GetRandom() []byte {
	if m != nil {
		return m.Random
	}
	return nil
}

func (m *TLSClientHello) GetSessionIDLen() uint32 {
	if m != nil {
		return m.SessionIDLen
	}
	return 0
}

func (m *TLSClientHello) GetSessionID() []byte {
	if m != nil {
		return m.SessionID
	}
	return nil
}

func (m *TLSClientHello) GetCipherSuiteLen() int32 {
	if m != nil {
		return m.CipherSuiteLen
	}
	return 0
}

func (m *TLSClientHello) GetExtensionLen() int32 {
	if m != nil {
		return m.ExtensionLen
	}
	return 0
}

func (m *TLSClientHello) GetSNI() string {
	if m != nil {
		return m.SNI
	}
	return ""
}

func (m *TLSClientHello) GetOSCP() bool {
	if m != nil {
		return m.OSCP
	}
	return false
}

func (m *TLSClientHello) GetCipherSuites() []int32 {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *TLSClientHello) GetCompressMethods() []int32 {
	if m != nil {
		return m.CompressMethods
	}
	return nil
}

func (m *TLSClientHello) GetSignatureAlgs() []int32 {
	if m != nil {
		return m.SignatureAlgs
	}
	return nil
}

func (m *TLSClientHello) GetSupportedGroups() []int32 {
	if m != nil {
		return m.SupportedGroups
	}
	return nil
}

func (m *TLSClientHello) GetSupportedPoints() []int32 {
	if m != nil {
		return m.SupportedPoints
	}
	return nil
}

func (m *TLSClientHello) GetALPNs() []string {
	if m != nil {
		return m.ALPNs
	}
	return nil
}

func (m *TLSClientHello) GetJa3() string {
	if m != nil {
		return m.Ja3
	}
	return ""
}

func (m *TLSClientHello) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *TLSClientHello) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *TLSClientHello) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *TLSClientHello) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *TLSClientHello) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TLSClientHello) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TLSClientHello) GetExtensions() []int32 {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type IPSecAH struct {
	Timestamp          string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Reserved           int32  `protobuf:"varint,2,opt,name=Reserved,proto3" json:"Reserved,omitempty"`
	SPI                int32  `protobuf:"varint,3,opt,name=SPI,proto3" json:"SPI,omitempty"`
	Seq                int32  `protobuf:"varint,4,opt,name=Seq,proto3" json:"Seq,omitempty"`
	AuthenticationData []byte `protobuf:"bytes,5,opt,name=AuthenticationData,proto3" json:"AuthenticationData,omitempty"`
}

func (m *IPSecAH) Reset()         { *m = IPSecAH{} }
func (m *IPSecAH) String() string { return proto.CompactTextString(m) }
func (*IPSecAH) ProtoMessage()    {}
func (*IPSecAH) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{66}
}
func (m *IPSecAH) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPSecAH) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPSecAH.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPSecAH) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPSecAH.Merge(dst, src)
}
func (m *IPSecAH) XXX_Size() int {
	return m.Size()
}
func (m *IPSecAH) XXX_DiscardUnknown() {
	xxx_messageInfo_IPSecAH.DiscardUnknown(m)
}

var xxx_messageInfo_IPSecAH proto.InternalMessageInfo

func (m *IPSecAH) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPSecAH) GetReserved() int32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *IPSecAH) GetSPI() int32 {
	if m != nil {
		return m.SPI
	}
	return 0
}

func (m *IPSecAH) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *IPSecAH) GetAuthenticationData() []byte {
	if m != nil {
		return m.AuthenticationData
	}
	return nil
}

type IPSecESP struct {
	Timestamp    string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SPI          int32  `protobuf:"varint,2,opt,name=SPI,proto3" json:"SPI,omitempty"`
	Seq          int32  `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	LenEncrypted int32  `protobuf:"varint,4,opt,name=LenEncrypted,proto3" json:"LenEncrypted,omitempty"`
}

func (m *IPSecESP) Reset()         { *m = IPSecESP{} }
func (m *IPSecESP) String() string { return proto.CompactTextString(m) }
func (*IPSecESP) ProtoMessage()    {}
func (*IPSecESP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{67}
}
func (m *IPSecESP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPSecESP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPSecESP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPSecESP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPSecESP.Merge(dst, src)
}
func (m *IPSecESP) XXX_Size() int {
	return m.Size()
}
func (m *IPSecESP) XXX_DiscardUnknown() {
	xxx_messageInfo_IPSecESP.DiscardUnknown(m)
}

var xxx_messageInfo_IPSecESP proto.InternalMessageInfo

func (m *IPSecESP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *IPSecESP) GetSPI() int32 {
	if m != nil {
		return m.SPI
	}
	return 0
}

func (m *IPSecESP) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *IPSecESP) GetLenEncrypted() int32 {
	if m != nil {
		return m.LenEncrypted
	}
	return 0
}

type Geneve struct {
	Timestamp      string          `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32           `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OptionsLength  int32           `protobuf:"varint,3,opt,name=OptionsLength,proto3" json:"OptionsLength,omitempty"`
	OAMPacket      bool            `protobuf:"varint,4,opt,name=OAMPacket,proto3" json:"OAMPacket,omitempty"`
	CriticalOption bool            `protobuf:"varint,5,opt,name=CriticalOption,proto3" json:"CriticalOption,omitempty"`
	Protocol       int32           `protobuf:"varint,6,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	VNI            uint32          `protobuf:"varint,7,opt,name=VNI,proto3" json:"VNI,omitempty"`
	Options        []*GeneveOption `protobuf:"bytes,8,rep,name=Options" json:"Options,omitempty"`
}

func (m *Geneve) Reset()         { *m = Geneve{} }
func (m *Geneve) String() string { return proto.CompactTextString(m) }
func (*Geneve) ProtoMessage()    {}
func (*Geneve) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{68}
}
func (m *Geneve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Geneve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Geneve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Geneve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Geneve.Merge(dst, src)
}
func (m *Geneve) XXX_Size() int {
	return m.Size()
}
func (m *Geneve) XXX_DiscardUnknown() {
	xxx_messageInfo_Geneve.DiscardUnknown(m)
}

var xxx_messageInfo_Geneve proto.InternalMessageInfo

func (m *Geneve) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Geneve) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Geneve) GetOptionsLength() int32 {
	if m != nil {
		return m.OptionsLength
	}
	return 0
}

func (m *Geneve) GetOAMPacket() bool {
	if m != nil {
		return m.OAMPacket
	}
	return false
}

func (m *Geneve) GetCriticalOption() bool {
	if m != nil {
		return m.CriticalOption
	}
	return false
}

func (m *Geneve) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *Geneve) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *Geneve) GetOptions() []*GeneveOption {
	if m != nil {
		return m.Options
	}
	return nil
}

type GeneveOption struct {
	Class  int32  `protobuf:"varint,1,opt,name=Class,proto3" json:"Class,omitempty"`
	Type   int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Flags  int32  `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Length int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   []byte `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *GeneveOption) Reset()         { *m = GeneveOption{} }
func (m *GeneveOption) String() string { return proto.CompactTextString(m) }
func (*GeneveOption) ProtoMessage()    {}
func (*GeneveOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{69}
}
func (m *GeneveOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneveOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneveOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GeneveOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneveOption.Merge(dst, src)
}
func (m *GeneveOption) XXX_Size() int {
	return m.Size()
}
func (m *GeneveOption) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneveOption.DiscardUnknown(m)
}

var xxx_messageInfo_GeneveOption proto.InternalMessageInfo

func (m *GeneveOption) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

func (m *GeneveOption) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *GeneveOption) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *GeneveOption) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *GeneveOption) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// VXLAN is a VXLAN packet header
type VXLAN struct {
	Timestamp        string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ValidIDFlag      bool   `protobuf:"varint,2,opt,name=ValidIDFlag,proto3" json:"ValidIDFlag,omitempty"`
	VNI              uint32 `protobuf:"varint,3,opt,name=VNI,proto3" json:"VNI,omitempty"`
	GBPExtension     bool   `protobuf:"varint,4,opt,name=GBPExtension,proto3" json:"GBPExtension,omitempty"`
	GBPDontLearn     bool   `protobuf:"varint,5,opt,name=GBPDontLearn,proto3" json:"GBPDontLearn,omitempty"`
	GBPApplied       bool   `protobuf:"varint,6,opt,name=GBPApplied,proto3" json:"GBPApplied,omitempty"`
	GBPGroupPolicyID int32  `protobuf:"varint,7,opt,name=GBPGroupPolicyID,proto3" json:"GBPGroupPolicyID,omitempty"`
}

func (m *VXLAN) Reset()         { *m = VXLAN{} }
func (m *VXLAN) String() string { return proto.CompactTextString(m) }
func (*VXLAN) ProtoMessage()    {}
func (*VXLAN) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{70}
}
func (m *VXLAN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VXLAN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VXLAN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VXLAN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VXLAN.Merge(dst, src)
}
func (m *VXLAN) XXX_Size() int {
	return m.Size()
}
func (m *VXLAN) XXX_DiscardUnknown() {
	xxx_messageInfo_VXLAN.DiscardUnknown(m)
}

var xxx_messageInfo_VXLAN proto.InternalMessageInfo

func (m *VXLAN) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *VXLAN) GetValidIDFlag() bool {
	if m != nil {
		return m.ValidIDFlag
	}
	return false
}

func (m *VXLAN) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *VXLAN) GetGBPExtension() bool {
	if m != nil {
		return m.GBPExtension
	}
	return false
}

func (m *VXLAN) GetGBPDontLearn() bool {
	if m != nil {
		return m.GBPDontLearn
	}
	return false
}

func (m *VXLAN) GetGBPApplied() bool {
	if m != nil {
		return m.GBPApplied
	}
	return false
}

func (m *VXLAN) GetGBPGroupPolicyID() int32 {
	if m != nil {
		return m.GBPGroupPolicyID
	}
	return 0
}

type USB struct {
	Timestamp              string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ID                     uint64 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	EventType              int32  `protobuf:"varint,3,opt,name=EventType,proto3" json:"EventType,omitempty"`
	TransferType           int32  `protobuf:"varint,4,opt,name=TransferType,proto3" json:"TransferType,omitempty"`
	Direction              int32  `protobuf:"varint,5,opt,name=Direction,proto3" json:"Direction,omitempty"`
	EndpointNumber         int32  `protobuf:"varint,6,opt,name=EndpointNumber,proto3" json:"EndpointNumber,omitempty"`
	DeviceAddress          int32  `protobuf:"varint,7,opt,name=DeviceAddress,proto3" json:"DeviceAddress,omitempty"`
	BusID                  int32  `protobuf:"varint,8,opt,name=BusID,proto3" json:"BusID,omitempty"`
	TimestampSec           int64  `protobuf:"varint,9,opt,name=TimestampSec,proto3" json:"TimestampSec,omitempty"`
	TimestampUsec          int32  `protobuf:"varint,10,opt,name=TimestampUsec,proto3" json:"TimestampUsec,omitempty"`
	Setup                  bool   `protobuf:"varint,11,opt,name=Setup,proto3" json:"Setup,omitempty"`
	Data                   bool   `protobuf:"varint,12,opt,name=Data,proto3" json:"Data,omitempty"`
	Status                 int32  `protobuf:"varint,13,opt,name=Status,proto3" json:"Status,omitempty"`
	UrbLength              uint32 `protobuf:"varint,14,opt,name=UrbLength,proto3" json:"UrbLength,omitempty"`
	UrbDataLength          uint32 `protobuf:"varint,15,opt,name=UrbDataLength,proto3" json:"UrbDataLength,omitempty"`
	UrbInterval            uint32 `protobuf:"varint,16,opt,name=UrbInterval,proto3" json:"UrbInterval,omitempty"`
	UrbStartFrame          uint32 `protobuf:"varint,17,opt,name=UrbStartFrame,proto3" json:"UrbStartFrame,omitempty"`
	UrbCopyOfTransferFlags uint32 `protobuf:"varint,18,opt,name=UrbCopyOfTransferFlags,proto3" json:"UrbCopyOfTransferFlags,omitempty"`
	IsoNumDesc             uint32 `protobuf:"varint,19,opt,name=IsoNumDesc,proto3" json:"IsoNumDesc,omitempty"`
	Payload                []byte `protobuf:"bytes,20,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *USB) Reset()         { *m = USB{} }
func (m *USB) String() string { return proto.CompactTextString(m) }
func (*USB) ProtoMessage()    {}
func (*USB) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{71}
}
func (m *USB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_USB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *USB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USB.Merge(dst, src)
}
func (m *USB) XXX_Size() int {
	return m.Size()
}
func (m *USB) XXX_DiscardUnknown() {
	xxx_messageInfo_USB.DiscardUnknown(m)
}

var xxx_messageInfo_USB proto.InternalMessageInfo

func (m *USB) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *USB) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *USB) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *USB) GetTransferType() int32 {
	if m != nil {
		return m.TransferType
	}
	return 0
}

func (m *USB) GetDirection() int32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *USB) GetEndpointNumber() int32 {
	if m != nil {
		return m.EndpointNumber
	}
	return 0
}

func (m *USB) GetDeviceAddress() int32 {
	if m != nil {
		return m.DeviceAddress
	}
	return 0
}

func (m *USB) GetBusID() int32 {
	if m != nil {
		return m.BusID
	}
	return 0
}

func (m *USB) GetTimestampSec() int64 {
	if m != nil {
		return m.TimestampSec
	}
	return 0
}

func (m *USB) GetTimestampUsec() int32 {
	if m != nil {
		return m.TimestampUsec
	}
	return 0
}

func (m *USB) GetSetup() bool {
	if m != nil {
		return m.Setup
	}
	return false
}

func (m *USB) GetData() bool {
	if m != nil {
		return m.Data
	}
	return false
}

func (m *USB) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *USB) GetUrbLength() uint32 {
	if m != nil {
		return m.UrbLength
	}
	return 0
}

func (m *USB) GetUrbDataLength() uint32 {
	if m != nil {
		return m.UrbDataLength
	}
	return 0
}

func (m *USB) GetUrbInterval() uint32 {
	if m != nil {
		return m.UrbInterval
	}
	return 0
}

func (m *USB) GetUrbStartFrame() uint32 {
	if m != nil {
		return m.UrbStartFrame
	}
	return 0
}

func (m *USB) GetUrbCopyOfTransferFlags() uint32 {
	if m != nil {
		return m.UrbCopyOfTransferFlags
	}
	return 0
}

func (m *USB) GetIsoNumDesc() uint32 {
	if m != nil {
		return m.IsoNumDesc
	}
	return 0
}

func (m *USB) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type USBRequestBlockSetup struct {
	Timestamp   string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	RequestType int32  `protobuf:"varint,2,opt,name=RequestType,proto3" json:"RequestType,omitempty"`
	Request     int32  `protobuf:"varint,3,opt,name=Request,proto3" json:"Request,omitempty"`
	Value       int32  `protobuf:"varint,4,opt,name=Value,proto3" json:"Value,omitempty"`
	Index       int32  `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	Length      int32  `protobuf:"varint,6,opt,name=Length,proto3" json:"Length,omitempty"`
}

func (m *USBRequestBlockSetup) Reset()         { *m = USBRequestBlockSetup{} }
func (m *USBRequestBlockSetup) String() string { return proto.CompactTextString(m) }
func (*USBRequestBlockSetup) ProtoMessage()    {}
func (*USBRequestBlockSetup) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{72}
}
func (m *USBRequestBlockSetup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USBRequestBlockSetup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_USBRequestBlockSetup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *USBRequestBlockSetup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USBRequestBlockSetup.Merge(dst, src)
}
func (m *USBRequestBlockSetup) XXX_Size() int {
	return m.Size()
}
func (m *USBRequestBlockSetup) XXX_DiscardUnknown() {
	xxx_messageInfo_USBRequestBlockSetup.DiscardUnknown(m)
}

var xxx_messageInfo_USBRequestBlockSetup proto.InternalMessageInfo

func (m *USBRequestBlockSetup) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *USBRequestBlockSetup) GetRequestType() int32 {
	if m != nil {
		return m.RequestType
	}
	return 0
}

func (m *USBRequestBlockSetup) GetRequest() int32 {
	if m != nil {
		return m.Request
	}
	return 0
}

func (m *USBRequestBlockSetup) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *USBRequestBlockSetup) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *USBRequestBlockSetup) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

// LCM (Lightweight Communications and Marshalling) is a set of libraries and tools for message passing and data marshalling,
// targeted at real-time systems where high-bandwidth and low latency are critical.
// It provides a publish/subscribe message passing model and automatic marshalling/unmarshalling
// code generation with bindings for applications in a variety of programming languages.
// References
// https://lcm-proj.github.io/
// https://github.com/lcm-proj/lcm
type LCM struct {
	Timestamp      string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Magic          int32  `protobuf:"varint,2,opt,name=Magic,proto3" json:"Magic,omitempty"`
	SequenceNumber int32  `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	PayloadSize    int32  `protobuf:"varint,4,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	FragmentOffset int32  `protobuf:"varint,5,opt,name=FragmentOffset,proto3" json:"FragmentOffset,omitempty"`
	FragmentNumber int32  `protobuf:"varint,6,opt,name=FragmentNumber,proto3" json:"FragmentNumber,omitempty"`
	TotalFragments int32  `protobuf:"varint,7,opt,name=TotalFragments,proto3" json:"TotalFragments,omitempty"`
	ChannelName    string `protobuf:"bytes,8,opt,name=ChannelName,proto3" json:"ChannelName,omitempty"`
	Fragmented     bool   `protobuf:"varint,9,opt,name=Fragmented,proto3" json:"Fragmented,omitempty"`
}

func (m *LCM) Reset()         { *m = LCM{} }
func (m *LCM) String() string { return proto.CompactTextString(m) }
func (*LCM) ProtoMessage()    {}
func (*LCM) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{73}
}
func (m *LCM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LCM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LCM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LCM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LCM.Merge(dst, src)
}
func (m *LCM) XXX_Size() int {
	return m.Size()
}
func (m *LCM) XXX_DiscardUnknown() {
	xxx_messageInfo_LCM.DiscardUnknown(m)
}

var xxx_messageInfo_LCM proto.InternalMessageInfo

func (m *LCM) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LCM) GetMagic() int32 {
	if m != nil {
		return m.Magic
	}
	return 0
}

func (m *LCM) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *LCM) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *LCM) GetFragmentOffset() int32 {
	if m != nil {
		return m.FragmentOffset
	}
	return 0
}

func (m *LCM) GetFragmentNumber() int32 {
	if m != nil {
		return m.FragmentNumber
	}
	return 0
}

func (m *LCM) GetTotalFragments() int32 {
	if m != nil {
		return m.TotalFragments
	}
	return 0
}

func (m *LCM) GetChannelName() string {
	if m != nil {
		return m.ChannelName
	}
	return ""
}

func (m *LCM) GetFragmented() bool {
	if m != nil {
		return m.Fragmented
	}
	return false
}

type MPLS struct {
	Timestamp    string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Label        int32  `protobuf:"varint,2,opt,name=Label,proto3" json:"Label,omitempty"`
	TrafficClass int32  `protobuf:"varint,3,opt,name=TrafficClass,proto3" json:"TrafficClass,omitempty"`
	StackBottom  bool   `protobuf:"varint,4,opt,name=StackBottom,proto3" json:"StackBottom,omitempty"`
	TTL          int32  `protobuf:"varint,5,opt,name=TTL,proto3" json:"TTL,omitempty"`
}

func (m *MPLS) Reset()         { *m = MPLS{} }
func (m *MPLS) String() string { return proto.CompactTextString(m) }
func (*MPLS) ProtoMessage()    {}
func (*MPLS) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{74}
}
func (m *MPLS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MPLS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MPLS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MPLS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPLS.Merge(dst, src)
}
func (m *MPLS) XXX_Size() int {
	return m.Size()
}
func (m *MPLS) XXX_DiscardUnknown() {
	xxx_messageInfo_MPLS.DiscardUnknown(m)
}

var xxx_messageInfo_MPLS proto.InternalMessageInfo

func (m *MPLS) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *MPLS) GetLabel() int32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *MPLS) GetTrafficClass() int32 {
	if m != nil {
		return m.TrafficClass
	}
	return 0
}

func (m *MPLS) GetStackBottom() bool {
	if m != nil {
		return m.StackBottom
	}
	return false
}

func (m *MPLS) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

type ModbusTCP struct {
	Timestamp             string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TransactionIdentifier int32  `protobuf:"varint,2,opt,name=TransactionIdentifier,proto3" json:"TransactionIdentifier,omitempty"`
	ProtocolIdentifier    int32  `protobuf:"varint,3,opt,name=ProtocolIdentifier,proto3" json:"ProtocolIdentifier,omitempty"`
	Length                int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	UnitIdentifier        int32  `protobuf:"varint,5,opt,name=UnitIdentifier,proto3" json:"UnitIdentifier,omitempty"`
	Payload               []byte `protobuf:"bytes,6,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *ModbusTCP) Reset()         { *m = ModbusTCP{} }
func (m *ModbusTCP) String() string { return proto.CompactTextString(m) }
func (*ModbusTCP) ProtoMessage()    {}
func (*ModbusTCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{75}
}
func (m *ModbusTCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModbusTCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModbusTCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModbusTCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModbusTCP.Merge(dst, src)
}
func (m *ModbusTCP) XXX_Size() int {
	return m.Size()
}
func (m *ModbusTCP) XXX_DiscardUnknown() {
	xxx_messageInfo_ModbusTCP.DiscardUnknown(m)
}

var xxx_messageInfo_ModbusTCP proto.InternalMessageInfo

func (m *ModbusTCP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ModbusTCP) GetTransactionIdentifier() int32 {
	if m != nil {
		return m.TransactionIdentifier
	}
	return 0
}

func (m *ModbusTCP) GetProtocolIdentifier() int32 {
	if m != nil {
		return m.ProtocolIdentifier
	}
	return 0
}

func (m *ModbusTCP) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ModbusTCP) GetUnitIdentifier() int32 {
	if m != nil {
		return m.UnitIdentifier
	}
	return 0
}

func (m *ModbusTCP) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type OSPFv2 struct {
	Timestamp      string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type           int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	PacketLength   int32  `protobuf:"varint,4,opt,name=PacketLength,proto3" json:"PacketLength,omitempty"`
	RouterID       uint32 `protobuf:"varint,5,opt,name=RouterID,proto3" json:"RouterID,omitempty"`
	AreaID         uint32 `protobuf:"varint,6,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	Checksum       int32  `protobuf:"varint,7,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	AuType         int32  `protobuf:"varint,8,opt,name=AuType,proto3" json:"AuType,omitempty"`
	Authentication int64  `protobuf:"varint,9,opt,name=Authentication,proto3" json:"Authentication,omitempty"`
	// interface Content
	LSAs    []*LSAheader `protobuf:"bytes,10,rep,name=LSAs" json:"LSAs,omitempty"`
	LSU     *LSUpdate    `protobuf:"bytes,11,opt,name=LSU" json:"LSU,omitempty"`
	LSR     []*LSReq     `protobuf:"bytes,12,rep,name=LSR" json:"LSR,omitempty"`
	DbDesc  *DbDescPkg   `protobuf:"bytes,13,opt,name=DbDesc" json:"DbDesc,omitempty"`
	HelloV2 *HelloPkgV2  `protobuf:"bytes,14,opt,name=HelloV2" json:"HelloV2,omitempty"`
}

func (m *OSPFv2) Reset()         { *m = OSPFv2{} }
func (m *OSPFv2) String() string { return proto.CompactTextString(m) }
func (*OSPFv2) ProtoMessage()    {}
func (*OSPFv2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{76}
}
func (m *OSPFv2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSPFv2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSPFv2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OSPFv2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSPFv2.Merge(dst, src)
}
func (m *OSPFv2) XXX_Size() int {
	return m.Size()
}
func (m *OSPFv2) XXX_DiscardUnknown() {
	xxx_messageInfo_OSPFv2.DiscardUnknown(m)
}

var xxx_messageInfo_OSPFv2 proto.InternalMessageInfo

func (m *OSPFv2) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *OSPFv2) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OSPFv2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *OSPFv2) GetPacketLength() int32 {
	if m != nil {
		return m.PacketLength
	}
	return 0
}

func (m *OSPFv2) GetRouterID() uint32 {
	if m != nil {
		return m.RouterID
	}
	return 0
}

func (m *OSPFv2) GetAreaID() uint32 {
	if m != nil {
		return m.AreaID
	}
	return 0
}

func (m *OSPFv2) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *OSPFv2) GetAuType() int32 {
	if m != nil {
		return m.AuType
	}
	return 0
}

func (m *OSPFv2) GetAuthentication() int64 {
	if m != nil {
		return m.Authentication
	}
	return 0
}

func (m *OSPFv2) GetLSAs() []*LSAheader {
	if m != nil {
		return m.LSAs
	}
	return nil
}

func (m *OSPFv2) GetLSU() *LSUpdate {
	if m != nil {
		return m.LSU
	}
	return nil
}

func (m *OSPFv2) GetLSR() []*LSReq {
	if m != nil {
		return m.LSR
	}
	return nil
}

func (m *OSPFv2) GetDbDesc() *DbDescPkg {
	if m != nil {
		return m.DbDesc
	}
	return nil
}

func (m *OSPFv2) GetHelloV2() *HelloPkgV2 {
	if m != nil {
		return m.HelloV2
	}
	return nil
}

type HelloPkg struct {
	InterfaceID              uint32   `protobuf:"varint,1,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	RtrPriority              int32    `protobuf:"varint,2,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options                  uint32   `protobuf:"varint,3,opt,name=Options,proto3" json:"Options,omitempty"`
	HelloInterval            int32    `protobuf:"varint,4,opt,name=HelloInterval,proto3" json:"HelloInterval,omitempty"`
	RouterDeadInterval       uint32   `protobuf:"varint,5,opt,name=RouterDeadInterval,proto3" json:"RouterDeadInterval,omitempty"`
	DesignatedRouterID       uint32   `protobuf:"varint,6,opt,name=DesignatedRouterID,proto3" json:"DesignatedRouterID,omitempty"`
	BackupDesignatedRouterID uint32   `protobuf:"varint,7,opt,name=BackupDesignatedRouterID,proto3" json:"BackupDesignatedRouterID,omitempty"`
	NeighborID               []uint32 `protobuf:"varint,8,rep,packed,name=NeighborID" json:"NeighborID,omitempty"`
}

func (m *HelloPkg) Reset()         { *m = HelloPkg{} }
func (m *HelloPkg) String() string { return proto.CompactTextString(m) }
func (*HelloPkg) ProtoMessage()    {}
func (*HelloPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{77}
}
func (m *HelloPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HelloPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloPkg.Merge(dst, src)
}
func (m *HelloPkg) XXX_Size() int {
	return m.Size()
}
func (m *HelloPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloPkg.DiscardUnknown(m)
}

var xxx_messageInfo_HelloPkg proto.InternalMessageInfo

func (m *HelloPkg) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *HelloPkg) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *HelloPkg) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *HelloPkg) GetHelloInterval() int32 {
	if m != nil {
		return m.HelloInterval
	}
	return 0
}

func (m *HelloPkg) GetRouterDeadInterval() uint32 {
	if m != nil {
		return m.RouterDeadInterval
	}
	return 0
}

func (m *HelloPkg) GetDesignatedRouterID() uint32 {
	if m != nil {
		return m.DesignatedRouterID
	}
	return 0
}

func (m *HelloPkg) GetBackupDesignatedRouterID() uint32 {
	if m != nil {
		return m.BackupDesignatedRouterID
	}
	return 0
}

func (m *HelloPkg) GetNeighborID() []uint32 {
	if m != nil {
		return m.NeighborID
	}
	return nil
}

type HelloPkgV2 struct {
	InterfaceID              uint32   `protobuf:"varint,1,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	RtrPriority              int32    `protobuf:"varint,2,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options                  uint32   `protobuf:"varint,3,opt,name=Options,proto3" json:"Options,omitempty"`
	HelloInterval            int32    `protobuf:"varint,4,opt,name=HelloInterval,proto3" json:"HelloInterval,omitempty"`
	RouterDeadInterval       uint32   `protobuf:"varint,5,opt,name=RouterDeadInterval,proto3" json:"RouterDeadInterval,omitempty"`
	DesignatedRouterID       uint32   `protobuf:"varint,6,opt,name=DesignatedRouterID,proto3" json:"DesignatedRouterID,omitempty"`
	BackupDesignatedRouterID uint32   `protobuf:"varint,7,opt,name=BackupDesignatedRouterID,proto3" json:"BackupDesignatedRouterID,omitempty"`
	NeighborID               []uint32 `protobuf:"varint,8,rep,packed,name=NeighborID" json:"NeighborID,omitempty"`
	NetworkMask              uint32   `protobuf:"varint,9,opt,name=NetworkMask,proto3" json:"NetworkMask,omitempty"`
}

func (m *HelloPkgV2) Reset()         { *m = HelloPkgV2{} }
func (m *HelloPkgV2) String() string { return proto.CompactTextString(m) }
func (*HelloPkgV2) ProtoMessage()    {}
func (*HelloPkgV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{78}
}
func (m *HelloPkgV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloPkgV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloPkgV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HelloPkgV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloPkgV2.Merge(dst, src)
}
func (m *HelloPkgV2) XXX_Size() int {
	return m.Size()
}
func (m *HelloPkgV2) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloPkgV2.DiscardUnknown(m)
}

var xxx_messageInfo_HelloPkgV2 proto.InternalMessageInfo

func (m *HelloPkgV2) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *HelloPkgV2) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *HelloPkgV2) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *HelloPkgV2) GetHelloInterval() int32 {
	if m != nil {
		return m.HelloInterval
	}
	return 0
}

func (m *HelloPkgV2) GetRouterDeadInterval() uint32 {
	if m != nil {
		return m.RouterDeadInterval
	}
	return 0
}

func (m *HelloPkgV2) GetDesignatedRouterID() uint32 {
	if m != nil {
		return m.DesignatedRouterID
	}
	return 0
}

func (m *HelloPkgV2) GetBackupDesignatedRouterID() uint32 {
	if m != nil {
		return m.BackupDesignatedRouterID
	}
	return 0
}

func (m *HelloPkgV2) GetNeighborID() []uint32 {
	if m != nil {
		return m.NeighborID
	}
	return nil
}

func (m *HelloPkgV2) GetNetworkMask() uint32 {
	if m != nil {
		return m.NetworkMask
	}
	return 0
}

type DbDescPkg struct {
	Options      uint32       `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	InterfaceMTU int32        `protobuf:"varint,2,opt,name=InterfaceMTU,proto3" json:"InterfaceMTU,omitempty"`
	Flags        int32        `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	DDSeqNumber  uint32       `protobuf:"varint,4,opt,name=DDSeqNumber,proto3" json:"DDSeqNumber,omitempty"`
	LSAinfo      []*LSAheader `protobuf:"bytes,5,rep,name=LSAinfo" json:"LSAinfo,omitempty"`
}

func (m *DbDescPkg) Reset()         { *m = DbDescPkg{} }
func (m *DbDescPkg) String() string { return proto.CompactTextString(m) }
func (*DbDescPkg) ProtoMessage()    {}
func (*DbDescPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{79}
}
func (m *DbDescPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDescPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDescPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DbDescPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDescPkg.Merge(dst, src)
}
func (m *DbDescPkg) XXX_Size() int {
	return m.Size()
}
func (m *DbDescPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDescPkg.DiscardUnknown(m)
}

var xxx_messageInfo_DbDescPkg proto.InternalMessageInfo

func (m *DbDescPkg) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *DbDescPkg) GetInterfaceMTU() int32 {
	if m != nil {
		return m.InterfaceMTU
	}
	return 0
}

func (m *DbDescPkg) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *DbDescPkg) GetDDSeqNumber() uint32 {
	if m != nil {
		return m.DDSeqNumber
	}
	return 0
}

func (m *DbDescPkg) GetLSAinfo() []*LSAheader {
	if m != nil {
		return m.LSAinfo
	}
	return nil
}

type OSPFv3 struct {
	Timestamp    string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version      int32  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type         int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	PacketLength int32  `protobuf:"varint,4,opt,name=PacketLength,proto3" json:"PacketLength,omitempty"`
	RouterID     uint32 `protobuf:"varint,5,opt,name=RouterID,proto3" json:"RouterID,omitempty"`
	AreaID       uint32 `protobuf:"varint,6,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	Checksum     int32  `protobuf:"varint,7,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Instance     int32  `protobuf:"varint,8,opt,name=Instance,proto3" json:"Instance,omitempty"`
	Reserved     int32  `protobuf:"varint,9,opt,name=Reserved,proto3" json:"Reserved,omitempty"`
	// interface Content
	Hello  *HelloPkg    `protobuf:"bytes,10,opt,name=Hello" json:"Hello,omitempty"`
	DbDesc *DbDescPkg   `protobuf:"bytes,11,opt,name=DbDesc" json:"DbDesc,omitempty"`
	LSR    []*LSReq     `protobuf:"bytes,12,rep,name=LSR" json:"LSR,omitempty"`
	LSU    *LSUpdate    `protobuf:"bytes,13,opt,name=LSU" json:"LSU,omitempty"`
	LSAs   []*LSAheader `protobuf:"bytes,14,rep,name=LSAs" json:"LSAs,omitempty"`
}

func (m *OSPFv3) Reset()         { *m = OSPFv3{} }
func (m *OSPFv3) String() string { return proto.CompactTextString(m) }
func (*OSPFv3) ProtoMessage()    {}
func (*OSPFv3) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{80}
}
func (m *OSPFv3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSPFv3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSPFv3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OSPFv3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSPFv3.Merge(dst, src)
}
func (m *OSPFv3) XXX_Size() int {
	return m.Size()
}
func (m *OSPFv3) XXX_DiscardUnknown() {
	xxx_messageInfo_OSPFv3.DiscardUnknown(m)
}

var xxx_messageInfo_OSPFv3 proto.InternalMessageInfo

func (m *OSPFv3) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *OSPFv3) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OSPFv3) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *OSPFv3) GetPacketLength() int32 {
	if m != nil {
		return m.PacketLength
	}
	return 0
}

func (m *OSPFv3) GetRouterID() uint32 {
	if m != nil {
		return m.RouterID
	}
	return 0
}

func (m *OSPFv3) GetAreaID() uint32 {
	if m != nil {
		return m.AreaID
	}
	return 0
}

func (m *OSPFv3) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *OSPFv3) GetInstance() int32 {
	if m != nil {
		return m.Instance
	}
	return 0
}

func (m *OSPFv3) GetReserved() int32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *OSPFv3) GetHello() *HelloPkg {
	if m != nil {
		return m.Hello
	}
	return nil
}

func (m *OSPFv3) GetDbDesc() *DbDescPkg {
	if m != nil {
		return m.DbDesc
	}
	return nil
}

func (m *OSPFv3) GetLSR() []*LSReq {
	if m != nil {
		return m.LSR
	}
	return nil
}

func (m *OSPFv3) GetLSU() *LSUpdate {
	if m != nil {
		return m.LSU
	}
	return nil
}

func (m *OSPFv3) GetLSAs() []*LSAheader {
	if m != nil {
		return m.LSAs
	}
	return nil
}

type LSAheader struct {
	LSAge       int32  `protobuf:"varint,1,opt,name=LSAge,proto3" json:"LSAge,omitempty"`
	LSType      int32  `protobuf:"varint,2,opt,name=LSType,proto3" json:"LSType,omitempty"`
	LinkStateID uint32 `protobuf:"varint,3,opt,name=LinkStateID,proto3" json:"LinkStateID,omitempty"`
	AdvRouter   uint32 `protobuf:"varint,4,opt,name=AdvRouter,proto3" json:"AdvRouter,omitempty"`
	LSSeqNumber uint32 `protobuf:"varint,5,opt,name=LSSeqNumber,proto3" json:"LSSeqNumber,omitempty"`
	LSChecksum  int32  `protobuf:"varint,6,opt,name=LSChecksum,proto3" json:"LSChecksum,omitempty"`
	Length      int32  `protobuf:"varint,7,opt,name=Length,proto3" json:"Length,omitempty"`
	LSOptions   int32  `protobuf:"varint,8,opt,name=LSOptions,proto3" json:"LSOptions,omitempty"`
}

func (m *LSAheader) Reset()         { *m = LSAheader{} }
func (m *LSAheader) String() string { return proto.CompactTextString(m) }
func (*LSAheader) ProtoMessage()    {}
func (*LSAheader) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{81}
}
func (m *LSAheader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSAheader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSAheader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LSAheader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSAheader.Merge(dst, src)
}
func (m *LSAheader) XXX_Size() int {
	return m.Size()
}
func (m *LSAheader) XXX_DiscardUnknown() {
	xxx_messageInfo_LSAheader.DiscardUnknown(m)
}

var xxx_messageInfo_LSAheader proto.InternalMessageInfo

func (m *LSAheader) GetLSAge() int32 {
	if m != nil {
		return m.LSAge
	}
	return 0
}

func (m *LSAheader) GetLSType() int32 {
	if m != nil {
		return m.LSType
	}
	return 0
}

func (m *LSAheader) GetLinkStateID() uint32 {
	if m != nil {
		return m.LinkStateID
	}
	return 0
}

func (m *LSAheader) GetAdvRouter() uint32 {
	if m != nil {
		return m.AdvRouter
	}
	return 0
}

func (m *LSAheader) GetLSSeqNumber() uint32 {
	if m != nil {
		return m.LSSeqNumber
	}
	return 0
}

func (m *LSAheader) GetLSChecksum() int32 {
	if m != nil {
		return m.LSChecksum
	}
	return 0
}

func (m *LSAheader) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *LSAheader) GetLSOptions() int32 {
	if m != nil {
		return m.LSOptions
	}
	return 0
}

type LSA struct {
	Header *LSAheader `protobuf:"bytes,1,opt,name=Header" json:"Header,omitempty"`
	// interface Content
	RLSAV2          *RouterLSAV2        `protobuf:"bytes,2,opt,name=RLSAV2" json:"RLSAV2,omitempty"`
	ASELSAV2        *ASExternalLSAV2    `protobuf:"bytes,3,opt,name=ASELSAV2" json:"ASELSAV2,omitempty"`
	RLSA            *RouterLSA          `protobuf:"bytes,4,opt,name=RLSA" json:"RLSA,omitempty"`
	NLSA            *NetworkLSA         `protobuf:"bytes,5,opt,name=NLSA" json:"NLSA,omitempty"`
	InterAPrefixLSA *InterAreaPrefixLSA `protobuf:"bytes,6,opt,name=InterAPrefixLSA" json:"InterAPrefixLSA,omitempty"`
	IARouterLSA     *InterAreaRouterLSA `protobuf:"bytes,7,opt,name=IARouterLSA" json:"IARouterLSA,omitempty"`
	ASELSA          *ASExternalLSA      `protobuf:"bytes,8,opt,name=ASELSA" json:"ASELSA,omitempty"`
	LLSA            *LinkLSA            `protobuf:"bytes,9,opt,name=LLSA" json:"LLSA,omitempty"`
	IntraAPrefixLSA *IntraAreaPrefixLSA `protobuf:"bytes,10,opt,name=IntraAPrefixLSA" json:"IntraAPrefixLSA,omitempty"`
}

func (m *LSA) Reset()         { *m = LSA{} }
func (m *LSA) String() string { return proto.CompactTextString(m) }
func (*LSA) ProtoMessage()    {}
func (*LSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{82}
}
func (m *LSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSA.Merge(dst, src)
}
func (m *LSA) XXX_Size() int {
	return m.Size()
}
func (m *LSA) XXX_DiscardUnknown() {
	xxx_messageInfo_LSA.DiscardUnknown(m)
}

var xxx_messageInfo_LSA proto.InternalMessageInfo

func (m *LSA) GetHeader() *LSAheader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *LSA) GetRLSAV2() *RouterLSAV2 {
	if m != nil {
		return m.RLSAV2
	}
	return nil
}

func (m *LSA) GetASELSAV2() *ASExternalLSAV2 {
	if m != nil {
		return m.ASELSAV2
	}
	return nil
}

func (m *LSA) GetRLSA() *RouterLSA {
	if m != nil {
		return m.RLSA
	}
	return nil
}

func (m *LSA) GetNLSA() *NetworkLSA {
	if m != nil {
		return m.NLSA
	}
	return nil
}

func (m *LSA) GetInterAPrefixLSA() *InterAreaPrefixLSA {
	if m != nil {
		return m.InterAPrefixLSA
	}
	return nil
}

func (m *LSA) GetIARouterLSA() *InterAreaRouterLSA {
	if m != nil {
		return m.IARouterLSA
	}
	return nil
}

func (m *LSA) GetASELSA() *ASExternalLSA {
	if m != nil {
		return m.ASELSA
	}
	return nil
}

func (m *LSA) GetLLSA() *LinkLSA {
	if m != nil {
		return m.LLSA
	}
	return nil
}

func (m *LSA) GetIntraAPrefixLSA() *IntraAreaPrefixLSA {
	if m != nil {
		return m.IntraAPrefixLSA
	}
	return nil
}

type LSReq struct {
	LSType    int32  `protobuf:"varint,1,opt,name=LSType,proto3" json:"LSType,omitempty"`
	LSID      uint32 `protobuf:"varint,2,opt,name=LSID,proto3" json:"LSID,omitempty"`
	AdvRouter uint32 `protobuf:"varint,3,opt,name=AdvRouter,proto3" json:"AdvRouter,omitempty"`
}

func (m *LSReq) Reset()         { *m = LSReq{} }
func (m *LSReq) String() string { return proto.CompactTextString(m) }
func (*LSReq) ProtoMessage()    {}
func (*LSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{83}
}
func (m *LSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSReq.Merge(dst, src)
}
func (m *LSReq) XXX_Size() int {
	return m.Size()
}
func (m *LSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LSReq.DiscardUnknown(m)
}

var xxx_messageInfo_LSReq proto.InternalMessageInfo

func (m *LSReq) GetLSType() int32 {
	if m != nil {
		return m.LSType
	}
	return 0
}

func (m *LSReq) GetLSID() uint32 {
	if m != nil {
		return m.LSID
	}
	return 0
}

func (m *LSReq) GetAdvRouter() uint32 {
	if m != nil {
		return m.AdvRouter
	}
	return 0
}

type LSUpdate struct {
	NumOfLSAs uint32 `protobuf:"varint,1,opt,name=NumOfLSAs,proto3" json:"NumOfLSAs,omitempty"`
	LSAs      []*LSA `protobuf:"bytes,2,rep,name=LSAs" json:"LSAs,omitempty"`
}

func (m *LSUpdate) Reset()         { *m = LSUpdate{} }
func (m *LSUpdate) String() string { return proto.CompactTextString(m) }
func (*LSUpdate) ProtoMessage()    {}
func (*LSUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{84}
}
func (m *LSUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LSUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSUpdate.Merge(dst, src)
}
func (m *LSUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LSUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LSUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LSUpdate proto.InternalMessageInfo

func (m *LSUpdate) GetNumOfLSAs() uint32 {
	if m != nil {
		return m.NumOfLSAs
	}
	return 0
}

func (m *LSUpdate) GetLSAs() []*LSA {
	if m != nil {
		return m.LSAs
	}
	return nil
}

type IntraAreaPrefixLSA struct {
	NumOfPrefixes  int32        `protobuf:"varint,1,opt,name=NumOfPrefixes,proto3" json:"NumOfPrefixes,omitempty"`
	RefLSType      int32        `protobuf:"varint,2,opt,name=RefLSType,proto3" json:"RefLSType,omitempty"`
	RefLinkStateID uint32       `protobuf:"varint,3,opt,name=RefLinkStateID,proto3" json:"RefLinkStateID,omitempty"`
	RefAdvRouter   uint32       `protobuf:"varint,4,opt,name=RefAdvRouter,proto3" json:"RefAdvRouter,omitempty"`
	Prefixes       []*LSAPrefix `protobuf:"bytes,5,rep,name=Prefixes" json:"Prefixes,omitempty"`
}

func (m *IntraAreaPrefixLSA) Reset()         { *m = IntraAreaPrefixLSA{} }
func (m *IntraAreaPrefixLSA) String() string { return proto.CompactTextString(m) }
func (*IntraAreaPrefixLSA) ProtoMessage()    {}
func (*IntraAreaPrefixLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{85}
}
func (m *IntraAreaPrefixLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntraAreaPrefixLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntraAreaPrefixLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IntraAreaPrefixLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntraAreaPrefixLSA.Merge(dst, src)
}
func (m *IntraAreaPrefixLSA) XXX_Size() int {
	return m.Size()
}
func (m *IntraAreaPrefixLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_IntraAreaPrefixLSA.DiscardUnknown(m)
}

var xxx_messageInfo_IntraAreaPrefixLSA proto.InternalMessageInfo

func (m *IntraAreaPrefixLSA) GetNumOfPrefixes() int32 {
	if m != nil {
		return m.NumOfPrefixes
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefLSType() int32 {
	if m != nil {
		return m.RefLSType
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefLinkStateID() uint32 {
	if m != nil {
		return m.RefLinkStateID
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefAdvRouter() uint32 {
	if m != nil {
		return m.RefAdvRouter
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetPrefixes() []*LSAPrefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type ASExternalLSA struct {
	Flags             int32  `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Metric            uint32 `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	PrefixLength      int32  `protobuf:"varint,3,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions     int32  `protobuf:"varint,4,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	RefLSType         int32  `protobuf:"varint,5,opt,name=RefLSType,proto3" json:"RefLSType,omitempty"`
	AddressPrefix     []byte `protobuf:"bytes,6,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
	ForwardingAddress []byte `protobuf:"bytes,7,opt,name=ForwardingAddress,proto3" json:"ForwardingAddress,omitempty"`
	ExternalRouteTag  uint32 `protobuf:"varint,8,opt,name=ExternalRouteTag,proto3" json:"ExternalRouteTag,omitempty"`
	RefLinkStateID    uint32 `protobuf:"varint,9,opt,name=RefLinkStateID,proto3" json:"RefLinkStateID,omitempty"`
}

func (m *ASExternalLSA) Reset()         { *m = ASExternalLSA{} }
func (m *ASExternalLSA) String() string { return proto.CompactTextString(m) }
func (*ASExternalLSA) ProtoMessage()    {}
func (*ASExternalLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{86}
}
func (m *ASExternalLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ASExternalLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ASExternalLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ASExternalLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASExternalLSA.Merge(dst, src)
}
func (m *ASExternalLSA) XXX_Size() int {
	return m.Size()
}
func (m *ASExternalLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_ASExternalLSA.DiscardUnknown(m)
}

var xxx_messageInfo_ASExternalLSA proto.InternalMessageInfo

func (m *ASExternalLSA) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ASExternalLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *ASExternalLSA) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *ASExternalLSA) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *ASExternalLSA) GetRefLSType() int32 {
	if m != nil {
		return m.RefLSType
	}
	return 0
}

func (m *ASExternalLSA) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

func (m *ASExternalLSA) GetForwardingAddress() []byte {
	if m != nil {
		return m.ForwardingAddress
	}
	return nil
}

func (m *ASExternalLSA) GetExternalRouteTag() uint32 {
	if m != nil {
		return m.ExternalRouteTag
	}
	return 0
}

func (m *ASExternalLSA) GetRefLinkStateID() uint32 {
	if m != nil {
		return m.RefLinkStateID
	}
	return 0
}

type InterAreaPrefixLSA struct {
	Metric        uint32 `protobuf:"varint,1,opt,name=Metric,proto3" json:"Metric,omitempty"`
	PrefixLength  int32  `protobuf:"varint,2,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions int32  `protobuf:"varint,3,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	AddressPrefix []byte `protobuf:"bytes,4,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
}

func (m *InterAreaPrefixLSA) Reset()         { *m = InterAreaPrefixLSA{} }
func (m *InterAreaPrefixLSA) String() string { return proto.CompactTextString(m) }
func (*InterAreaPrefixLSA) ProtoMessage()    {}
func (*InterAreaPrefixLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{87}
}
func (m *InterAreaPrefixLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterAreaPrefixLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterAreaPrefixLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InterAreaPrefixLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterAreaPrefixLSA.Merge(dst, src)
}
func (m *InterAreaPrefixLSA) XXX_Size() int {
	return m.Size()
}
func (m *InterAreaPrefixLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_InterAreaPrefixLSA.DiscardUnknown(m)
}

var xxx_messageInfo_InterAreaPrefixLSA proto.InternalMessageInfo

func (m *InterAreaPrefixLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

type InterAreaRouterLSA struct {
	Options             uint32 `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	Metric              uint32 `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	DestinationRouterID uint32 `protobuf:"varint,3,opt,name=DestinationRouterID,proto3" json:"DestinationRouterID,omitempty"`
}

func (m *InterAreaRouterLSA) Reset()         { *m = InterAreaRouterLSA{} }
func (m *InterAreaRouterLSA) String() string { return proto.CompactTextString(m) }
func (*InterAreaRouterLSA) ProtoMessage()    {}
func (*InterAreaRouterLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{88}
}
func (m *InterAreaRouterLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterAreaRouterLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterAreaRouterLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InterAreaRouterLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterAreaRouterLSA.Merge(dst, src)
}
func (m *InterAreaRouterLSA) XXX_Size() int {
	return m.Size()
}
func (m *InterAreaRouterLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_InterAreaRouterLSA.DiscardUnknown(m)
}

var xxx_messageInfo_InterAreaRouterLSA proto.InternalMessageInfo

func (m *InterAreaRouterLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *InterAreaRouterLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *InterAreaRouterLSA) GetDestinationRouterID() uint32 {
	if m != nil {
		return m.DestinationRouterID
	}
	return 0
}

type ASExternalLSAV2 struct {
	NetworkMask       uint32 `protobuf:"varint,1,opt,name=NetworkMask,proto3" json:"NetworkMask,omitempty"`
	ExternalBit       int32  `protobuf:"varint,2,opt,name=ExternalBit,proto3" json:"ExternalBit,omitempty"`
	Metric            uint32 `protobuf:"varint,3,opt,name=Metric,proto3" json:"Metric,omitempty"`
	ForwardingAddress uint32 `protobuf:"varint,4,opt,name=ForwardingAddress,proto3" json:"ForwardingAddress,omitempty"`
	ExternalRouteTag  uint32 `protobuf:"varint,5,opt,name=ExternalRouteTag,proto3" json:"ExternalRouteTag,omitempty"`
}

func (m *ASExternalLSAV2) Reset()         { *m = ASExternalLSAV2{} }
func (m *ASExternalLSAV2) String() string { return proto.CompactTextString(m) }
func (*ASExternalLSAV2) ProtoMessage()    {}
func (*ASExternalLSAV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{89}
}
func (m *ASExternalLSAV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ASExternalLSAV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ASExternalLSAV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ASExternalLSAV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASExternalLSAV2.Merge(dst, src)
}
func (m *ASExternalLSAV2) XXX_Size() int {
	return m.Size()
}
func (m *ASExternalLSAV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ASExternalLSAV2.DiscardUnknown(m)
}

var xxx_messageInfo_ASExternalLSAV2 proto.InternalMessageInfo

func (m *ASExternalLSAV2) GetNetworkMask() uint32 {
	if m != nil {
		return m.NetworkMask
	}
	return 0
}

func (m *ASExternalLSAV2) GetExternalBit() int32 {
	if m != nil {
		return m.ExternalBit
	}
	return 0
}

func (m *ASExternalLSAV2) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *ASExternalLSAV2) GetForwardingAddress() uint32 {
	if m != nil {
		return m.ForwardingAddress
	}
	return 0
}

func (m *ASExternalLSAV2) GetExternalRouteTag() uint32 {
	if m != nil {
		return m.ExternalRouteTag
	}
	return 0
}

type RouterLSA struct {
	Flags   int32     `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Options uint32    `protobuf:"varint,2,opt,name=Options,proto3" json:"Options,omitempty"`
	Routers []*Router `protobuf:"bytes,3,rep,name=Routers" json:"Routers,omitempty"`
}

func (m *RouterLSA) Reset()         { *m = RouterLSA{} }
func (m *RouterLSA) String() string { return proto.CompactTextString(m) }
func (*RouterLSA) ProtoMessage()    {}
func (*RouterLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{90}
}
func (m *RouterLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RouterLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterLSA.Merge(dst, src)
}
func (m *RouterLSA) XXX_Size() int {
	return m.Size()
}
func (m *RouterLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterLSA.DiscardUnknown(m)
}

var xxx_messageInfo_RouterLSA proto.InternalMessageInfo

func (m *RouterLSA) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RouterLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *RouterLSA) GetRouters() []*Router {
	if m != nil {
		return m.Routers
	}
	return nil
}

type Router struct {
	Type                int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Metric              int32  `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	InterfaceID         uint32 `protobuf:"varint,3,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	NeighborInterfaceID uint32 `protobuf:"varint,4,opt,name=NeighborInterfaceID,proto3" json:"NeighborInterfaceID,omitempty"`
	NeighborRouterID    uint32 `protobuf:"varint,5,opt,name=NeighborRouterID,proto3" json:"NeighborRouterID,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{91}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(dst, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Router) GetMetric() int32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *Router) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *Router) GetNeighborInterfaceID() uint32 {
	if m != nil {
		return m.NeighborInterfaceID
	}
	return 0
}

func (m *Router) GetNeighborRouterID() uint32 {
	if m != nil {
		return m.NeighborRouterID
	}
	return 0
}

type RouterLSAV2 struct {
	Flags   int32       `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Links   int32       `protobuf:"varint,2,opt,name=Links,proto3" json:"Links,omitempty"`
	Routers []*RouterV2 `protobuf:"bytes,3,rep,name=Routers" json:"Routers,omitempty"`
}

func (m *RouterLSAV2) Reset()         { *m = RouterLSAV2{} }
func (m *RouterLSAV2) String() string { return proto.CompactTextString(m) }
func (*RouterLSAV2) ProtoMessage()    {}
func (*RouterLSAV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{92}
}
func (m *RouterLSAV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterLSAV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterLSAV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RouterLSAV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterLSAV2.Merge(dst, src)
}
func (m *RouterLSAV2) XXX_Size() int {
	return m.Size()
}
func (m *RouterLSAV2) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterLSAV2.DiscardUnknown(m)
}

var xxx_messageInfo_RouterLSAV2 proto.InternalMessageInfo

func (m *RouterLSAV2) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RouterLSAV2) GetLinks() int32 {
	if m != nil {
		return m.Links
	}
	return 0
}

func (m *RouterLSAV2) GetRouters() []*RouterV2 {
	if m != nil {
		return m.Routers
	}
	return nil
}

type RouterV2 struct {
	Type     int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	LinkID   uint32 `protobuf:"varint,2,opt,name=LinkID,proto3" json:"LinkID,omitempty"`
	LinkData uint32 `protobuf:"varint,3,opt,name=LinkData,proto3" json:"LinkData,omitempty"`
	Metric   uint32 `protobuf:"varint,4,opt,name=Metric,proto3" json:"Metric,omitempty"`
}

func (m *RouterV2) Reset()         { *m = RouterV2{} }
func (m *RouterV2) String() string { return proto.CompactTextString(m) }
func (*RouterV2) ProtoMessage()    {}
func (*RouterV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{93}
}
func (m *RouterV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RouterV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterV2.Merge(dst, src)
}
func (m *RouterV2) XXX_Size() int {
	return m.Size()
}
func (m *RouterV2) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterV2.DiscardUnknown(m)
}

var xxx_messageInfo_RouterV2 proto.InternalMessageInfo

func (m *RouterV2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RouterV2) GetLinkID() uint32 {
	if m != nil {
		return m.LinkID
	}
	return 0
}

func (m *RouterV2) GetLinkData() uint32 {
	if m != nil {
		return m.LinkData
	}
	return 0
}

func (m *RouterV2) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

type NetworkLSA struct {
	Options        uint32   `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	AttachedRouter []uint32 `protobuf:"varint,2,rep,packed,name=AttachedRouter" json:"AttachedRouter,omitempty"`
}

func (m *NetworkLSA) Reset()         { *m = NetworkLSA{} }
func (m *NetworkLSA) String() string { return proto.CompactTextString(m) }
func (*NetworkLSA) ProtoMessage()    {}
func (*NetworkLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{94}
}
func (m *NetworkLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetworkLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkLSA.Merge(dst, src)
}
func (m *NetworkLSA) XXX_Size() int {
	return m.Size()
}
func (m *NetworkLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkLSA.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkLSA proto.InternalMessageInfo

func (m *NetworkLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *NetworkLSA) GetAttachedRouter() []uint32 {
	if m != nil {
		return m.AttachedRouter
	}
	return nil
}

type LinkLSA struct {
	RtrPriority      int32        `protobuf:"varint,1,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options          uint32       `protobuf:"varint,2,opt,name=Options,proto3" json:"Options,omitempty"`
	LinkLocalAddress []byte       `protobuf:"bytes,3,opt,name=LinkLocalAddress,proto3" json:"LinkLocalAddress,omitempty"`
	NumOfPrefixes    uint32       `protobuf:"varint,4,opt,name=NumOfPrefixes,proto3" json:"NumOfPrefixes,omitempty"`
	Prefixes         []*LSAPrefix `protobuf:"bytes,5,rep,name=Prefixes" json:"Prefixes,omitempty"`
}

func (m *LinkLSA) Reset()         { *m = LinkLSA{} }
func (m *LinkLSA) String() string { return proto.CompactTextString(m) }
func (*LinkLSA) ProtoMessage()    {}
func (*LinkLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{95}
}
func (m *LinkLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LinkLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLSA.Merge(dst, src)
}
func (m *LinkLSA) XXX_Size() int {
	return m.Size()
}
func (m *LinkLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLSA.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLSA proto.InternalMessageInfo

func (m *LinkLSA) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *LinkLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *LinkLSA) GetLinkLocalAddress() []byte {
	if m != nil {
		return m.LinkLocalAddress
	}
	return nil
}

func (m *LinkLSA) GetNumOfPrefixes() uint32 {
	if m != nil {
		return m.NumOfPrefixes
	}
	return 0
}

func (m *LinkLSA) GetPrefixes() []*LSAPrefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type LSAPrefix struct {
	PrefixLength  int32  `protobuf:"varint,1,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions int32  `protobuf:"varint,2,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	Metric        int32  `protobuf:"varint,3,opt,name=Metric,proto3" json:"Metric,omitempty"`
	AddressPrefix []byte `protobuf:"bytes,4,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
}

func (m *LSAPrefix) Reset()         { *m = LSAPrefix{} }
func (m *LSAPrefix) String() string { return proto.CompactTextString(m) }
func (*LSAPrefix) ProtoMessage()    {}
func (*LSAPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{96}
}
func (m *LSAPrefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSAPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSAPrefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LSAPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSAPrefix.Merge(dst, src)
}
func (m *LSAPrefix) XXX_Size() int {
	return m.Size()
}
func (m *LSAPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_LSAPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_LSAPrefix proto.InternalMessageInfo

func (m *LSAPrefix) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *LSAPrefix) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *LSAPrefix) GetMetric() int32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *LSAPrefix) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

type BFD struct {
	Timestamp                 string         `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version                   int32          `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Diagnostic                int32          `protobuf:"varint,3,opt,name=Diagnostic,proto3" json:"Diagnostic,omitempty"`
	State                     int32          `protobuf:"varint,4,opt,name=State,proto3" json:"State,omitempty"`
	Poll                      bool           `protobuf:"varint,5,opt,name=Poll,proto3" json:"Poll,omitempty"`
	Final                     bool           `protobuf:"varint,6,opt,name=Final,proto3" json:"Final,omitempty"`
	ControlPlaneIndependent   bool           `protobuf:"varint,7,opt,name=ControlPlaneIndependent,proto3" json:"ControlPlaneIndependent,omitempty"`
	AuthPresent               bool           `protobuf:"varint,8,opt,name=AuthPresent,proto3" json:"AuthPresent,omitempty"`
	Demand                    bool           `protobuf:"varint,9,opt,name=Demand,proto3" json:"Demand,omitempty"`
	Multipoint                bool           `protobuf:"varint,10,opt,name=Multipoint,proto3" json:"Multipoint,omitempty"`
	DetectMultiplier          int32          `protobuf:"varint,11,opt,name=DetectMultiplier,proto3" json:"DetectMultiplier,omitempty"`
	MyDiscriminator           int32          `protobuf:"varint,12,opt,name=MyDiscriminator,proto3" json:"MyDiscriminator,omitempty"`
	YourDiscriminator         int32          `protobuf:"varint,13,opt,name=YourDiscriminator,proto3" json:"YourDiscriminator,omitempty"`
	DesiredMinTxInterval      int32          `protobuf:"varint,14,opt,name=DesiredMinTxInterval,proto3" json:"DesiredMinTxInterval,omitempty"`
	RequiredMinRxInterval     int32          `protobuf:"varint,15,opt,name=RequiredMinRxInterval,proto3" json:"RequiredMinRxInterval,omitempty"`
	RequiredMinEchoRxInterval int32          `protobuf:"varint,16,opt,name=RequiredMinEchoRxInterval,proto3" json:"RequiredMinEchoRxInterval,omitempty"`
	AuthHeader                *BFDAuthHeader `protobuf:"bytes,17,opt,name=AuthHeader" json:"AuthHeader,omitempty"`
}

func (m *BFD) Reset()         { *m = BFD{} }
func (m *BFD) String() string { return proto.CompactTextString(m) }
func (*BFD) ProtoMessage()    {}
func (*BFD) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{97}
}
func (m *BFD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BFD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BFD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BFD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BFD.Merge(dst, src)
}
func (m *BFD) XXX_Size() int {
	return m.Size()
}
func (m *BFD) XXX_DiscardUnknown() {
	xxx_messageInfo_BFD.DiscardUnknown(m)
}

var xxx_messageInfo_BFD proto.InternalMessageInfo

func (m *BFD) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *BFD) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BFD) GetDiagnostic() int32 {
	if m != nil {
		return m.Diagnostic
	}
	return 0
}

func (m *BFD) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *BFD) GetPoll() bool {
	if m != nil {
		return m.Poll
	}
	return false
}

func (m *BFD) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *BFD) GetControlPlaneIndependent() bool {
	if m != nil {
		return m.ControlPlaneIndependent
	}
	return false
}

func (m *BFD) GetAuthPresent() bool {
	if m != nil {
		return m.AuthPresent
	}
	return false
}

func (m *BFD) GetDemand() bool {
	if m != nil {
		return m.Demand
	}
	return false
}

func (m *BFD) GetMultipoint() bool {
	if m != nil {
		return m.Multipoint
	}
	return false
}

func (m *BFD) GetDetectMultiplier() int32 {
	if m != nil {
		return m.DetectMultiplier
	}
	return 0
}

func (m *BFD) GetMyDiscriminator() int32 {
	if m != nil {
		return m.MyDiscriminator
	}
	return 0
}

func (m *BFD) GetYourDiscriminator() int32 {
	if m != nil {
		return m.YourDiscriminator
	}
	return 0
}

func (m *BFD) GetDesiredMinTxInterval() int32 {
	if m != nil {
		return m.DesiredMinTxInterval
	}
	return 0
}

func (m *BFD) GetRequiredMinRxInterval() int32 {
	if m != nil {
		return m.RequiredMinRxInterval
	}
	return 0
}

func (m *BFD) GetRequiredMinEchoRxInterval() int32 {
	if m != nil {
		return m.RequiredMinEchoRxInterval
	}
	return 0
}

func (m *BFD) GetAuthHeader() *BFDAuthHeader {
	if m != nil {
		return m.AuthHeader
	}
	return nil
}

type BFDAuthHeader struct {
	AuthType       int32  `protobuf:"varint,1,opt,name=AuthType,proto3" json:"AuthType,omitempty"`
	KeyID          int32  `protobuf:"varint,2,opt,name=KeyID,proto3" json:"KeyID,omitempty"`
	SequenceNumber int32  `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	Data           []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *BFDAuthHeader) Reset()         { *m = BFDAuthHeader{} }
func (m *BFDAuthHeader) String() string { return proto.CompactTextString(m) }
func (*BFDAuthHeader) ProtoMessage()    {}
func (*BFDAuthHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{98}
}
func (m *BFDAuthHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BFDAuthHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BFDAuthHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BFDAuthHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BFDAuthHeader.Merge(dst, src)
}
func (m *BFDAuthHeader) XXX_Size() int {
	return m.Size()
}
func (m *BFDAuthHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BFDAuthHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BFDAuthHeader proto.InternalMessageInfo

func (m *BFDAuthHeader) GetAuthType() int32 {
	if m != nil {
		return m.AuthType
	}
	return 0
}

func (m *BFDAuthHeader) GetKeyID() int32 {
	if m != nil {
		return m.KeyID
	}
	return 0
}

func (m *BFDAuthHeader) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *BFDAuthHeader) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type GRE struct {
	Timestamp         string      `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ChecksumPresent   bool        `protobuf:"varint,2,opt,name=ChecksumPresent,proto3" json:"ChecksumPresent,omitempty"`
	RoutingPresent    bool        `protobuf:"varint,3,opt,name=RoutingPresent,proto3" json:"RoutingPresent,omitempty"`
	KeyPresent        bool        `protobuf:"varint,4,opt,name=KeyPresent,proto3" json:"KeyPresent,omitempty"`
	SeqPresent        bool        `protobuf:"varint,5,opt,name=SeqPresent,proto3" json:"SeqPresent,omitempty"`
	StrictSourceRoute bool        `protobuf:"varint,6,opt,name=StrictSourceRoute,proto3" json:"StrictSourceRoute,omitempty"`
	AckPresent        bool        `protobuf:"varint,7,opt,name=AckPresent,proto3" json:"AckPresent,omitempty"`
	RecursionControl  int32       `protobuf:"varint,8,opt,name=RecursionControl,proto3" json:"RecursionControl,omitempty"`
	Flags             int32       `protobuf:"varint,9,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Version           int32       `protobuf:"varint,10,opt,name=Version,proto3" json:"Version,omitempty"`
	Protocol          int32       `protobuf:"varint,11,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Checksum          int32       `protobuf:"varint,12,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Offset            int32       `protobuf:"varint,13,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Key               uint32      `protobuf:"varint,14,opt,name=Key,proto3" json:"Key,omitempty"`
	Seq               uint32      `protobuf:"varint,15,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Ack               uint32      `protobuf:"varint,16,opt,name=Ack,proto3" json:"Ack,omitempty"`
	Routing           *GRERouting `protobuf:"bytes,17,opt,name=Routing" json:"Routing,omitempty"`
}

func (m *GRE) Reset()         { *m = GRE{} }
func (m *GRE) String() string { return proto.CompactTextString(m) }
func (*GRE) ProtoMessage()    {}
func (*GRE) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{99}
}
func (m *GRE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GRE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRE.Merge(dst, src)
}
func (m *GRE) XXX_Size() int {
	return m.Size()
}
func (m *GRE) XXX_DiscardUnknown() {
	xxx_messageInfo_GRE.DiscardUnknown(m)
}

var xxx_messageInfo_GRE proto.InternalMessageInfo

func (m *GRE) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *GRE) GetChecksumPresent() bool {
	if m != nil {
		return m.ChecksumPresent
	}
	return false
}

func (m *GRE) GetRoutingPresent() bool {
	if m != nil {
		return m.RoutingPresent
	}
	return false
}

func (m *GRE) GetKeyPresent() bool {
	if m != nil {
		return m.KeyPresent
	}
	return false
}

func (m *GRE) GetSeqPresent() bool {
	if m != nil {
		return m.SeqPresent
	}
	return false
}

func (m *GRE) GetStrictSourceRoute() bool {
	if m != nil {
		return m.StrictSourceRoute
	}
	return false
}

func (m *GRE) GetAckPresent() bool {
	if m != nil {
		return m.AckPresent
	}
	return false
}

func (m *GRE) GetRecursionControl() int32 {
	if m != nil {
		return m.RecursionControl
	}
	return 0
}

func (m *GRE) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *GRE) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GRE) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *GRE) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *GRE) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GRE) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *GRE) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *GRE) GetAck() uint32 {
	if m != nil {
		return m.Ack
	}
	return 0
}

func (m *GRE) GetRouting() *GRERouting {
	if m != nil {
		return m.Routing
	}
	return nil
}

type GRERouting struct {
	AddressFamily      int32       `protobuf:"varint,1,opt,name=AddressFamily,proto3" json:"AddressFamily,omitempty"`
	SREOffset          int32       `protobuf:"varint,2,opt,name=SREOffset,proto3" json:"SREOffset,omitempty"`
	SRELength          int32       `protobuf:"varint,3,opt,name=SRELength,proto3" json:"SRELength,omitempty"`
	RoutingInformation []byte      `protobuf:"bytes,4,opt,name=RoutingInformation,proto3" json:"RoutingInformation,omitempty"`
	Next               *GRERouting `protobuf:"bytes,5,opt,name=Next" json:"Next,omitempty"`
}

func (m *GRERouting) Reset()         { *m = GRERouting{} }
func (m *GRERouting) String() string { return proto.CompactTextString(m) }
func (*GRERouting) ProtoMessage()    {}
func (*GRERouting) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{100}
}
func (m *GRERouting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRERouting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRERouting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GRERouting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRERouting.Merge(dst, src)
}
func (m *GRERouting) XXX_Size() int {
	return m.Size()
}
func (m *GRERouting) XXX_DiscardUnknown() {
	xxx_messageInfo_GRERouting.DiscardUnknown(m)
}

var xxx_messageInfo_GRERouting proto.InternalMessageInfo

func (m *GRERouting) GetAddressFamily() int32 {
	if m != nil {
		return m.AddressFamily
	}
	return 0
}

func (m *GRERouting) GetSREOffset() int32 {
	if m != nil {
		return m.SREOffset
	}
	return 0
}

func (m *GRERouting) GetSRELength() int32 {
	if m != nil {
		return m.SRELength
	}
	return 0
}

func (m *GRERouting) GetRoutingInformation() []byte {
	if m != nil {
		return m.RoutingInformation
	}
	return nil
}

func (m *GRERouting) GetNext() *GRERouting {
	if m != nil {
		return m.Next
	}
	return nil
}

type FDDI struct {
	Timestamp    string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	FrameControl int32  `protobuf:"varint,2,opt,name=FrameControl,proto3" json:"FrameControl,omitempty"`
	Priority     int32  `protobuf:"varint,3,opt,name=Priority,proto3" json:"Priority,omitempty"`
	SrcMAC       string `protobuf:"bytes,4,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC       string `protobuf:"bytes,5,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
}

func (m *FDDI) Reset()         { *m = FDDI{} }
func (m *FDDI) String() string { return proto.CompactTextString(m) }
func (*FDDI) ProtoMessage()    {}
func (*FDDI) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{101}
}
func (m *FDDI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FDDI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FDDI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FDDI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FDDI.Merge(dst, src)
}
func (m *FDDI) XXX_Size() int {
	return m.Size()
}
func (m *FDDI) XXX_DiscardUnknown() {
	xxx_messageInfo_FDDI.DiscardUnknown(m)
}

var xxx_messageInfo_FDDI proto.InternalMessageInfo

func (m *FDDI) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *FDDI) GetFrameControl() int32 {
	if m != nil {
		return m.FrameControl
	}
	return 0
}

func (m *FDDI) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *FDDI) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *FDDI) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

// EAP defines an Extensible Authentication Protocol (rfc 3748) layer.
type EAP struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Code      int32  `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Id        int32  `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	Length    int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Type      int32  `protobuf:"varint,5,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeData  []byte `protobuf:"bytes,6,opt,name=TypeData,proto3" json:"TypeData,omitempty"`
}

func (m *EAP) Reset()         { *m = EAP{} }
func (m *EAP) String() string { return proto.CompactTextString(m) }
func (*EAP) ProtoMessage()    {}
func (*EAP) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{102}
}
func (m *EAP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EAP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAP.Merge(dst, src)
}
func (m *EAP) XXX_Size() int {
	return m.Size()
}
func (m *EAP) XXX_DiscardUnknown() {
	xxx_messageInfo_EAP.DiscardUnknown(m)
}

var xxx_messageInfo_EAP proto.InternalMessageInfo

func (m *EAP) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EAP) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EAP) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EAP) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *EAP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EAP) GetTypeData() []byte {
	if m != nil {
		return m.TypeData
	}
	return nil
}

// EAPOL defines an EAP over LAN (802.1x) layer.
type EAPOL struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version   int32  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type      int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	Length    int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
}

func (m *EAPOL) Reset()         { *m = EAPOL{} }
func (m *EAPOL) String() string { return proto.CompactTextString(m) }
func (*EAPOL) ProtoMessage()    {}
func (*EAPOL) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{103}
}
func (m *EAPOL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAPOL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAPOL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EAPOL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAPOL.Merge(dst, src)
}
func (m *EAPOL) XXX_Size() int {
	return m.Size()
}
func (m *EAPOL) XXX_DiscardUnknown() {
	xxx_messageInfo_EAPOL.DiscardUnknown(m)
}

var xxx_messageInfo_EAPOL proto.InternalMessageInfo

func (m *EAPOL) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EAPOL) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EAPOL) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EAPOL) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

// EAPOLKey defines an EAPOL-Key frame for 802.1x authentication
type EAPOLKey struct {
	Timestamp            string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	KeyDescriptorType    int32  `protobuf:"varint,2,opt,name=KeyDescriptorType,proto3" json:"KeyDescriptorType,omitempty"`
	KeyDescriptorVersion int32  `protobuf:"varint,3,opt,name=KeyDescriptorVersion,proto3" json:"KeyDescriptorVersion,omitempty"`
	KeyType              int32  `protobuf:"varint,4,opt,name=KeyType,proto3" json:"KeyType,omitempty"`
	KeyIndex             int32  `protobuf:"varint,5,opt,name=KeyIndex,proto3" json:"KeyIndex,omitempty"`
	Install              bool   `protobuf:"varint,6,opt,name=Install,proto3" json:"Install,omitempty"`
	KeyACK               bool   `protobuf:"varint,7,opt,name=KeyACK,proto3" json:"KeyACK,omitempty"`
	KeyMIC               bool   `protobuf:"varint,8,opt,name=KeyMIC,proto3" json:"KeyMIC,omitempty"`
	Secure               bool   `protobuf:"varint,9,opt,name=Secure,proto3" json:"Secure,omitempty"`
	MICError             bool   `protobuf:"varint,10,opt,name=MICError,proto3" json:"MICError,omitempty"`
	Request              bool   `protobuf:"varint,11,opt,name=Request,proto3" json:"Request,omitempty"`
	HasEncryptedKeyData  bool   `protobuf:"varint,12,opt,name=HasEncryptedKeyData,proto3" json:"HasEncryptedKeyData,omitempty"`
	SMKMessage           bool   `protobuf:"varint,13,opt,name=SMKMessage,proto3" json:"SMKMessage,omitempty"`
	KeyLength            int32  `protobuf:"varint,14,opt,name=KeyLength,proto3" json:"KeyLength,omitempty"`
	ReplayCounter        uint64 `protobuf:"varint,15,opt,name=ReplayCounter,proto3" json:"ReplayCounter,omitempty"`
	Nonce                []byte `protobuf:"bytes,16,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	IV                   []byte `protobuf:"bytes,17,opt,name=IV,proto3" json:"IV,omitempty"`
	RSC                  uint64 `protobuf:"varint,18,opt,name=RSC,proto3" json:"RSC,omitempty"`
	ID                   uint64 `protobuf:"varint,19,opt,name=ID,proto3" json:"ID,omitempty"`
	MIC                  []byte `protobuf:"bytes,20,opt,name=MIC,proto3" json:"MIC,omitempty"`
	KeyDataLength        int32  `protobuf:"varint,21,opt,name=KeyDataLength,proto3" json:"KeyDataLength,omitempty"`
	EncryptedKeyData     []byte `protobuf:"bytes,22,opt,name=EncryptedKeyData,proto3" json:"EncryptedKeyData,omitempty"`
}

func (m *EAPOLKey) Reset()         { *m = EAPOLKey{} }
func (m *EAPOLKey) String() string { return proto.CompactTextString(m) }
func (*EAPOLKey) ProtoMessage()    {}
func (*EAPOLKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{104}
}
func (m *EAPOLKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAPOLKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAPOLKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EAPOLKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAPOLKey.Merge(dst, src)
}
func (m *EAPOLKey) XXX_Size() int {
	return m.Size()
}
func (m *EAPOLKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EAPOLKey.DiscardUnknown(m)
}

var xxx_messageInfo_EAPOLKey proto.InternalMessageInfo

func (m *EAPOLKey) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *EAPOLKey) GetKeyDescriptorType() int32 {
	if m != nil {
		return m.KeyDescriptorType
	}
	return 0
}

func (m *EAPOLKey) GetKeyDescriptorVersion() int32 {
	if m != nil {
		return m.KeyDescriptorVersion
	}
	return 0
}

func (m *EAPOLKey) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

func (m *EAPOLKey) GetKeyIndex() int32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

func (m *EAPOLKey) GetInstall() bool {
	if m != nil {
		return m.Install
	}
	return false
}

func (m *EAPOLKey) GetKeyACK() bool {
	if m != nil {
		return m.KeyACK
	}
	return false
}

func (m *EAPOLKey) GetKeyMIC() bool {
	if m != nil {
		return m.KeyMIC
	}
	return false
}

func (m *EAPOLKey) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

func (m *EAPOLKey) GetMICError() bool {
	if m != nil {
		return m.MICError
	}
	return false
}

func (m *EAPOLKey) GetRequest() bool {
	if m != nil {
		return m.Request
	}
	return false
}

func (m *EAPOLKey) GetHasEncryptedKeyData() bool {
	if m != nil {
		return m.HasEncryptedKeyData
	}
	return false
}

func (m *EAPOLKey) GetSMKMessage() bool {
	if m != nil {
		return m.SMKMessage
	}
	return false
}

func (m *EAPOLKey) GetKeyLength() int32 {
	if m != nil {
		return m.KeyLength
	}
	return 0
}

func (m *EAPOLKey) GetReplayCounter() uint64 {
	if m != nil {
		return m.ReplayCounter
	}
	return 0
}

func (m *EAPOLKey) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EAPOLKey) GetIV() []byte {
	if m != nil {
		return m.IV
	}
	return nil
}

func (m *EAPOLKey) GetRSC() uint64 {
	if m != nil {
		return m.RSC
	}
	return 0
}

func (m *EAPOLKey) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *EAPOLKey) GetMIC() []byte {
	if m != nil {
		return m.MIC
	}
	return nil
}

func (m *EAPOLKey) GetKeyDataLength() int32 {
	if m != nil {
		return m.KeyDataLength
	}
	return 0
}

func (m *EAPOLKey) GetEncryptedKeyData() []byte {
	if m != nil {
		return m.EncryptedKeyData
	}
	return nil
}

type VRRPv2 struct {
	Timestamp    string   `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version      int32    `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type         int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	VirtualRtrID int32    `protobuf:"varint,4,opt,name=VirtualRtrID,proto3" json:"VirtualRtrID,omitempty"`
	Priority     int32    `protobuf:"varint,5,opt,name=Priority,proto3" json:"Priority,omitempty"`
	CountIPAddr  int32    `protobuf:"varint,6,opt,name=CountIPAddr,proto3" json:"CountIPAddr,omitempty"`
	AuthType     int32    `protobuf:"varint,7,opt,name=AuthType,proto3" json:"AuthType,omitempty"`
	AdverInt     int32    `protobuf:"varint,8,opt,name=AdverInt,proto3" json:"AdverInt,omitempty"`
	Checksum     int32    `protobuf:"varint,9,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	IPAddress    []string `protobuf:"bytes,10,rep,name=IPAddress" json:"IPAddress,omitempty"`
}

func (m *VRRPv2) Reset()         { *m = VRRPv2{} }
func (m *VRRPv2) String() string { return proto.CompactTextString(m) }
func (*VRRPv2) ProtoMessage()    {}
func (*VRRPv2) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{105}
}
func (m *VRRPv2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VRRPv2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VRRPv2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VRRPv2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VRRPv2.Merge(dst, src)
}
func (m *VRRPv2) XXX_Size() int {
	return m.Size()
}
func (m *VRRPv2) XXX_DiscardUnknown() {
	xxx_messageInfo_VRRPv2.DiscardUnknown(m)
}

var xxx_messageInfo_VRRPv2 proto.InternalMessageInfo

func (m *VRRPv2) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *VRRPv2) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VRRPv2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *VRRPv2) GetVirtualRtrID() int32 {
	if m != nil {
		return m.VirtualRtrID
	}
	return 0
}

func (m *VRRPv2) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *VRRPv2) GetCountIPAddr() int32 {
	if m != nil {
		return m.CountIPAddr
	}
	return 0
}

func (m *VRRPv2) GetAuthType() int32 {
	if m != nil {
		return m.AuthType
	}
	return 0
}

func (m *VRRPv2) GetAdverInt() int32 {
	if m != nil {
		return m.AdverInt
	}
	return 0
}

func (m *VRRPv2) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *VRRPv2) GetIPAddress() []string {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

type CiscoDiscovery struct {
	Timestamp string                 `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version   int32                  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	TTL       int32                  `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Checksum  int32                  `protobuf:"varint,4,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Values    []*CiscoDiscoveryValue `protobuf:"bytes,5,rep,name=Values" json:"Values,omitempty"`
}

func (m *CiscoDiscovery) Reset()         { *m = CiscoDiscovery{} }
func (m *CiscoDiscovery) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscovery) ProtoMessage()    {}
func (*CiscoDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{106}
}
func (m *CiscoDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CiscoDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscovery.Merge(dst, src)
}
func (m *CiscoDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscovery proto.InternalMessageInfo

func (m *CiscoDiscovery) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *CiscoDiscovery) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CiscoDiscovery) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *CiscoDiscovery) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *CiscoDiscovery) GetValues() []*CiscoDiscoveryValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type CiscoDiscoveryValue struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *CiscoDiscoveryValue) Reset()         { *m = CiscoDiscoveryValue{} }
func (m *CiscoDiscoveryValue) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscoveryValue) ProtoMessage()    {}
func (*CiscoDiscoveryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{107}
}
func (m *CiscoDiscoveryValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscoveryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscoveryValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CiscoDiscoveryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscoveryValue.Merge(dst, src)
}
func (m *CiscoDiscoveryValue) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscoveryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscoveryValue.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscoveryValue proto.InternalMessageInfo

func (m *CiscoDiscoveryValue) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CiscoDiscoveryValue) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *CiscoDiscoveryValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CDPVLANDialogue struct {
	ID   int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	VLAN int32 `protobuf:"varint,2,opt,name=VLAN,proto3" json:"VLAN,omitempty"`
}

func (m *CDPVLANDialogue) Reset()         { *m = CDPVLANDialogue{} }
func (m *CDPVLANDialogue) String() string { return proto.CompactTextString(m) }
func (*CDPVLANDialogue) ProtoMessage()    {}
func (*CDPVLANDialogue) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{108}
}
func (m *CDPVLANDialogue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPVLANDialogue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPVLANDialogue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPVLANDialogue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPVLANDialogue.Merge(dst, src)
}
func (m *CDPVLANDialogue) XXX_Size() int {
	return m.Size()
}
func (m *CDPVLANDialogue) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPVLANDialogue.DiscardUnknown(m)
}

var xxx_messageInfo_CDPVLANDialogue proto.InternalMessageInfo

func (m *CDPVLANDialogue) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CDPVLANDialogue) GetVLAN() int32 {
	if m != nil {
		return m.VLAN
	}
	return 0
}

type CDPLocation struct {
	Type     int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Location string `protobuf:"bytes,2,opt,name=Location,proto3" json:"Location,omitempty"`
}

func (m *CDPLocation) Reset()         { *m = CDPLocation{} }
func (m *CDPLocation) String() string { return proto.CompactTextString(m) }
func (*CDPLocation) ProtoMessage()    {}
func (*CDPLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{109}
}
func (m *CDPLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPLocation.Merge(dst, src)
}
func (m *CDPLocation) XXX_Size() int {
	return m.Size()
}
func (m *CDPLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CDPLocation proto.InternalMessageInfo

func (m *CDPLocation) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CDPLocation) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

type CDPPowerDialogue struct {
	ID     int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	MgmtID int32    `protobuf:"varint,2,opt,name=MgmtID,proto3" json:"MgmtID,omitempty"`
	Values []uint32 `protobuf:"varint,3,rep,packed,name=Values" json:"Values,omitempty"`
}

func (m *CDPPowerDialogue) Reset()         { *m = CDPPowerDialogue{} }
func (m *CDPPowerDialogue) String() string { return proto.CompactTextString(m) }
func (*CDPPowerDialogue) ProtoMessage()    {}
func (*CDPPowerDialogue) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{110}
}
func (m *CDPPowerDialogue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPPowerDialogue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPPowerDialogue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPPowerDialogue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPPowerDialogue.Merge(dst, src)
}
func (m *CDPPowerDialogue) XXX_Size() int {
	return m.Size()
}
func (m *CDPPowerDialogue) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPPowerDialogue.DiscardUnknown(m)
}

var xxx_messageInfo_CDPPowerDialogue proto.InternalMessageInfo

func (m *CDPPowerDialogue) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CDPPowerDialogue) GetMgmtID() int32 {
	if m != nil {
		return m.MgmtID
	}
	return 0
}

func (m *CDPPowerDialogue) GetValues() []uint32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type CDPSparePairPoE struct {
	PSEFourWire  bool `protobuf:"varint,1,opt,name=PSEFourWire,proto3" json:"PSEFourWire,omitempty"`
	PDArchShared bool `protobuf:"varint,2,opt,name=PDArchShared,proto3" json:"PDArchShared,omitempty"`
	PDRequestOn  bool `protobuf:"varint,3,opt,name=PDRequestOn,proto3" json:"PDRequestOn,omitempty"`
	PSEOn        bool `protobuf:"varint,4,opt,name=PSEOn,proto3" json:"PSEOn,omitempty"`
}

func (m *CDPSparePairPoE) Reset()         { *m = CDPSparePairPoE{} }
func (m *CDPSparePairPoE) String() string { return proto.CompactTextString(m) }
func (*CDPSparePairPoE) ProtoMessage()    {}
func (*CDPSparePairPoE) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{111}
}
func (m *CDPSparePairPoE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPSparePairPoE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPSparePairPoE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPSparePairPoE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPSparePairPoE.Merge(dst, src)
}
func (m *CDPSparePairPoE) XXX_Size() int {
	return m.Size()
}
func (m *CDPSparePairPoE) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPSparePairPoE.DiscardUnknown(m)
}

var xxx_messageInfo_CDPSparePairPoE proto.InternalMessageInfo

func (m *CDPSparePairPoE) GetPSEFourWire() bool {
	if m != nil {
		return m.PSEFourWire
	}
	return false
}

func (m *CDPSparePairPoE) GetPDArchShared() bool {
	if m != nil {
		return m.PDArchShared
	}
	return false
}

func (m *CDPSparePairPoE) GetPDRequestOn() bool {
	if m != nil {
		return m.PDRequestOn
	}
	return false
}

func (m *CDPSparePairPoE) GetPSEOn() bool {
	if m != nil {
		return m.PSEOn
	}
	return false
}

type CiscoDiscoveryInfo struct {
	Timestamp        string                 `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	CDPHello         *CDPHello              `protobuf:"bytes,2,opt,name=CDPHello" json:"CDPHello,omitempty"`
	DeviceID         string                 `protobuf:"bytes,3,opt,name=DeviceID,proto3" json:"DeviceID,omitempty"`
	Addresses        []string               `protobuf:"bytes,4,rep,name=Addresses" json:"Addresses,omitempty"`
	PortID           string                 `protobuf:"bytes,5,opt,name=PortID,proto3" json:"PortID,omitempty"`
	Capabilities     *CDPCapabilities       `protobuf:"bytes,6,opt,name=Capabilities" json:"Capabilities,omitempty"`
	Version          string                 `protobuf:"bytes,7,opt,name=Version,proto3" json:"Version,omitempty"`
	Platform         string                 `protobuf:"bytes,8,opt,name=Platform,proto3" json:"Platform,omitempty"`
	IPPrefixes       []*IPNet               `protobuf:"bytes,9,rep,name=IPPrefixes" json:"IPPrefixes,omitempty"`
	VTPDomain        string                 `protobuf:"bytes,10,opt,name=VTPDomain,proto3" json:"VTPDomain,omitempty"`
	NativeVLAN       int32                  `protobuf:"varint,11,opt,name=NativeVLAN,proto3" json:"NativeVLAN,omitempty"`
	FullDuplex       bool                   `protobuf:"varint,12,opt,name=FullDuplex,proto3" json:"FullDuplex,omitempty"`
	VLANReply        *CDPVLANDialogue       `protobuf:"bytes,13,opt,name=VLANReply" json:"VLANReply,omitempty"`
	VLANQuery        *CDPVLANDialogue       `protobuf:"bytes,14,opt,name=VLANQuery" json:"VLANQuery,omitempty"`
	PowerConsumption int32                  `protobuf:"varint,15,opt,name=PowerConsumption,proto3" json:"PowerConsumption,omitempty"`
	MTU              uint32                 `protobuf:"varint,16,opt,name=MTU,proto3" json:"MTU,omitempty"`
	ExtendedTrust    int32                  `protobuf:"varint,17,opt,name=ExtendedTrust,proto3" json:"ExtendedTrust,omitempty"`
	UntrustedCOS     int32                  `protobuf:"varint,18,opt,name=UntrustedCOS,proto3" json:"UntrustedCOS,omitempty"`
	SysName          string                 `protobuf:"bytes,19,opt,name=SysName,proto3" json:"SysName,omitempty"`
	SysOID           string                 `protobuf:"bytes,20,opt,name=SysOID,proto3" json:"SysOID,omitempty"`
	MgmtAddresses    []string               `protobuf:"bytes,21,rep,name=MgmtAddresses" json:"MgmtAddresses,omitempty"`
	Location         *CDPLocation           `protobuf:"bytes,22,opt,name=Location" json:"Location,omitempty"`
	PowerRequest     *CDPPowerDialogue      `protobuf:"bytes,23,opt,name=PowerRequest" json:"PowerRequest,omitempty"`
	PowerAvailable   *CDPPowerDialogue      `protobuf:"bytes,24,opt,name=PowerAvailable" json:"PowerAvailable,omitempty"`
	SparePairPoe     *CDPSparePairPoE       `protobuf:"bytes,25,opt,name=SparePairPoe" json:"SparePairPoe,omitempty"`
	EnergyWise       *CDPEnergyWise         `protobuf:"bytes,26,opt,name=EnergyWise" json:"EnergyWise,omitempty"`
	Unknown          []*CiscoDiscoveryValue `protobuf:"bytes,27,rep,name=Unknown" json:"Unknown,omitempty"`
}

func (m *CiscoDiscoveryInfo) Reset()         { *m = CiscoDiscoveryInfo{} }
func (m *CiscoDiscoveryInfo) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscoveryInfo) ProtoMessage()    {}
func (*CiscoDiscoveryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{112}
}
func (m *CiscoDiscoveryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscoveryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CiscoDiscoveryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscoveryInfo.Merge(dst, src)
}
func (m *CiscoDiscoveryInfo) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscoveryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscoveryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscoveryInfo proto.InternalMessageInfo

func (m *CiscoDiscoveryInfo) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetCDPHello() *CDPHello {
	if m != nil {
		return m.CDPHello
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetDeviceID() string {
	if m != nil {
		return m.DeviceID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPortID() string {
	if m != nil {
		return m.PortID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetCapabilities() *CDPCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetIPPrefixes() []*IPNet {
	if m != nil {
		return m.IPPrefixes
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVTPDomain() string {
	if m != nil {
		return m.VTPDomain
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetNativeVLAN() int32 {
	if m != nil {
		return m.NativeVLAN
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetFullDuplex() bool {
	if m != nil {
		return m.FullDuplex
	}
	return false
}

func (m *CiscoDiscoveryInfo) GetVLANReply() *CDPVLANDialogue {
	if m != nil {
		return m.VLANReply
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVLANQuery() *CDPVLANDialogue {
	if m != nil {
		return m.VLANQuery
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerConsumption() int32 {
	if m != nil {
		return m.PowerConsumption
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetMTU() uint32 {
	if m != nil {
		return m.MTU
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetExtendedTrust() int32 {
	if m != nil {
		return m.ExtendedTrust
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetUntrustedCOS() int32 {
	if m != nil {
		return m.UntrustedCOS
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetSysOID() string {
	if m != nil {
		return m.SysOID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetMgmtAddresses() []string {
	if m != nil {
		return m.MgmtAddresses
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetLocation() *CDPLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerRequest() *CDPPowerDialogue {
	if m != nil {
		return m.PowerRequest
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerAvailable() *CDPPowerDialogue {
	if m != nil {
		return m.PowerAvailable
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetSparePairPoe() *CDPSparePairPoE {
	if m != nil {
		return m.SparePairPoe
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetEnergyWise() *CDPEnergyWise {
	if m != nil {
		return m.EnergyWise
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetUnknown() []*CiscoDiscoveryValue {
	if m != nil {
		return m.Unknown
	}
	return nil
}

type CDPHello struct {
	OUI              []byte `protobuf:"bytes,1,opt,name=OUI,proto3" json:"OUI,omitempty"`
	ProtocolID       int32  `protobuf:"varint,2,opt,name=ProtocolID,proto3" json:"ProtocolID,omitempty"`
	ClusterMaster    string `protobuf:"bytes,3,opt,name=ClusterMaster,proto3" json:"ClusterMaster,omitempty"`
	Unknown1         string `protobuf:"bytes,4,opt,name=Unknown1,proto3" json:"Unknown1,omitempty"`
	Version          int32  `protobuf:"varint,5,opt,name=Version,proto3" json:"Version,omitempty"`
	SubVersion       int32  `protobuf:"varint,6,opt,name=SubVersion,proto3" json:"SubVersion,omitempty"`
	Status           int32  `protobuf:"varint,7,opt,name=Status,proto3" json:"Status,omitempty"`
	Unknown2         int32  `protobuf:"varint,8,opt,name=Unknown2,proto3" json:"Unknown2,omitempty"`
	ClusterCommander string `protobuf:"bytes,9,opt,name=ClusterCommander,proto3" json:"ClusterCommander,omitempty"`
	SwitchMAC        string `protobuf:"bytes,10,opt,name=SwitchMAC,proto3" json:"SwitchMAC,omitempty"`
	Unknown3         int32  `protobuf:"varint,11,opt,name=Unknown3,proto3" json:"Unknown3,omitempty"`
	ManagementVLAN   int32  `protobuf:"varint,12,opt,name=ManagementVLAN,proto3" json:"ManagementVLAN,omitempty"`
}

func (m *CDPHello) Reset()         { *m = CDPHello{} }
func (m *CDPHello) String() string { return proto.CompactTextString(m) }
func (*CDPHello) ProtoMessage()    {}
func (*CDPHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{113}
}
func (m *CDPHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPHello.Merge(dst, src)
}
func (m *CDPHello) XXX_Size() int {
	return m.Size()
}
func (m *CDPHello) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPHello.DiscardUnknown(m)
}

var xxx_messageInfo_CDPHello proto.InternalMessageInfo

func (m *CDPHello) GetOUI() []byte {
	if m != nil {
		return m.OUI
	}
	return nil
}

func (m *CDPHello) GetProtocolID() int32 {
	if m != nil {
		return m.ProtocolID
	}
	return 0
}

func (m *CDPHello) GetClusterMaster() string {
	if m != nil {
		return m.ClusterMaster
	}
	return ""
}

func (m *CDPHello) GetUnknown1() string {
	if m != nil {
		return m.Unknown1
	}
	return ""
}

func (m *CDPHello) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CDPHello) GetSubVersion() int32 {
	if m != nil {
		return m.SubVersion
	}
	return 0
}

func (m *CDPHello) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CDPHello) GetUnknown2() int32 {
	if m != nil {
		return m.Unknown2
	}
	return 0
}

func (m *CDPHello) GetClusterCommander() string {
	if m != nil {
		return m.ClusterCommander
	}
	return ""
}

func (m *CDPHello) GetSwitchMAC() string {
	if m != nil {
		return m.SwitchMAC
	}
	return ""
}

func (m *CDPHello) GetUnknown3() int32 {
	if m != nil {
		return m.Unknown3
	}
	return 0
}

func (m *CDPHello) GetManagementVLAN() int32 {
	if m != nil {
		return m.ManagementVLAN
	}
	return 0
}

type CDPEnergyWise struct {
	EncryptedData  []byte `protobuf:"bytes,1,opt,name=EncryptedData,proto3" json:"EncryptedData,omitempty"`
	Unknown1       uint32 `protobuf:"varint,2,opt,name=Unknown1,proto3" json:"Unknown1,omitempty"`
	SequenceNumber uint32 `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	ModelNumber    string `protobuf:"bytes,4,opt,name=ModelNumber,proto3" json:"ModelNumber,omitempty"`
	Unknown2       int32  `protobuf:"varint,5,opt,name=Unknown2,proto3" json:"Unknown2,omitempty"`
	HardwareID     string `protobuf:"bytes,6,opt,name=HardwareID,proto3" json:"HardwareID,omitempty"`
	SerialNum      string `protobuf:"bytes,7,opt,name=SerialNum,proto3" json:"SerialNum,omitempty"`
	Unknown3       []byte `protobuf:"bytes,8,opt,name=Unknown3,proto3" json:"Unknown3,omitempty"`
	Role           string `protobuf:"bytes,9,opt,name=Role,proto3" json:"Role,omitempty"`
	Domain         string `protobuf:"bytes,10,opt,name=Domain,proto3" json:"Domain,omitempty"`
	Name           string `protobuf:"bytes,11,opt,name=Name,proto3" json:"Name,omitempty"`
	ReplyUnknown1  []byte `protobuf:"bytes,12,opt,name=ReplyUnknown1,proto3" json:"ReplyUnknown1,omitempty"`
	ReplyPort      []byte `protobuf:"bytes,13,opt,name=ReplyPort,proto3" json:"ReplyPort,omitempty"`
	ReplyAddress   []byte `protobuf:"bytes,14,opt,name=ReplyAddress,proto3" json:"ReplyAddress,omitempty"`
	ReplyUnknown2  []byte `protobuf:"bytes,15,opt,name=ReplyUnknown2,proto3" json:"ReplyUnknown2,omitempty"`
	ReplyUnknown3  []byte `protobuf:"bytes,16,opt,name=ReplyUnknown3,proto3" json:"ReplyUnknown3,omitempty"`
}

func (m *CDPEnergyWise) Reset()         { *m = CDPEnergyWise{} }
func (m *CDPEnergyWise) String() string { return proto.CompactTextString(m) }
func (*CDPEnergyWise) ProtoMessage()    {}
func (*CDPEnergyWise) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{114}
}
func (m *CDPEnergyWise) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPEnergyWise) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPEnergyWise.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPEnergyWise) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPEnergyWise.Merge(dst, src)
}
func (m *CDPEnergyWise) XXX_Size() int {
	return m.Size()
}
func (m *CDPEnergyWise) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPEnergyWise.DiscardUnknown(m)
}

var xxx_messageInfo_CDPEnergyWise proto.InternalMessageInfo

func (m *CDPEnergyWise) GetEncryptedData() []byte {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

func (m *CDPEnergyWise) GetUnknown1() uint32 {
	if m != nil {
		return m.Unknown1
	}
	return 0
}

func (m *CDPEnergyWise) GetSequenceNumber() uint32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *CDPEnergyWise) GetModelNumber() string {
	if m != nil {
		return m.ModelNumber
	}
	return ""
}

func (m *CDPEnergyWise) GetUnknown2() int32 {
	if m != nil {
		return m.Unknown2
	}
	return 0
}

func (m *CDPEnergyWise) GetHardwareID() string {
	if m != nil {
		return m.HardwareID
	}
	return ""
}

func (m *CDPEnergyWise) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *CDPEnergyWise) GetUnknown3() []byte {
	if m != nil {
		return m.Unknown3
	}
	return nil
}

func (m *CDPEnergyWise) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *CDPEnergyWise) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *CDPEnergyWise) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CDPEnergyWise) GetReplyUnknown1() []byte {
	if m != nil {
		return m.ReplyUnknown1
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyPort() []byte {
	if m != nil {
		return m.ReplyPort
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyAddress() []byte {
	if m != nil {
		return m.ReplyAddress
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyUnknown2() []byte {
	if m != nil {
		return m.ReplyUnknown2
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyUnknown3() []byte {
	if m != nil {
		return m.ReplyUnknown3
	}
	return nil
}

type CDPCapabilities struct {
	L3Router        bool `protobuf:"varint,1,opt,name=L3Router,proto3" json:"L3Router,omitempty"`
	TBBridge        bool `protobuf:"varint,2,opt,name=TBBridge,proto3" json:"TBBridge,omitempty"`
	SPBridge        bool `protobuf:"varint,3,opt,name=SPBridge,proto3" json:"SPBridge,omitempty"`
	L2Switch        bool `protobuf:"varint,4,opt,name=L2Switch,proto3" json:"L2Switch,omitempty"`
	IsHost          bool `protobuf:"varint,5,opt,name=IsHost,proto3" json:"IsHost,omitempty"`
	IGMPFilter      bool `protobuf:"varint,6,opt,name=IGMPFilter,proto3" json:"IGMPFilter,omitempty"`
	L1Repeater      bool `protobuf:"varint,7,opt,name=L1Repeater,proto3" json:"L1Repeater,omitempty"`
	IsPhone         bool `protobuf:"varint,8,opt,name=IsPhone,proto3" json:"IsPhone,omitempty"`
	RemotelyManaged bool `protobuf:"varint,9,opt,name=RemotelyManaged,proto3" json:"RemotelyManaged,omitempty"`
}

func (m *CDPCapabilities) Reset()         { *m = CDPCapabilities{} }
func (m *CDPCapabilities) String() string { return proto.CompactTextString(m) }
func (*CDPCapabilities) ProtoMessage()    {}
func (*CDPCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{115}
}
func (m *CDPCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CDPCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPCapabilities.Merge(dst, src)
}
func (m *CDPCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *CDPCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_CDPCapabilities proto.InternalMessageInfo

func (m *CDPCapabilities) GetL3Router() bool {
	if m != nil {
		return m.L3Router
	}
	return false
}

func (m *CDPCapabilities) GetTBBridge() bool {
	if m != nil {
		return m.TBBridge
	}
	return false
}

func (m *CDPCapabilities) GetSPBridge() bool {
	if m != nil {
		return m.SPBridge
	}
	return false
}

func (m *CDPCapabilities) GetL2Switch() bool {
	if m != nil {
		return m.L2Switch
	}
	return false
}

func (m *CDPCapabilities) GetIsHost() bool {
	if m != nil {
		return m.IsHost
	}
	return false
}

func (m *CDPCapabilities) GetIGMPFilter() bool {
	if m != nil {
		return m.IGMPFilter
	}
	return false
}

func (m *CDPCapabilities) GetL1Repeater() bool {
	if m != nil {
		return m.L1Repeater
	}
	return false
}

func (m *CDPCapabilities) GetIsPhone() bool {
	if m != nil {
		return m.IsPhone
	}
	return false
}

func (m *CDPCapabilities) GetRemotelyManaged() bool {
	if m != nil {
		return m.RemotelyManaged
	}
	return false
}

type IPNet struct {
	IP     string `protobuf:"bytes,1,opt,name=IP,proto3" json:"IP,omitempty"`
	IPMask string `protobuf:"bytes,2,opt,name=IPMask,proto3" json:"IPMask,omitempty"`
}

func (m *IPNet) Reset()         { *m = IPNet{} }
func (m *IPNet) String() string { return proto.CompactTextString(m) }
func (*IPNet) ProtoMessage()    {}
func (*IPNet) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{116}
}
func (m *IPNet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPNet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPNet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IPNet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPNet.Merge(dst, src)
}
func (m *IPNet) XXX_Size() int {
	return m.Size()
}
func (m *IPNet) XXX_DiscardUnknown() {
	xxx_messageInfo_IPNet.DiscardUnknown(m)
}

var xxx_messageInfo_IPNet proto.InternalMessageInfo

func (m *IPNet) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *IPNet) GetIPMask() string {
	if m != nil {
		return m.IPMask
	}
	return ""
}

type NortelDiscovery struct {
	Timestamp string `protobuf:"bytes,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	IPAddress string `protobuf:"bytes,2,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	SegmentID []byte `protobuf:"bytes,3,opt,name=SegmentID,proto3" json:"SegmentID,omitempty"`
	Chassis   int32  `protobuf:"varint,4,opt,name=Chassis,proto3" json:"Chassis,omitempty"`
	Backplane int32  `protobuf:"varint,5,opt,name=Backplane,proto3" json:"Backplane,omitempty"`
	State     int32  `protobuf:"varint,6,opt,name=State,proto3" json:"State,omitempty"`
	NumLinks  int32  `protobuf:"varint,7,opt,name=NumLinks,proto3" json:"NumLinks,omitempty"`
}

func (m *NortelDiscovery) Reset()         { *m = NortelDiscovery{} }
func (m *NortelDiscovery) String() string { return proto.CompactTextString(m) }
func (*NortelDiscovery) ProtoMessage()    {}
func (*NortelDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_netcap_96fb18cb63d9eadb, []int{117}
}
func (m *NortelDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NortelDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NortelDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NortelDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NortelDiscovery.Merge(dst, src)
}
func (m *NortelDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *NortelDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_NortelDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_NortelDiscovery proto.InternalMessageInfo

func (m *NortelDiscovery) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *NortelDiscovery) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *NortelDiscovery) GetSegmentID() []byte {
	if m != nil {
		return m.SegmentID
	}
	return nil
}

func (m *NortelDiscovery) GetChassis() int32 {
	if m != nil {
		return m.Chassis
	}
	return 0
}

func (m *NortelDiscovery) GetBackplane() int32 {
	if m != nil {
		return m.Backplane
	}
	return 0
}

func (m *NortelDiscovery) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *NortelDiscovery) GetNumLinks() int32 {
	if m != nil {
		return m.NumLinks
	}
	return 0
}

func init() {
	proto.RegisterType((*Header)(nil), "types.Header")
	proto.RegisterType((*Batch)(nil), "types.Batch")
	proto.RegisterType((*Flow)(nil), "types.Flow")
	proto.RegisterType((*Connection)(nil), "types.Connection")
	proto.RegisterType((*LinkFlow)(nil), "types.LinkFlow")
	proto.RegisterType((*NetworkFlow)(nil), "types.NetworkFlow")
	proto.RegisterType((*TransportFlow)(nil), "types.TransportFlow")
	proto.RegisterType((*Ethernet)(nil), "types.Ethernet")
	proto.RegisterType((*ARP)(nil), "types.ARP")
	proto.RegisterType((*Dot1Q)(nil), "types.Dot1Q")
	proto.RegisterType((*Dot11)(nil), "types.Dot11")
	proto.RegisterType((*Dot11QOS)(nil), "types.Dot11QOS")
	proto.RegisterType((*Dot11HTControl)(nil), "types.Dot11HTControl")
	proto.RegisterType((*Dot11HTControlVHT)(nil), "types.Dot11HTControlVHT")
	proto.RegisterType((*Dot11HTControlHT)(nil), "types.Dot11HTControlHT")
	proto.RegisterType((*Dot11HTControlMFB)(nil), "types.Dot11HTControlMFB")
	proto.RegisterType((*Dot11LinkAdapationControl)(nil), "types.Dot11LinkAdapationControl")
	proto.RegisterType((*Dot11ASEL)(nil), "types.Dot11ASEL")
	proto.RegisterType((*LinkLayerDiscovery)(nil), "types.LinkLayerDiscovery")
	proto.RegisterType((*LLDPChassisID)(nil), "types.LLDPChassisID")
	proto.RegisterType((*LLDPPortID)(nil), "types.LLDPPortID")
	proto.RegisterType((*LinkLayerDiscoveryValue)(nil), "types.LinkLayerDiscoveryValue")
	proto.RegisterType((*EthernetCTP)(nil), "types.EthernetCTP")
	proto.RegisterType((*EthernetCTPReply)(nil), "types.EthernetCTPReply")
	proto.RegisterType((*LinkLayerDiscoveryInfo)(nil), "types.LinkLayerDiscoveryInfo")
	proto.RegisterType((*LLDPSysCapabilities)(nil), "types.LLDPSysCapabilities")
	proto.RegisterType((*LLDPCapabilities)(nil), "types.LLDPCapabilities")
	proto.RegisterType((*LLDPMgmtAddress)(nil), "types.LLDPMgmtAddress")
	proto.RegisterType((*LLDPOrgSpecificTLV)(nil), "types.LLDPOrgSpecificTLV")
	proto.RegisterType((*IPv4)(nil), "types.IPv4")
	proto.RegisterType((*IPv4Option)(nil), "types.IPv4Option")
	proto.RegisterType((*IPv6)(nil), "types.IPv6")
	proto.RegisterType((*IPv6Fragment)(nil), "types.IPv6Fragment")
	proto.RegisterType((*ICMPv4)(nil), "types.ICMPv4")
	proto.RegisterType((*ICMPv6)(nil), "types.ICMPv6")
	proto.RegisterType((*ICMPv6NeighborAdvertisement)(nil), "types.ICMPv6NeighborAdvertisement")
	proto.RegisterType((*ICMPv6RouterAdvertisement)(nil), "types.ICMPv6RouterAdvertisement")
	proto.RegisterType((*ICMPv6Option)(nil), "types.ICMPv6Option")
	proto.RegisterType((*UDP)(nil), "types.UDP")
	proto.RegisterType((*TCP)(nil), "types.TCP")
	proto.RegisterType((*TCPOption)(nil), "types.TCPOption")
	proto.RegisterType((*SCTP)(nil), "types.SCTP")
	proto.RegisterType((*DNS)(nil), "types.DNS")
	proto.RegisterType((*DNSResourceRecord)(nil), "types.DNSResourceRecord")
	proto.RegisterType((*DNSSOA)(nil), "types.DNSSOA")
	proto.RegisterType((*DNSSRV)(nil), "types.DNSSRV")
	proto.RegisterType((*DNSMX)(nil), "types.DNSMX")
	proto.RegisterType((*DNSQuestion)(nil), "types.DNSQuestion")
	proto.RegisterType((*DHCPv4)(nil), "types.DHCPv4")
	proto.RegisterType((*DHCPOption)(nil), "types.DHCPOption")
	proto.RegisterType((*DHCPv6)(nil), "types.DHCPv6")
	proto.RegisterType((*DHCPv6Option)(nil), "types.DHCPv6Option")
	proto.RegisterType((*LLC)(nil), "types.LLC")
	proto.RegisterType((*NTP)(nil), "types.NTP")
	proto.RegisterType((*SIP)(nil), "types.SIP")
	proto.RegisterType((*IGMP)(nil), "types.IGMP")
	proto.RegisterType((*IGMPv3GroupRecord)(nil), "types.IGMPv3GroupRecord")
	proto.RegisterType((*IPv6HopByHop)(nil), "types.IPv6HopByHop")
	proto.RegisterType((*IPv6HopByHopOption)(nil), "types.IPv6HopByHopOption")
	proto.RegisterType((*IPv6HopByHopOptionAlignment)(nil), "types.IPv6HopByHopOptionAlignment")
	proto.RegisterType((*SNAP)(nil), "types.SNAP")
	proto.RegisterType((*ICMPv6Echo)(nil), "types.ICMPv6Echo")
	proto.RegisterType((*ICMPv6NeighborSolicitation)(nil), "types.ICMPv6NeighborSolicitation")
	proto.RegisterType((*ICMPv6RouterSolicitation)(nil), "types.ICMPv6RouterSolicitation")
	proto.RegisterType((*HTTP)(nil), "types.HTTP")
	proto.RegisterType((*TLSClientHello)(nil), "types.TLSClientHello")
	proto.RegisterType((*IPSecAH)(nil), "types.IPSecAH")
	proto.RegisterType((*IPSecESP)(nil), "types.IPSecESP")
	proto.RegisterType((*Geneve)(nil), "types.Geneve")
	proto.RegisterType((*GeneveOption)(nil), "types.GeneveOption")
	proto.RegisterType((*VXLAN)(nil), "types.VXLAN")
	proto.RegisterType((*USB)(nil), "types.USB")
	proto.RegisterType((*USBRequestBlockSetup)(nil), "types.USBRequestBlockSetup")
	proto.RegisterType((*LCM)(nil), "types.LCM")
	proto.RegisterType((*MPLS)(nil), "types.MPLS")
	proto.RegisterType((*ModbusTCP)(nil), "types.ModbusTCP")
	proto.RegisterType((*OSPFv2)(nil), "types.OSPFv2")
	proto.RegisterType((*HelloPkg)(nil), "types.HelloPkg")
	proto.RegisterType((*HelloPkgV2)(nil), "types.HelloPkgV2")
	proto.RegisterType((*DbDescPkg)(nil), "types.DbDescPkg")
	proto.RegisterType((*OSPFv3)(nil), "types.OSPFv3")
	proto.RegisterType((*LSAheader)(nil), "types.LSAheader")
	proto.RegisterType((*LSA)(nil), "types.LSA")
	proto.RegisterType((*LSReq)(nil), "types.LSReq")
	proto.RegisterType((*LSUpdate)(nil), "types.LSUpdate")
	proto.RegisterType((*IntraAreaPrefixLSA)(nil), "types.IntraAreaPrefixLSA")
	proto.RegisterType((*ASExternalLSA)(nil), "types.ASExternalLSA")
	proto.RegisterType((*InterAreaPrefixLSA)(nil), "types.InterAreaPrefixLSA")
	proto.RegisterType((*InterAreaRouterLSA)(nil), "types.InterAreaRouterLSA")
	proto.RegisterType((*ASExternalLSAV2)(nil), "types.ASExternalLSAV2")
	proto.RegisterType((*RouterLSA)(nil), "types.RouterLSA")
	proto.RegisterType((*Router)(nil), "types.Router")
	proto.RegisterType((*RouterLSAV2)(nil), "types.RouterLSAV2")
	proto.RegisterType((*RouterV2)(nil), "types.RouterV2")
	proto.RegisterType((*NetworkLSA)(nil), "types.NetworkLSA")
	proto.RegisterType((*LinkLSA)(nil), "types.LinkLSA")
	proto.RegisterType((*LSAPrefix)(nil), "types.LSAPrefix")
	proto.RegisterType((*BFD)(nil), "types.BFD")
	proto.RegisterType((*BFDAuthHeader)(nil), "types.BFDAuthHeader")
	proto.RegisterType((*GRE)(nil), "types.GRE")
	proto.RegisterType((*GRERouting)(nil), "types.GRERouting")
	proto.RegisterType((*FDDI)(nil), "types.FDDI")
	proto.RegisterType((*EAP)(nil), "types.EAP")
	proto.RegisterType((*EAPOL)(nil), "types.EAPOL")
	proto.RegisterType((*EAPOLKey)(nil), "types.EAPOLKey")
	proto.RegisterType((*VRRPv2)(nil), "types.VRRPv2")
	proto.RegisterType((*CiscoDiscovery)(nil), "types.CiscoDiscovery")
	proto.RegisterType((*CiscoDiscoveryValue)(nil), "types.CiscoDiscoveryValue")
	proto.RegisterType((*CDPVLANDialogue)(nil), "types.CDPVLANDialogue")
	proto.RegisterType((*CDPLocation)(nil), "types.CDPLocation")
	proto.RegisterType((*CDPPowerDialogue)(nil), "types.CDPPowerDialogue")
	proto.RegisterType((*CDPSparePairPoE)(nil), "types.CDPSparePairPoE")
	proto.RegisterType((*CiscoDiscoveryInfo)(nil), "types.CiscoDiscoveryInfo")
	proto.RegisterType((*CDPHello)(nil), "types.CDPHello")
	proto.RegisterType((*CDPEnergyWise)(nil), "types.CDPEnergyWise")
	proto.RegisterType((*CDPCapabilities)(nil), "types.CDPCapabilities")
	proto.RegisterType((*IPNet)(nil), "types.IPNet")
	proto.RegisterType((*NortelDiscovery)(nil), "types.NortelDiscovery")
	proto.RegisterEnum("types.Type", Type_name, Type_value)
}
func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Created) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.InputSource) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.InputSource)))
		i += copy(dAtA[i:], m.InputSource)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ContainsPayloads {
		dAtA[i] = 0x28
		i++
		if m.ContainsPayloads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MessageType))
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.ContainsPayloads {
		dAtA[i] = 0x28
		i++
		if m.ContainsPayloads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimestampFirst) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampFirst)))
		i += copy(dAtA[i:], m.TimestampFirst)
	}
	if len(m.LinkProto) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkProto)))
		i += copy(dAtA[i:], m.LinkProto)
	}
	if len(m.NetworkProto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NetworkProto)))
		i += copy(dAtA[i:], m.NetworkProto)
	}
	if len(m.TransportProto) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TransportProto)))
		i += copy(dAtA[i:], m.TransportProto)
	}
	if len(m.ApplicationProto) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ApplicationProto)))
		i += copy(dAtA[i:], m.ApplicationProto)
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.SrcPort) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcPort)))
		i += copy(dAtA[i:], m.SrcPort)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if len(m.DstPort) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstPort)))
		i += copy(dAtA[i:], m.DstPort)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if m.AppPayloadSize != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AppPayloadSize))
	}
	if m.NumPackets != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
	}
	if len(m.UID) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if len(m.TimestampLast) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampLast)))
		i += copy(dAtA[i:], m.TimestampLast)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimestampFirst) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampFirst)))
		i += copy(dAtA[i:], m.TimestampFirst)
	}
	if len(m.LinkProto) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkProto)))
		i += copy(dAtA[i:], m.LinkProto)
	}
	if len(m.NetworkProto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NetworkProto)))
		i += copy(dAtA[i:], m.NetworkProto)
	}
	if len(m.TransportProto) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TransportProto)))
		i += copy(dAtA[i:], m.TransportProto)
	}
	if len(m.ApplicationProto) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ApplicationProto)))
		i += copy(dAtA[i:], m.ApplicationProto)
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.SrcPort) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcPort)))
		i += copy(dAtA[i:], m.SrcPort)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if len(m.DstPort) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstPort)))
		i += copy(dAtA[i:], m.DstPort)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if m.AppPayloadSize != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AppPayloadSize))
	}
	if m.NumPackets != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
	}
	if len(m.UID) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if len(m.TimestampLast) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampLast)))
		i += copy(dAtA[i:], m.TimestampLast)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *LinkFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimestampFirst) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampFirst)))
		i += copy(dAtA[i:], m.TimestampFirst)
	}
	if len(m.TimestampLast) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampLast)))
		i += copy(dAtA[i:], m.TimestampLast)
	}
	if len(m.Proto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Proto)))
		i += copy(dAtA[i:], m.Proto)
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
	}
	if m.UID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UID))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *NetworkFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimestampFirst) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampFirst)))
		i += copy(dAtA[i:], m.TimestampFirst)
	}
	if len(m.TimestampLast) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampLast)))
		i += copy(dAtA[i:], m.TimestampLast)
	}
	if len(m.Proto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Proto)))
		i += copy(dAtA[i:], m.Proto)
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
	}
	if m.UID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UID))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *TransportFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransportFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimestampFirst) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampFirst)))
		i += copy(dAtA[i:], m.TimestampFirst)
	}
	if len(m.TimestampLast) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TimestampLast)))
		i += copy(dAtA[i:], m.TimestampLast)
	}
	if len(m.Proto) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Proto)))
		i += copy(dAtA[i:], m.Proto)
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
	}
	if m.UID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UID))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *Ethernet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ethernet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	if m.EthernetType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.EthernetType))
	}
	if m.PayloadEntropy != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i += 8
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	return i, nil
}

func (m *ARP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ARP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.AddrType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AddrType))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
	}
	if m.HwAddressSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HwAddressSize))
	}
	if m.ProtAddressSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtAddressSize))
	}
	if m.Operation != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Operation))
	}
	if len(m.SrcHwAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcHwAddress)))
		i += copy(dAtA[i:], m.SrcHwAddress)
	}
	if len(m.SrcProtAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcProtAddress)))
		i += copy(dAtA[i:], m.SrcProtAddress)
	}
	if len(m.DstHwAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstHwAddress)))
		i += copy(dAtA[i:], m.DstHwAddress)
	}
	if len(m.DstProtAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstProtAddress)))
		i += copy(dAtA[i:], m.DstProtAddress)
	}
	return i, nil
}

func (m *Dot1Q) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot1Q) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
	}
	if m.DropEligible {
		dAtA[i] = 0x18
		i++
		if m.DropEligible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VLANIdentifier != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLANIdentifier))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Dot11) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Proto != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Proto))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.DurationID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DurationID))
	}
	if len(m.Address1) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address1)))
		i += copy(dAtA[i:], m.Address1)
	}
	if len(m.Address2) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address2)))
		i += copy(dAtA[i:], m.Address2)
	}
	if len(m.Address3) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address3)))
		i += copy(dAtA[i:], m.Address3)
	}
	if len(m.Address4) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address4)))
		i += copy(dAtA[i:], m.Address4)
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
	}
	if m.FragmentNumber != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentNumber))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.QOS != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.QOS.Size()))
		n1, err := m.QOS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.HTControl != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HTControl.Size()))
		n2, err := m.HTControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Dot11QOS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11QOS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TID))
	}
	if m.EOSP {
		dAtA[i] = 0x10
		i++
		if m.EOSP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AckPolicy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AckPolicy))
	}
	if m.TXOP != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TXOP))
	}
	return i, nil
}

func (m *Dot11HTControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ACConstraint {
		dAtA[i] = 0x8
		i++
		if m.ACConstraint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RDGMorePPDU {
		dAtA[i] = 0x10
		i++
		if m.RDGMorePPDU {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VHT != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VHT.Size()))
		n3, err := m.VHT.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.HT != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HT.Size()))
		n4, err := m.HT.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *Dot11HTControlVHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlVHT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MRQ {
		dAtA[i] = 0x8
		i++
		if m.MRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UnsolicitedMFB {
		dAtA[i] = 0x10
		i++
		if m.UnsolicitedMFB {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MSI != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MSI))
	}
	if m.MFB != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFB.Size()))
		n5, err := m.MFB.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CompressedMSI != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CompressedMSI))
	}
	if m.STBCIndication {
		dAtA[i] = 0x30
		i++
		if m.STBCIndication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MFSI != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFSI))
	}
	if m.GID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.GID))
	}
	if m.CodingType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CodingType))
	}
	if m.FbTXBeamformed {
		dAtA[i] = 0x50
		i++
		if m.FbTXBeamformed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Dot11HTControlHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlHT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LinkAdapationControl != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkAdapationControl.Size()))
		n6, err := m.LinkAdapationControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CalibrationPosition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CalibrationPosition))
	}
	if m.CalibrationSequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CalibrationSequence))
	}
	if m.CSISteering != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CSISteering))
	}
	if m.NDPAnnouncement {
		dAtA[i] = 0x28
		i++
		if m.NDPAnnouncement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DEI {
		dAtA[i] = 0x30
		i++
		if m.DEI {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Dot11HTControlMFB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlMFB) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumSTS != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumSTS))
	}
	if m.VHTMCS != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VHTMCS))
	}
	if m.BW != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.BW))
	}
	if m.SNR != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SNR))
	}
	return i, nil
}

func (m *Dot11LinkAdapationControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11LinkAdapationControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TRQ {
		dAtA[i] = 0x8
		i++
		if m.TRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MRQ {
		dAtA[i] = 0x10
		i++
		if m.MRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MSI != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MSI))
	}
	if m.MFSI != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFSI))
	}
	if m.ASEL != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ASEL.Size()))
		n7, err := m.ASEL.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MFB != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFB))
	}
	return i, nil
}

func (m *Dot11ASEL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11ASEL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Command != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Command))
	}
	if m.Data != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Data))
	}
	return i, nil
}

func (m *LinkLayerDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscovery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.ChassisID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ChassisID.Size()))
		n8, err := m.ChassisID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.PortID != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PortID.Size()))
		n9, err := m.PortID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.TTL != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LLDPChassisID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPChassisID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *LLDPPortID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPPortID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *LinkLayerDiscoveryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscoveryValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *EthernetCTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetCTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.SkipCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SkipCount))
	}
	return i, nil
}

func (m *EthernetCTPReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetCTPReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Function != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Function))
	}
	if m.ReceiptNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReceiptNumber))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *LinkLayerDiscoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.PortDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PortDescription)))
		i += copy(dAtA[i:], m.PortDescription)
	}
	if len(m.SysName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysName)))
		i += copy(dAtA[i:], m.SysName)
	}
	if len(m.SysDescription) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysDescription)))
		i += copy(dAtA[i:], m.SysDescription)
	}
	if m.SysCapabilities != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SysCapabilities.Size()))
		n10, err := m.SysCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MgmtAddress != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MgmtAddress.Size()))
		n11, err := m.MgmtAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.OrgTLVs) > 0 {
		for _, msg := range m.OrgTLVs {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Unknown) > 0 {
		for _, msg := range m.Unknown {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LLDPSysCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPSysCapabilities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SystemCap != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SystemCap.Size()))
		n12, err := m.SystemCap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.EnabledCap != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.EnabledCap.Size()))
		n13, err := m.EnabledCap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *LLDPCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPCapabilities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Other {
		dAtA[i] = 0x8
		i++
		if m.Other {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Repeater {
		dAtA[i] = 0x10
		i++
		if m.Repeater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Bridge {
		dAtA[i] = 0x18
		i++
		if m.Bridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WLANAP {
		dAtA[i] = 0x20
		i++
		if m.WLANAP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Router {
		dAtA[i] = 0x28
		i++
		if m.Router {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Phone {
		dAtA[i] = 0x30
		i++
		if m.Phone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DocSis {
		dAtA[i] = 0x38
		i++
		if m.DocSis {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StationOnly {
		dAtA[i] = 0x40
		i++
		if m.StationOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CVLAN {
		dAtA[i] = 0x48
		i++
		if m.CVLAN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SVLAN {
		dAtA[i] = 0x50
		i++
		if m.SVLAN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TMPR {
		dAtA[i] = 0x58
		i++
		if m.TMPR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LLDPMgmtAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPMgmtAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.InterfaceSubtype != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceSubtype))
	}
	if m.InterfaceNumber != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceNumber))
	}
	if len(m.OID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OID)))
		i += copy(dAtA[i:], m.OID)
	}
	return i, nil
}

func (m *LLDPOrgSpecificTLV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPOrgSpecificTLV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OUI != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OUI))
	}
	if m.SubType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SubType))
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	return i, nil
}

func (m *IPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.IHL != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.IHL))
	}
	if m.TOS != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TOS))
	}
	if m.Length != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.Id != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.FragOffset != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragOffset))
	}
	if m.TTL != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if len(m.Padding) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Padding)))
		i += copy(dAtA[i:], m.Padding)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PayloadEntropy != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i += 8
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	return i, nil
}

func (m *IPv4Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4Option) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
	}
	if len(m.OptionData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i += copy(dAtA[i:], m.OptionData)
	}
	return i, nil
}

func (m *IPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.TrafficClass != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TrafficClass))
	}
	if m.FlowLabel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FlowLabel))
	}
	if m.Length != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.NextHeader != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NextHeader))
	}
	if m.HopLimit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopLimit))
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if m.PayloadEntropy != 0 {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i += 8
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	if m.HopByHop != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopByHop.Size()))
		n14, err := m.HopByHop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *IPv6Fragment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Fragment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.NextHeader != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NextHeader))
	}
	if m.Reserved1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved1))
	}
	if m.FragmentOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentOffset))
	}
	if m.Reserved2 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved2))
	}
	if m.MoreFragments {
		dAtA[i] = 0x30
		i++
		if m.MoreFragments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Identification != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Identification))
	}
	return i, nil
}

func (m *ICMPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv4) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.TypeCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
	}
	return i, nil
}

func (m *ICMPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.TypeCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	return i, nil
}

func (m *ICMPv6NeighborAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6NeighborAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if len(m.TargetAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TargetAddress)))
		i += copy(dAtA[i:], m.TargetAddress)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ICMPv6RouterAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6RouterAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.HopLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopLimit))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.RouterLifetime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterLifetime))
	}
	if m.ReachableTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReachableTime))
	}
	if m.RetransTimer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RetransTimer))
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ICMPv6Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6Option) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *UDP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.PayloadEntropy != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i += 8
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *TCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SeqNum))
	}
	if m.AckNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AckNum))
	}
	if m.DataOffset != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DataOffset))
	}
	if m.FIN {
		dAtA[i] = 0x38
		i++
		if m.FIN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SYN {
		dAtA[i] = 0x40
		i++
		if m.SYN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RST {
		dAtA[i] = 0x48
		i++
		if m.RST {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PSH {
		dAtA[i] = 0x50
		i++
		if m.PSH {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ACK {
		dAtA[i] = 0x58
		i++
		if m.ACK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.URG {
		dAtA[i] = 0x60
		i++
		if m.URG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ECE {
		dAtA[i] = 0x68
		i++
		if m.ECE {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CWR {
		dAtA[i] = 0x70
		i++
		if m.CWR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NS {
		dAtA[i] = 0x78
		i++
		if m.NS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Window != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Window))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.Urgent != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Urgent))
	}
	if len(m.Padding) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Padding)))
		i += copy(dAtA[i:], m.Padding)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PayloadEntropy != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i += 8
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *TCPOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
	}
	if len(m.OptionData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i += copy(dAtA[i:], m.OptionData)
	}
	return i, nil
}

func (m *SCTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
	}
	if m.VerificationTag != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VerificationTag))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	return i, nil
}

func (m *DNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
	}
	if m.QR {
		dAtA[i] = 0x18
		i++
		if m.QR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OpCode))
	}
	if m.AA {
		dAtA[i] = 0x28
		i++
		if m.AA {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TC {
		dAtA[i] = 0x30
		i++
		if m.TC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RD {
		dAtA[i] = 0x38
		i++
		if m.RD {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RA {
		dAtA[i] = 0x40
		i++
		if m.RA {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Z != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Z))
	}
	if m.ResponseCode != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResponseCode))
	}
	if m.QDCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.QDCount))
	}
	if m.ANCount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ANCount))
	}
	if m.NSCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NSCount))
	}
	if m.ARCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ARCount))
	}
	if len(m.Questions) > 0 {
		for _, msg := range m.Questions {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Answers) > 0 {
		for _, msg := range m.Answers {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Authorities) > 0 {
		for _, msg := range m.Authorities {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Additionals) > 0 {
		for _, msg := range m.Additionals {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DNSResourceRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSResourceRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Class != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
	}
	if m.TTL != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
	}
	if m.DataLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DataLength))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.NS) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NS)))
		i += copy(dAtA[i:], m.NS)
	}
	if len(m.CNAME) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.CNAME)))
		i += copy(dAtA[i:], m.CNAME)
	}
	if len(m.PTR) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PTR)))
		i += copy(dAtA[i:], m.PTR)
	}
	if m.SOA != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SOA.Size()))
		n15, err := m.SOA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.SRV != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SRV.Size()))
		n16, err := m.SRV.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MX != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MX.Size()))
		n17, err := m.MX.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.TXTs) > 0 {
		for _, b := range m.TXTs {
			dAtA[i] = 0x72
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *DNSSOA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSSOA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MName)))
		i += copy(dAtA[i:], m.MName)
	}
	if len(m.RName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RName)))
		i += copy(dAtA[i:], m.RName)
	}
	if m.Serial != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Serial))
	}
	if m.Refresh != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Refresh))
	}
	if m.Retry != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Retry))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Expire))
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Minimum))
	}
	return i, nil
}

func (m *DNSSRV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSSRV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Weight))
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Port))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *DNSMX) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSMX) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Preference != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Preference))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *DNSQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSQuestion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Class != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
	}
	return i, nil
}

func (m *DHCPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv4) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Operation != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Operation))
	}
	if m.HardwareType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareType))
	}
	if m.HardwareLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareLen))
	}
	if m.HardwareOpts != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareOpts))
	}
	if m.Xid != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Xid))
	}
	if m.Secs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Secs))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if len(m.ClientIP) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientIP)))
		i += copy(dAtA[i:], m.ClientIP)
	}
	if len(m.YourClientIP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.YourClientIP)))
		i += copy(dAtA[i:], m.YourClientIP)
	}
	if len(m.NextServerIP) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NextServerIP)))
		i += copy(dAtA[i:], m.NextServerIP)
	}
	if len(m.RelayAgentIP) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RelayAgentIP)))
		i += copy(dAtA[i:], m.RelayAgentIP)
	}
	if len(m.ClientHWAddr) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientHWAddr)))
		i += copy(dAtA[i:], m.ClientHWAddr)
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DHCPOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *DHCPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv6) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.MsgType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MsgType))
	}
	if m.HopCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopCount))
	}
	if len(m.LinkAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkAddr)))
		i += copy(dAtA[i:], m.LinkAddr)
	}
	if len(m.PeerAddr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PeerAddr)))
		i += copy(dAtA[i:], m.PeerAddr)
	}
	if len(m.TransactionID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TransactionID)))
		i += copy(dAtA[i:], m.TransactionID)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DHCPv6Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv6Option) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Code))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *LLC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.DSAP != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DSAP))
	}
	if m.IG {
		dAtA[i] = 0x18
		i++
		if m.IG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SSAP != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SSAP))
	}
	if m.CR {
		dAtA[i] = 0x28
		i++
		if m.CR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Control != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Control))
	}
	return i, nil
}

func (m *NTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.LeapIndicator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LeapIndicator))
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Mode))
	}
	if m.Stratum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Stratum))
	}
	if m.Poll != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Poll))
	}
	if m.Precision != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Precision))
	}
	if m.RootDelay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RootDelay))
	}
	if m.RootDispersion != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RootDispersion))
	}
	if m.ReferenceID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReferenceID))
	}
	if m.ReferenceTimestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReferenceTimestamp))
	}
	if m.OriginTimestamp != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OriginTimestamp))
	}
	if m.ReceiveTimestamp != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReceiveTimestamp))
	}
	if m.TransmitTimestamp != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransmitTimestamp))
	}
	if len(m.ExtensionBytes) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ExtensionBytes)))
		i += copy(dAtA[i:], m.ExtensionBytes)
	}
	return i, nil
}

func (m *SIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Method != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Method))
	}
	if len(m.Headers) > 0 {
		for _, s := range m.Headers {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IsResponse {
		dAtA[i] = 0x28
		i++
		if m.IsResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResponseCode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResponseCode))
	}
	if len(m.ResponseStatus) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResponseStatus)))
		i += copy(dAtA[i:], m.ResponseStatus)
	}
	return i, nil
}

func (m *IGMP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IGMP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.MaxResponseTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MaxResponseTime))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if len(m.GroupAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.GroupAddress)))
		i += copy(dAtA[i:], m.GroupAddress)
	}
	if m.SupressRouterProcessing {
		dAtA[i] = 0x30
		i++
		if m.SupressRouterProcessing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RobustnessValue != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RobustnessValue))
	}
	if m.IntervalTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.IntervalTime))
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NumberOfGroupRecords != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfGroupRecords))
	}
	if m.NumberOfSources != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfSources))
	}
	if len(m.GroupRecords) > 0 {
		for _, msg := range m.GroupRecords {
			dAtA[i] = 0x62
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Version != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *IGMPv3GroupRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IGMPv3GroupRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.AuxDataLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuxDataLen))
	}
	if m.NumberOfSources != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfSources))
	}
	if len(m.MulticastAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MulticastAddress)))
		i += copy(dAtA[i:], m.MulticastAddress)
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *IPv6HopByHop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPv6HopByHopOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHopOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
	}
	if m.ActualLength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ActualLength))
	}
	if len(m.OptionData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i += copy(dAtA[i:], m.OptionData)
	}
	if m.OptionAlignment != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionAlignment.Size()))
		n18, err := m.OptionAlignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *IPv6HopByHopOptionAlignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHopOptionAlignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.One != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.One))
	}
	if m.Two != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Two))
	}
	return i, nil
}

func (m *SNAP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNAP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.OrganizationalCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OrganizationalCode)))
		i += copy(dAtA[i:], m.OrganizationalCode)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ICMPv6Echo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6Echo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Identifier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Identifier))
	}
	if m.SeqNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SeqNumber))
	}
	return i, nil
}

func (m *ICMPv6NeighborSolicitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6NeighborSolicitation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.TargetAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TargetAddress)))
		i += copy(dAtA[i:], m.TargetAddress)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ICMPv6RouterSolicitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6RouterSolicitation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.Proto) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Proto)))
		i += copy(dAtA[i:], m.Proto)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.UserAgent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.UserAgent)))
		i += copy(dAtA[i:], m.UserAgent)
	}
	if len(m.Referer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Referer)))
		i += copy(dAtA[i:], m.Referer)
	}
	if len(m.ReqCookies) > 0 {
		for _, s := range m.ReqCookies {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ReqContentLength != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReqContentLength))
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if m.ResContentLength != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResContentLength))
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.StatusCode))
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	return i, nil
}

func (m *TLSClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSClientHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.MessageLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MessageLen))
	}
	if m.HandshakeType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeType))
	}
	if m.HandshakeLen != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeLen))
	}
	if m.HandshakeVersion != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeVersion))
	}
	if len(m.Random) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Random)))
		i += copy(dAtA[i:], m.Random)
	}
	if m.SessionIDLen != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SessionIDLen))
	}
	if len(m.SessionID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SessionID)))
		i += copy(dAtA[i:], m.SessionID)
	}
	if m.CipherSuiteLen != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CipherSuiteLen))
	}
	if m.ExtensionLen != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExtensionLen))
	}
	if len(m.SNI) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SNI)))
		i += copy(dAtA[i:], m.SNI)
	}
	if m.OSCP {
		dAtA[i] = 0x70
		i++
		if m.OSCP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CipherSuites) > 0 {
		dAtA20 := make([]byte, len(m.CipherSuites)*10)
		var j19 int
		for _, num1 := range m.CipherSuites {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.CompressMethods) > 0 {
		dAtA22 := make([]byte, len(m.CompressMethods)*10)
		var j21 int
		for _, num1 := range m.CompressMethods {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if len(m.SignatureAlgs) > 0 {
		dAtA24 := make([]byte, len(m.SignatureAlgs)*10)
		var j23 int
		for _, num1 := range m.SignatureAlgs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	if len(m.SupportedGroups) > 0 {
		dAtA26 := make([]byte, len(m.SupportedGroups)*10)
		var j25 int
		for _, num1 := range m.SupportedGroups {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if len(m.SupportedPoints) > 0 {
		dAtA28 := make([]byte, len(m.SupportedPoints)*10)
		var j27 int
		for _, num1 := range m.SupportedPoints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if len(m.ALPNs) > 0 {
		for _, s := range m.ALPNs {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ja3) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Ja3)))
		i += copy(dAtA[i:], m.Ja3)
	}
	if len(m.SrcIP) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i += copy(dAtA[i:], m.SrcIP)
	}
	if len(m.DstIP) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i += copy(dAtA[i:], m.DstIP)
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	if m.SrcPort != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
	}
	if len(m.Extensions) > 0 {
		dAtA30 := make([]byte, len(m.Extensions)*10)
		var j29 int
		for _, num1 := range m.Extensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	return i, nil
}

func (m *IPSecAH) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecAH) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Reserved != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved))
	}
	if m.SPI != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SPI))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
	}
	if len(m.AuthenticationData) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AuthenticationData)))
		i += copy(dAtA[i:], m.AuthenticationData)
	}
	return i, nil
}

func (m *IPSecESP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecESP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.SPI != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SPI))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
	}
	if m.LenEncrypted != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LenEncrypted))
	}
	return i, nil
}

func (m *Geneve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Geneve) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.OptionsLength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionsLength))
	}
	if m.OAMPacket {
		dAtA[i] = 0x20
		i++
		if m.OAMPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CriticalOption {
		dAtA[i] = 0x28
		i++
		if m.CriticalOption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
	}
	if m.VNI != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VNI))
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GeneveOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneveOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Class != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *VXLAN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VXLAN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.ValidIDFlag {
		dAtA[i] = 0x10
		i++
		if m.ValidIDFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VNI != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VNI))
	}
	if m.GBPExtension {
		dAtA[i] = 0x20
		i++
		if m.GBPExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GBPDontLearn {
		dAtA[i] = 0x28
		i++
		if m.GBPDontLearn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GBPApplied {
		dAtA[i] = 0x30
		i++
		if m.GBPApplied {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GBPGroupPolicyID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.GBPGroupPolicyID))
	}
	return i, nil
}

func (m *USB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USB) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
	}
	if m.EventType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.EventType))
	}
	if m.TransferType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransferType))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Direction))
	}
	if m.EndpointNumber != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.EndpointNumber))
	}
	if m.DeviceAddress != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DeviceAddress))
	}
	if m.BusID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.BusID))
	}
	if m.TimestampSec != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampSec))
	}
	if m.TimestampUsec != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampUsec))
	}
	if m.Setup {
		dAtA[i] = 0x58
		i++
		if m.Setup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Data {
		dAtA[i] = 0x60
		i++
		if m.Data {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Status != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
	}
	if m.UrbLength != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbLength))
	}
	if m.UrbDataLength != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbDataLength))
	}
	if m.UrbInterval != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbInterval))
	}
	if m.UrbStartFrame != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbStartFrame))
	}
	if m.UrbCopyOfTransferFlags != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbCopyOfTransferFlags))
	}
	if m.IsoNumDesc != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.IsoNumDesc))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *USBRequestBlockSetup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USBRequestBlockSetup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.RequestType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequestType))
	}
	if m.Request != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Request))
	}
	if m.Value != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Value))
	}
	if m.Index != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Index))
	}
	if m.Length != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *LCM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LCM) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Magic != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Magic))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
	}
	if m.FragmentOffset != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentOffset))
	}
	if m.FragmentNumber != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentNumber))
	}
	if m.TotalFragments != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalFragments))
	}
	if len(m.ChannelName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ChannelName)))
		i += copy(dAtA[i:], m.ChannelName)
	}
	if m.Fragmented {
		dAtA[i] = 0x48
		i++
		if m.Fragmented {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MPLS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MPLS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Label != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Label))
	}
	if m.TrafficClass != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TrafficClass))
	}
	if m.StackBottom {
		dAtA[i] = 0x20
		i++
		if m.StackBottom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TTL != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
	}
	return i, nil
}

func (m *ModbusTCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModbusTCP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.TransactionIdentifier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransactionIdentifier))
	}
	if m.ProtocolIdentifier != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtocolIdentifier))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.UnitIdentifier != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UnitIdentifier))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *OSPFv2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSPFv2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.PacketLength != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.AuType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuType))
	}
	if m.Authentication != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Authentication))
	}
	if len(m.LSAs) > 0 {
		for _, msg := range m.LSAs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LSU != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSU.Size()))
		n31, err := m.LSU.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.LSR) > 0 {
		for _, msg := range m.LSR {
			dAtA[i] = 0x62
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DbDesc != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DbDesc.Size()))
		n32, err := m.DbDesc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.HelloV2 != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HelloV2.Size()))
		n33, err := m.HelloV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *HelloPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloPkg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		dAtA35 := make([]byte, len(m.NeighborID)*10)
		var j34 int
		for _, num := range m.NeighborID {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	return i, nil
}

func (m *HelloPkgV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloPkgV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		dAtA37 := make([]byte, len(m.NeighborID)*10)
		var j36 int
		for _, num := range m.NeighborID {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	if m.NetworkMask != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NetworkMask))
	}
	return i, nil
}

func (m *DbDescPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDescPkg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if m.InterfaceMTU != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceMTU))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.DDSeqNumber != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DDSeqNumber))
	}
	if len(m.LSAinfo) > 0 {
		for _, msg := range m.LSAinfo {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OSPFv3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSPFv3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.PacketLength != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.Instance != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Instance))
	}
	if m.Reserved != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved))
	}
	if m.Hello != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Hello.Size()))
		n38, err := m.Hello.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.DbDesc != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DbDesc.Size()))
		n39, err := m.DbDesc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.LSR) > 0 {
		for _, msg := range m.LSR {
			dAtA[i] = 0x62
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LSU != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSU.Size()))
		n40, err := m.LSU.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.LSAs) > 0 {
		for _, msg := range m.LSAs {
			dAtA[i] = 0x72
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LSAheader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSAheader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LSAge != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSAge))
	}
	if m.LSType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSType))
	}
	if m.LinkStateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkStateID))
	}
	if m.AdvRouter != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdvRouter))
	}
	if m.LSSeqNumber != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSSeqNumber))
	}
	if m.LSChecksum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSChecksum))
	}
	if m.Length != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.LSOptions != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSOptions))
	}
	return i, nil
}

func (m *LSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Header.Size()))
		n41, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.RLSAV2 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RLSAV2.Size()))
		n42, err := m.RLSAV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.ASELSAV2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ASELSAV2.Size()))
		n43, err := m.ASELSAV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.RLSA != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RLSA.Size()))
		n44, err := m.RLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.NLSA != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NLSA.Size()))
		n45, err := m.NLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.InterAPrefixLSA != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterAPrefixLSA.Size()))
		n46, err := m.InterAPrefixLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.IARouterLSA != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.IARouterLSA.Size()))
		n47, err := m.IARouterLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.ASELSA != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ASELSA.Size()))
		n48, err := m.ASELSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.LLSA != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LLSA.Size()))
		n49, err := m.LLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.IntraAPrefixLSA != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.IntraAPrefixLSA.Size()))
		n50, err := m.IntraAPrefixLSA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *LSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LSType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSType))
	}
	if m.LSID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSID))
	}
	if m.AdvRouter != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdvRouter))
	}
	return i, nil
}

func (m *LSUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumOfLSAs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfLSAs))
	}
	if len(m.LSAs) > 0 {
		for _, msg := range m.LSAs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IntraAreaPrefixLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntraAreaPrefixLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumOfPrefixes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfPrefixes))
	}
	if m.RefLSType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLSType))
	}
	if m.RefLinkStateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLinkStateID))
	}
	if m.RefAdvRouter != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefAdvRouter))
	}
	if len(m.Prefixes) > 0 {
		for _, msg := range m.Prefixes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ASExternalLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ASExternalLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
	}
	if m.RefLSType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLSType))
	}
	if len(m.AddressPrefix) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i += copy(dAtA[i:], m.AddressPrefix)
	}
	if len(m.ForwardingAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ForwardingAddress)))
		i += copy(dAtA[i:], m.ForwardingAddress)
	}
	if m.ExternalRouteTag != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalRouteTag))
	}
	if m.RefLinkStateID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLinkStateID))
	}
	return i, nil
}

func (m *InterAreaPrefixLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterAreaPrefixLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
	}
	if len(m.AddressPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i += copy(dAtA[i:], m.AddressPrefix)
	}
	return i, nil
}

func (m *InterAreaRouterLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterAreaRouterLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if m.DestinationRouterID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DestinationRouterID))
	}
	return i, nil
}

func (m *ASExternalLSAV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ASExternalLSAV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkMask != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NetworkMask))
	}
	if m.ExternalBit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalBit))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if m.ForwardingAddress != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ForwardingAddress))
	}
	if m.ExternalRouteTag != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalRouteTag))
	}
	return i, nil
}

func (m *RouterLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.Options != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if len(m.Routers) > 0 {
		for _, msg := range m.Routers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if m.InterfaceID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
	}
	if m.NeighborInterfaceID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NeighborInterfaceID))
	}
	if m.NeighborRouterID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NeighborRouterID))
	}
	return i, nil
}

func (m *RouterLSAV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterLSAV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.Links != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Links))
	}
	if len(m.Routers) > 0 {
		for _, msg := range m.Routers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouterV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.LinkID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkID))
	}
	if m.LinkData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkData))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	return i, nil
}

func (m *NetworkLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if len(m.AttachedRouter) > 0 {
		dAtA52 := make([]byte, len(m.AttachedRouter)*10)
		var j51 int
		for _, num := range m.AttachedRouter {
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j51))
		i += copy(dAtA[i:], dAtA52[:j51])
	}
	return i, nil
}

func (m *LinkLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLSA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RtrPriority != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
	}
	if len(m.LinkLocalAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkLocalAddress)))
		i += copy(dAtA[i:], m.LinkLocalAddress)
	}
	if m.NumOfPrefixes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfPrefixes))
	}
	if len(m.Prefixes) > 0 {
		for _, msg := range m.Prefixes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LSAPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSAPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrefixLength != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
	}
	if m.Metric != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
	}
	if len(m.AddressPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i += copy(dAtA[i:], m.AddressPrefix)
	}
	return i, nil
}

func (m *BFD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFD) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Diagnostic != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Diagnostic))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.State))
	}
	if m.Poll {
		dAtA[i] = 0x28
		i++
		if m.Poll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Final {
		dAtA[i] = 0x30
		i++
		if m.Final {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ControlPlaneIndependent {
		dAtA[i] = 0x38
		i++
		if m.ControlPlaneIndependent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AuthPresent {
		dAtA[i] = 0x40
		i++
		if m.AuthPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Demand {
		dAtA[i] = 0x48
		i++
		if m.Demand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Multipoint {
		dAtA[i] = 0x50
		i++
		if m.Multipoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DetectMultiplier != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DetectMultiplier))
	}
	if m.MyDiscriminator != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MyDiscriminator))
	}
	if m.YourDiscriminator != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.YourDiscriminator))
	}
	if m.DesiredMinTxInterval != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesiredMinTxInterval))
	}
	if m.RequiredMinRxInterval != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequiredMinRxInterval))
	}
	if m.RequiredMinEchoRxInterval != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequiredMinEchoRxInterval))
	}
	if m.AuthHeader != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuthHeader.Size()))
		n53, err := m.AuthHeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}

func (m *BFDAuthHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFDAuthHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuthType))
	}
	if m.KeyID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyID))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *GRE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRE) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.ChecksumPresent {
		dAtA[i] = 0x10
		i++
		if m.ChecksumPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RoutingPresent {
		dAtA[i] = 0x18
		i++
		if m.RoutingPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyPresent {
		dAtA[i] = 0x20
		i++
		if m.KeyPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SeqPresent {
		dAtA[i] = 0x28
		i++
		if m.SeqPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StrictSourceRoute {
		dAtA[i] = 0x30
		i++
		if m.StrictSourceRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AckPresent {
		dAtA[i] = 0x38
		i++
		if m.AckPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecursionControl != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RecursionControl))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
	}
	if m.Version != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Offset))
	}
	if m.Key != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Key))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
	}
	if m.Ack != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Ack))
	}
	if m.Routing != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Routing.Size()))
		n54, err := m.Routing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}

func (m *GRERouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRERouting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddressFamily != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AddressFamily))
	}
	if m.SREOffset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SREOffset))
	}
	if m.SRELength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SRELength))
	}
	if len(m.RoutingInformation) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RoutingInformation)))
		i += copy(dAtA[i:], m.RoutingInformation)
	}
	if m.Next != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Next.Size()))
		n55, err := m.Next.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *FDDI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FDDI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.FrameControl != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.FrameControl))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
	}
	if len(m.SrcMAC) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i += copy(dAtA[i:], m.SrcMAC)
	}
	if len(m.DstMAC) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i += copy(dAtA[i:], m.DstMAC)
	}
	return i, nil
}

func (m *EAP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Code))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeData) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TypeData)))
		i += copy(dAtA[i:], m.TypeData)
	}
	return i, nil
}

func (m *EAPOL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAPOL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *EAPOLKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAPOLKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.KeyDescriptorType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDescriptorType))
	}
	if m.KeyDescriptorVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDescriptorVersion))
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyType))
	}
	if m.KeyIndex != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyIndex))
	}
	if m.Install {
		dAtA[i] = 0x30
		i++
		if m.Install {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyACK {
		dAtA[i] = 0x38
		i++
		if m.KeyACK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyMIC {
		dAtA[i] = 0x40
		i++
		if m.KeyMIC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Secure {
		dAtA[i] = 0x48
		i++
		if m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MICError {
		dAtA[i] = 0x50
		i++
		if m.MICError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Request {
		dAtA[i] = 0x58
		i++
		if m.Request {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasEncryptedKeyData {
		dAtA[i] = 0x60
		i++
		if m.HasEncryptedKeyData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SMKMessage {
		dAtA[i] = 0x68
		i++
		if m.SMKMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyLength != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyLength))
	}
	if m.ReplayCounter != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReplayCounter))
	}
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.IV) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IV)))
		i += copy(dAtA[i:], m.IV)
	}
	if m.RSC != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.RSC))
	}
	if m.ID != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
	}
	if len(m.MIC) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MIC)))
		i += copy(dAtA[i:], m.MIC)
	}
	if m.KeyDataLength != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDataLength))
	}
	if len(m.EncryptedKeyData) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.EncryptedKeyData)))
		i += copy(dAtA[i:], m.EncryptedKeyData)
	}
	return i, nil
}

func (m *VRRPv2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VRRPv2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.VirtualRtrID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VirtualRtrID))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
	}
	if m.CountIPAddr != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CountIPAddr))
	}
	if m.AuthType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuthType))
	}
	if m.AdverInt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdverInt))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if len(m.IPAddress) > 0 {
		for _, s := range m.IPAddress {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CiscoDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscovery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.TTL != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CiscoDiscoveryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscoveryValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CDPVLANDialogue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPVLANDialogue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
	}
	if m.VLAN != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLAN))
	}
	return i, nil
}

func (m *CDPLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	return i, nil
}

func (m *CDPPowerDialogue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPPowerDialogue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
	}
	if m.MgmtID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MgmtID))
	}
	if len(m.Values) > 0 {
		dAtA57 := make([]byte, len(m.Values)*10)
		var j56 int
		for _, num := range m.Values {
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(j56))
		i += copy(dAtA[i:], dAtA57[:j56])
	}
	return i, nil
}

func (m *CDPSparePairPoE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPSparePairPoE) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PSEFourWire {
		dAtA[i] = 0x8
		i++
		if m.PSEFourWire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PDArchShared {
		dAtA[i] = 0x10
		i++
		if m.PDArchShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PDRequestOn {
		dAtA[i] = 0x18
		i++
		if m.PDRequestOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PSEOn {
		dAtA[i] = 0x20
		i++
		if m.PSEOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CiscoDiscoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if m.CDPHello != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.CDPHello.Size()))
		n58, err := m.CDPHello.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.DeviceID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeviceID)))
		i += copy(dAtA[i:], m.DeviceID)
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PortID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PortID)))
		i += copy(dAtA[i:], m.PortID)
	}
	if m.Capabilities != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Capabilities.Size()))
		n59, err := m.Capabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.IPPrefixes) > 0 {
		for _, msg := range m.IPPrefixes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VTPDomain) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.VTPDomain)))
		i += copy(dAtA[i:], m.VTPDomain)
	}
	if m.NativeVLAN != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NativeVLAN))
	}
	if m.FullDuplex {
		dAtA[i] = 0x60
		i++
		if m.FullDuplex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VLANReply != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLANReply.Size()))
		n60, err := m.VLANReply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.VLANQuery != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLANQuery.Size()))
		n61, err := m.VLANQuery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.PowerConsumption != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PowerConsumption))
	}
	if m.MTU != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.MTU))
	}
	if m.ExtendedTrust != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExtendedTrust))
	}
	if m.UntrustedCOS != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.UntrustedCOS))
	}
	if len(m.SysName) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysName)))
		i += copy(dAtA[i:], m.SysName)
	}
	if len(m.SysOID) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysOID)))
		i += copy(dAtA[i:], m.SysOID)
	}
	if len(m.MgmtAddresses) > 0 {
		for _, s := range m.MgmtAddresses {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Location != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Location.Size()))
		n62, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.PowerRequest != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PowerRequest.Size()))
		n63, err := m.PowerRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.PowerAvailable != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.PowerAvailable.Size()))
		n64, err := m.PowerAvailable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.SparePairPoe != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SparePairPoe.Size()))
		n65, err := m.SparePairPoe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.EnergyWise != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.EnergyWise.Size()))
		n66, err := m.EnergyWise.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if len(m.Unknown) > 0 {
		for _, msg := range m.Unknown {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNetcap(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CDPHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OUI) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OUI)))
		i += copy(dAtA[i:], m.OUI)
	}
	if m.ProtocolID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtocolID))
	}
	if len(m.ClusterMaster) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClusterMaster)))
		i += copy(dAtA[i:], m.ClusterMaster)
	}
	if len(m.Unknown1) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Unknown1)))
		i += copy(dAtA[i:], m.Unknown1)
	}
	if m.Version != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
	}
	if m.SubVersion != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SubVersion))
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
	}
	if m.Unknown2 != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown2))
	}
	if len(m.ClusterCommander) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClusterCommander)))
		i += copy(dAtA[i:], m.ClusterCommander)
	}
	if len(m.SwitchMAC) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SwitchMAC)))
		i += copy(dAtA[i:], m.SwitchMAC)
	}
	if m.Unknown3 != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown3))
	}
	if m.ManagementVLAN != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.ManagementVLAN))
	}
	return i, nil
}

func (m *CDPEnergyWise) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPEnergyWise) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryptedData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.EncryptedData)))
		i += copy(dAtA[i:], m.EncryptedData)
	}
	if m.Unknown1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown1))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.ModelNumber) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ModelNumber)))
		i += copy(dAtA[i:], m.ModelNumber)
	}
	if m.Unknown2 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown2))
	}
	if len(m.HardwareID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.HardwareID)))
		i += copy(dAtA[i:], m.HardwareID)
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.Unknown3) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Unknown3)))
		i += copy(dAtA[i:], m.Unknown3)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ReplyUnknown1) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown1)))
		i += copy(dAtA[i:], m.ReplyUnknown1)
	}
	if len(m.ReplyPort) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyPort)))
		i += copy(dAtA[i:], m.ReplyPort)
	}
	if len(m.ReplyAddress) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyAddress)))
		i += copy(dAtA[i:], m.ReplyAddress)
	}
	if len(m.ReplyUnknown2) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown2)))
		i += copy(dAtA[i:], m.ReplyUnknown2)
	}
	if len(m.ReplyUnknown3) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown3)))
		i += copy(dAtA[i:], m.ReplyUnknown3)
	}
	return i, nil
}

func (m *CDPCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPCapabilities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L3Router {
		dAtA[i] = 0x8
		i++
		if m.L3Router {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TBBridge {
		dAtA[i] = 0x10
		i++
		if m.TBBridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SPBridge {
		dAtA[i] = 0x18
		i++
		if m.SPBridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.L2Switch {
		dAtA[i] = 0x20
		i++
		if m.L2Switch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsHost {
		dAtA[i] = 0x28
		i++
		if m.IsHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IGMPFilter {
		dAtA[i] = 0x30
		i++
		if m.IGMPFilter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.L1Repeater {
		dAtA[i] = 0x38
		i++
		if m.L1Repeater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPhone {
		dAtA[i] = 0x40
		i++
		if m.IsPhone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RemotelyManaged {
		dAtA[i] = 0x48
		i++
		if m.RemotelyManaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IPNet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPNet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.IPMask) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPMask)))
		i += copy(dAtA[i:], m.IPMask)
	}
	return i, nil
}

func (m *NortelDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NortelDiscovery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Timestamp)))
		i += copy(dAtA[i:], m.Timestamp)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.SegmentID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SegmentID)))
		i += copy(dAtA[i:], m.SegmentID)
	}
	if m.Chassis != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Chassis))
	}
	if m.Backplane != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.Backplane))
	}
	if m.State != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.State))
	}
	if m.NumLinks != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumLinks))
	}
	return i, nil
}

func encodeVarintNetcap(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.InputSource)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ContainsPayloads {
		n += 2
	}
	return n
}

func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MessageType != 0 {
		n += 1 + sovNetcap(uint64(m.MessageType))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ContainsPayloads {
		n += 2
	}
	return n
}

func (m *Flow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimestampFirst)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.LinkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NetworkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TransportProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ApplicationProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.AppPayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.AppPayloadSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TimestampLast)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.Duration != 0 {
		n += 2 + sovNetcap(uint64(m.Duration))
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimestampFirst)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.LinkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NetworkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TransportProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ApplicationProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.AppPayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.AppPayloadSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TimestampLast)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.Duration != 0 {
		n += 2 + sovNetcap(uint64(m.Duration))
	}
	return n
}

func (m *LinkFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimestampFirst)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TimestampLast)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	if m.UID != 0 {
		n += 1 + sovNetcap(uint64(m.UID))
	}
	if m.Duration != 0 {
		n += 1 + sovNetcap(uint64(m.Duration))
	}
	return n
}

func (m *NetworkFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimestampFirst)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TimestampLast)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	if m.UID != 0 {
		n += 1 + sovNetcap(uint64(m.UID))
	}
	if m.Duration != 0 {
		n += 1 + sovNetcap(uint64(m.Duration))
	}
	return n
}

func (m *TransportFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimestampFirst)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TimestampLast)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	if m.UID != 0 {
		n += 1 + sovNetcap(uint64(m.UID))
	}
	if m.Duration != 0 {
		n += 1 + sovNetcap(uint64(m.Duration))
	}
	return n
}

func (m *Ethernet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.EthernetType != 0 {
		n += 1 + sovNetcap(uint64(m.EthernetType))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	return n
}

func (m *ARP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.AddrType != 0 {
		n += 1 + sovNetcap(uint64(m.AddrType))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.HwAddressSize != 0 {
		n += 1 + sovNetcap(uint64(m.HwAddressSize))
	}
	if m.ProtAddressSize != 0 {
		n += 1 + sovNetcap(uint64(m.ProtAddressSize))
	}
	if m.Operation != 0 {
		n += 1 + sovNetcap(uint64(m.Operation))
	}
	l = len(m.SrcHwAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcProtAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstHwAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstProtAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot1Q) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.DropEligible {
		n += 2
	}
	if m.VLANIdentifier != 0 {
		n += 1 + sovNetcap(uint64(m.VLANIdentifier))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	return n
}

func (m *Dot11) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Proto != 0 {
		n += 1 + sovNetcap(uint64(m.Proto))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.DurationID != 0 {
		n += 1 + sovNetcap(uint64(m.DurationID))
	}
	l = len(m.Address1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address2)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address3)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address4)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	if m.FragmentNumber != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentNumber))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.QOS != nil {
		l = m.QOS.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HTControl != nil {
		l = m.HTControl.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot11QOS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TID != 0 {
		n += 1 + sovNetcap(uint64(m.TID))
	}
	if m.EOSP {
		n += 2
	}
	if m.AckPolicy != 0 {
		n += 1 + sovNetcap(uint64(m.AckPolicy))
	}
	if m.TXOP != 0 {
		n += 1 + sovNetcap(uint64(m.TXOP))
	}
	return n
}

func (m *Dot11HTControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ACConstraint {
		n += 2
	}
	if m.RDGMorePPDU {
		n += 2
	}
	if m.VHT != nil {
		l = m.VHT.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HT != nil {
		l = m.HT.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot11HTControlVHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MRQ {
		n += 2
	}
	if m.UnsolicitedMFB {
		n += 2
	}
	if m.MSI != 0 {
		n += 1 + sovNetcap(uint64(m.MSI))
	}
	if m.MFB != nil {
		l = m.MFB.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CompressedMSI != 0 {
		n += 1 + sovNetcap(uint64(m.CompressedMSI))
	}
	if m.STBCIndication {
		n += 2
	}
	if m.MFSI != 0 {
		n += 1 + sovNetcap(uint64(m.MFSI))
	}
	if m.GID != 0 {
		n += 1 + sovNetcap(uint64(m.GID))
	}
	if m.CodingType != 0 {
		n += 1 + sovNetcap(uint64(m.CodingType))
	}
	if m.FbTXBeamformed {
		n += 2
	}
	return n
}

func (m *Dot11HTControlHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkAdapationControl != nil {
		l = m.LinkAdapationControl.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CalibrationPosition != 0 {
		n += 1 + sovNetcap(uint64(m.CalibrationPosition))
	}
	if m.CalibrationSequence != 0 {
		n += 1 + sovNetcap(uint64(m.CalibrationSequence))
	}
	if m.CSISteering != 0 {
		n += 1 + sovNetcap(uint64(m.CSISteering))
	}
	if m.NDPAnnouncement {
		n += 2
	}
	if m.DEI {
		n += 2
	}
	return n
}

func (m *Dot11HTControlMFB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumSTS != 0 {
		n += 1 + sovNetcap(uint64(m.NumSTS))
	}
	if m.VHTMCS != 0 {
		n += 1 + sovNetcap(uint64(m.VHTMCS))
	}
	if m.BW != 0 {
		n += 1 + sovNetcap(uint64(m.BW))
	}
	if m.SNR != 0 {
		n += 1 + sovNetcap(uint64(m.SNR))
	}
	return n
}

func (m *Dot11LinkAdapationControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TRQ {
		n += 2
	}
	if m.MRQ {
		n += 2
	}
	if m.MSI != 0 {
		n += 1 + sovNetcap(uint64(m.MSI))
	}
	if m.MFSI != 0 {
		n += 1 + sovNetcap(uint64(m.MFSI))
	}
	if m.ASEL != nil {
		l = m.ASEL.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MFB != 0 {
		n += 1 + sovNetcap(uint64(m.MFB))
	}
	return n
}

func (m *Dot11ASEL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovNetcap(uint64(m.Command))
	}
	if m.Data != 0 {
		n += 1 + sovNetcap(uint64(m.Data))
	}
	return n
}

func (m *LinkLayerDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ChassisID != nil {
		l = m.ChassisID.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PortID != nil {
		l = m.PortID.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LLDPChassisID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPPortID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LinkLayerDiscoveryValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EthernetCTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SkipCount != 0 {
		n += 1 + sovNetcap(uint64(m.SkipCount))
	}
	return n
}

func (m *EthernetCTPReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Function != 0 {
		n += 1 + sovNetcap(uint64(m.Function))
	}
	if m.ReceiptNumber != 0 {
		n += 1 + sovNetcap(uint64(m.ReceiptNumber))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LinkLayerDiscoveryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.PortDescription)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysDescription)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SysCapabilities != nil {
		l = m.SysCapabilities.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MgmtAddress != nil {
		l = m.MgmtAddress.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.OrgTLVs) > 0 {
		for _, e := range m.OrgTLVs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Unknown) > 0 {
		for _, e := range m.Unknown {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LLDPSysCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemCap != nil {
		l = m.SystemCap.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.EnabledCap != nil {
		l = m.EnabledCap.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Other {
		n += 2
	}
	if m.Repeater {
		n += 2
	}
	if m.Bridge {
		n += 2
	}
	if m.WLANAP {
		n += 2
	}
	if m.Router {
		n += 2
	}
	if m.Phone {
		n += 2
	}
	if m.DocSis {
		n += 2
	}
	if m.StationOnly {
		n += 2
	}
	if m.CVLAN {
		n += 2
	}
	if m.SVLAN {
		n += 2
	}
	if m.TMPR {
		n += 2
	}
	return n
}

func (m *LLDPMgmtAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.InterfaceSubtype != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceSubtype))
	}
	if m.InterfaceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceNumber))
	}
	l = len(m.OID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPOrgSpecificTLV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OUI != 0 {
		n += 1 + sovNetcap(uint64(m.OUI))
	}
	if m.SubType != 0 {
		n += 1 + sovNetcap(uint64(m.SubType))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.IHL != 0 {
		n += 1 + sovNetcap(uint64(m.IHL))
	}
	if m.TOS != 0 {
		n += 1 + sovNetcap(uint64(m.TOS))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.FragOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragOffset))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Padding)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.PayloadEntropy != 0 {
		n += 10
	}
	if m.PayloadSize != 0 {
		n += 2 + sovNetcap(uint64(m.PayloadSize))
	}
	return n
}

func (m *IPv4Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.TrafficClass != 0 {
		n += 1 + sovNetcap(uint64(m.TrafficClass))
	}
	if m.FlowLabel != 0 {
		n += 1 + sovNetcap(uint64(m.FlowLabel))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.NextHeader != 0 {
		n += 1 + sovNetcap(uint64(m.NextHeader))
	}
	if m.HopLimit != 0 {
		n += 1 + sovNetcap(uint64(m.HopLimit))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	if m.HopByHop != nil {
		l = m.HopByHop.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6Fragment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NextHeader != 0 {
		n += 1 + sovNetcap(uint64(m.NextHeader))
	}
	if m.Reserved1 != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved1))
	}
	if m.FragmentOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentOffset))
	}
	if m.Reserved2 != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved2))
	}
	if m.MoreFragments {
		n += 2
	}
	if m.Identification != 0 {
		n += 1 + sovNetcap(uint64(m.Identification))
	}
	return n
}

func (m *ICMPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TypeCode != 0 {
		n += 1 + sovNetcap(uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	return n
}

func (m *ICMPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TypeCode != 0 {
		n += 1 + sovNetcap(uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	return n
}

func (m *ICMPv6NeighborAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *ICMPv6RouterAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HopLimit != 0 {
		n += 1 + sovNetcap(uint64(m.HopLimit))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.RouterLifetime != 0 {
		n += 1 + sovNetcap(uint64(m.RouterLifetime))
	}
	if m.ReachableTime != 0 {
		n += 1 + sovNetcap(uint64(m.ReachableTime))
	}
	if m.RetransTimer != 0 {
		n += 1 + sovNetcap(uint64(m.RetransTimer))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *ICMPv6Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *UDP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *TCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.SeqNum != 0 {
		n += 1 + sovNetcap(uint64(m.SeqNum))
	}
	if m.AckNum != 0 {
		n += 1 + sovNetcap(uint64(m.AckNum))
	}
	if m.DataOffset != 0 {
		n += 1 + sovNetcap(uint64(m.DataOffset))
	}
	if m.FIN {
		n += 2
	}
	if m.SYN {
		n += 2
	}
	if m.RST {
		n += 2
	}
	if m.PSH {
		n += 2
	}
	if m.ACK {
		n += 2
	}
	if m.URG {
		n += 2
	}
	if m.ECE {
		n += 2
	}
	if m.CWR {
		n += 2
	}
	if m.NS {
		n += 2
	}
	if m.Window != 0 {
		n += 2 + sovNetcap(uint64(m.Window))
	}
	if m.Checksum != 0 {
		n += 2 + sovNetcap(uint64(m.Checksum))
	}
	if m.Urgent != 0 {
		n += 2 + sovNetcap(uint64(m.Urgent))
	}
	l = len(m.Padding)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if m.PayloadEntropy != 0 {
		n += 10
	}
	if m.PayloadSize != 0 {
		n += 2 + sovNetcap(uint64(m.PayloadSize))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *TCPOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SCTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.VerificationTag != 0 {
		n += 1 + sovNetcap(uint64(m.VerificationTag))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	return n
}

func (m *DNS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.QR {
		n += 2
	}
	if m.OpCode != 0 {
		n += 1 + sovNetcap(uint64(m.OpCode))
	}
	if m.AA {
		n += 2
	}
	if m.TC {
		n += 2
	}
	if m.RD {
		n += 2
	}
	if m.RA {
		n += 2
	}
	if m.Z != 0 {
		n += 1 + sovNetcap(uint64(m.Z))
	}
	if m.ResponseCode != 0 {
		n += 1 + sovNetcap(uint64(m.ResponseCode))
	}
	if m.QDCount != 0 {
		n += 1 + sovNetcap(uint64(m.QDCount))
	}
	if m.ANCount != 0 {
		n += 1 + sovNetcap(uint64(m.ANCount))
	}
	if m.NSCount != 0 {
		n += 1 + sovNetcap(uint64(m.NSCount))
	}
	if m.ARCount != 0 {
		n += 1 + sovNetcap(uint64(m.ARCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Answers) > 0 {
		for _, e := range m.Answers {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Authorities) > 0 {
		for _, e := range m.Authorities {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Additionals) > 0 {
		for _, e := range m.Additionals {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *DNSResourceRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.DataLength != 0 {
		n += 1 + sovNetcap(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NS)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.CNAME)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.PTR)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SOA != nil {
		l = m.SOA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SRV != nil {
		l = m.SRV.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MX != nil {
		l = m.MX.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.TXTs) > 0 {
		for _, b := range m.TXTs {
			l = len(b)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *DNSSOA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.RName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Serial != 0 {
		n += 1 + sovNetcap(uint64(m.Serial))
	}
	if m.Refresh != 0 {
		n += 1 + sovNetcap(uint64(m.Refresh))
	}
	if m.Retry != 0 {
		n += 1 + sovNetcap(uint64(m.Retry))
	}
	if m.Expire != 0 {
		n += 1 + sovNetcap(uint64(m.Expire))
	}
	if m.Minimum != 0 {
		n += 1 + sovNetcap(uint64(m.Minimum))
	}
	return n
}

func (m *DNSSRV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.Weight != 0 {
		n += 1 + sovNetcap(uint64(m.Weight))
	}
	if m.Port != 0 {
		n += 1 + sovNetcap(uint64(m.Port))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DNSMX) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Preference != 0 {
		n += 1 + sovNetcap(uint64(m.Preference))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DNSQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	return n
}

func (m *DHCPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Operation != 0 {
		n += 1 + sovNetcap(uint64(m.Operation))
	}
	if m.HardwareType != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareType))
	}
	if m.HardwareLen != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareLen))
	}
	if m.HardwareOpts != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareOpts))
	}
	if m.Xid != 0 {
		n += 1 + sovNetcap(uint64(m.Xid))
	}
	if m.Secs != 0 {
		n += 1 + sovNetcap(uint64(m.Secs))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	l = len(m.ClientIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.YourClientIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NextServerIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.RelayAgentIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ClientHWAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *DHCPOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DHCPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovNetcap(uint64(m.MsgType))
	}
	if m.HopCount != 0 {
		n += 1 + sovNetcap(uint64(m.HopCount))
	}
	l = len(m.LinkAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *DHCPv6Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNetcap(uint64(m.Code))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.DSAP != 0 {
		n += 1 + sovNetcap(uint64(m.DSAP))
	}
	if m.IG {
		n += 2
	}
	if m.SSAP != 0 {
		n += 1 + sovNetcap(uint64(m.SSAP))
	}
	if m.CR {
		n += 2
	}
	if m.Control != 0 {
		n += 1 + sovNetcap(uint64(m.Control))
	}
	return n
}

func (m *NTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.LeapIndicator != 0 {
		n += 1 + sovNetcap(uint64(m.LeapIndicator))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Mode != 0 {
		n += 1 + sovNetcap(uint64(m.Mode))
	}
	if m.Stratum != 0 {
		n += 1 + sovNetcap(uint64(m.Stratum))
	}
	if m.Poll != 0 {
		n += 1 + sovNetcap(uint64(m.Poll))
	}
	if m.Precision != 0 {
		n += 1 + sovNetcap(uint64(m.Precision))
	}
	if m.RootDelay != 0 {
		n += 1 + sovNetcap(uint64(m.RootDelay))
	}
	if m.RootDispersion != 0 {
		n += 1 + sovNetcap(uint64(m.RootDispersion))
	}
	if m.ReferenceID != 0 {
		n += 1 + sovNetcap(uint64(m.ReferenceID))
	}
	if m.ReferenceTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.ReferenceTimestamp))
	}
	if m.OriginTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.OriginTimestamp))
	}
	if m.ReceiveTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.ReceiveTimestamp))
	}
	if m.TransmitTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.TransmitTimestamp))
	}
	l = len(m.ExtensionBytes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Method != 0 {
		n += 1 + sovNetcap(uint64(m.Method))
	}
	if len(m.Headers) > 0 {
		for _, s := range m.Headers {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.IsResponse {
		n += 2
	}
	if m.ResponseCode != 0 {
		n += 1 + sovNetcap(uint64(m.ResponseCode))
	}
	l = len(m.ResponseStatus)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IGMP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.MaxResponseTime != 0 {
		n += 1 + sovNetcap(uint64(m.MaxResponseTime))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.GroupAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SupressRouterProcessing {
		n += 2
	}
	if m.RobustnessValue != 0 {
		n += 1 + sovNetcap(uint64(m.RobustnessValue))
	}
	if m.IntervalTime != 0 {
		n += 1 + sovNetcap(uint64(m.IntervalTime))
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.NumberOfGroupRecords != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfGroupRecords))
	}
	if m.NumberOfSources != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfSources))
	}
	if len(m.GroupRecords) > 0 {
		for _, e := range m.GroupRecords {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	return n
}

func (m *IGMPv3GroupRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.AuxDataLen != 0 {
		n += 1 + sovNetcap(uint64(m.AuxDataLen))
	}
	if m.NumberOfSources != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfSources))
	}
	l = len(m.MulticastAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *IPv6HopByHop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *IPv6HopByHopOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	if m.ActualLength != 0 {
		n += 1 + sovNetcap(uint64(m.ActualLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.OptionAlignment != nil {
		l = m.OptionAlignment.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6HopByHopOptionAlignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.One != 0 {
		n += 1 + sovNetcap(uint64(m.One))
	}
	if m.Two != 0 {
		n += 1 + sovNetcap(uint64(m.Two))
	}
	return n
}

func (m *SNAP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.OrganizationalCode)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	return n
}

func (m *ICMPv6Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Identifier != 0 {
		n += 1 + sovNetcap(uint64(m.Identifier))
	}
	if m.SeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SeqNumber))
	}
	return n
}

func (m *ICMPv6NeighborSolicitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *ICMPv6RouterSolicitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *HTTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Referer)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.ReqCookies) > 0 {
		for _, s := range m.ReqCookies {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.ReqContentLength != 0 {
		n += 1 + sovNetcap(uint64(m.ReqContentLength))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ResContentLength != 0 {
		n += 1 + sovNetcap(uint64(m.ResContentLength))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovNetcap(uint64(m.StatusCode))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *TLSClientHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.MessageLen != 0 {
		n += 1 + sovNetcap(uint64(m.MessageLen))
	}
	if m.HandshakeType != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeType))
	}
	if m.HandshakeLen != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeLen))
	}
	if m.HandshakeVersion != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeVersion))
	}
	l = len(m.Random)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SessionIDLen != 0 {
		n += 1 + sovNetcap(uint64(m.SessionIDLen))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CipherSuiteLen != 0 {
		n += 1 + sovNetcap(uint64(m.CipherSuiteLen))
	}
	if m.ExtensionLen != 0 {
		n += 1 + sovNetcap(uint64(m.ExtensionLen))
	}
	l = len(m.SNI)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.OSCP {
		n += 2
	}
	if len(m.CipherSuites) > 0 {
		l = 0
		for _, e := range m.CipherSuites {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	if len(m.CompressMethods) > 0 {
		l = 0
		for _, e := range m.CompressMethods {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SignatureAlgs) > 0 {
		l = 0
		for _, e := range m.SignatureAlgs {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SupportedGroups) > 0 {
		l = 0
		for _, e := range m.SupportedGroups {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SupportedPoints) > 0 {
		l = 0
		for _, e := range m.SupportedPoints {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.ALPNs) > 0 {
		for _, s := range m.ALPNs {
			l = len(s)
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Ja3)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	if len(m.Extensions) > 0 {
		l = 0
		for _, e := range m.Extensions {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *IPSecAH) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Reserved != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved))
	}
	if m.SPI != 0 {
		n += 1 + sovNetcap(uint64(m.SPI))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	l = len(m.AuthenticationData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPSecESP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SPI != 0 {
		n += 1 + sovNetcap(uint64(m.SPI))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	if m.LenEncrypted != 0 {
		n += 1 + sovNetcap(uint64(m.LenEncrypted))
	}
	return n
}

func (m *Geneve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.OptionsLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionsLength))
	}
	if m.OAMPacket {
		n += 2
	}
	if m.CriticalOption {
		n += 2
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.VNI != 0 {
		n += 1 + sovNetcap(uint64(m.VNI))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *GeneveOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *VXLAN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ValidIDFlag {
		n += 2
	}
	if m.VNI != 0 {
		n += 1 + sovNetcap(uint64(m.VNI))
	}
	if m.GBPExtension {
		n += 2
	}
	if m.GBPDontLearn {
		n += 2
	}
	if m.GBPApplied {
		n += 2
	}
	if m.GBPGroupPolicyID != 0 {
		n += 1 + sovNetcap(uint64(m.GBPGroupPolicyID))
	}
	return n
}

func (m *USB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.EventType != 0 {
		n += 1 + sovNetcap(uint64(m.EventType))
	}
	if m.TransferType != 0 {
		n += 1 + sovNetcap(uint64(m.TransferType))
	}
	if m.Direction != 0 {
		n += 1 + sovNetcap(uint64(m.Direction))
	}
	if m.EndpointNumber != 0 {
		n += 1 + sovNetcap(uint64(m.EndpointNumber))
	}
	if m.DeviceAddress != 0 {
		n += 1 + sovNetcap(uint64(m.DeviceAddress))
	}
	if m.BusID != 0 {
		n += 1 + sovNetcap(uint64(m.BusID))
	}
	if m.TimestampSec != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampSec))
	}
	if m.TimestampUsec != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampUsec))
	}
	if m.Setup {
		n += 2
	}
	if m.Data {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	if m.UrbLength != 0 {
		n += 1 + sovNetcap(uint64(m.UrbLength))
	}
	if m.UrbDataLength != 0 {
		n += 1 + sovNetcap(uint64(m.UrbDataLength))
	}
	if m.UrbInterval != 0 {
		n += 2 + sovNetcap(uint64(m.UrbInterval))
	}
	if m.UrbStartFrame != 0 {
		n += 2 + sovNetcap(uint64(m.UrbStartFrame))
	}
	if m.UrbCopyOfTransferFlags != 0 {
		n += 2 + sovNetcap(uint64(m.UrbCopyOfTransferFlags))
	}
	if m.IsoNumDesc != 0 {
		n += 2 + sovNetcap(uint64(m.IsoNumDesc))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *USBRequestBlockSetup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.RequestType != 0 {
		n += 1 + sovNetcap(uint64(m.RequestType))
	}
	if m.Request != 0 {
		n += 1 + sovNetcap(uint64(m.Request))
	}
	if m.Value != 0 {
		n += 1 + sovNetcap(uint64(m.Value))
	}
	if m.Index != 0 {
		n += 1 + sovNetcap(uint64(m.Index))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	return n
}

func (m *LCM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Magic != 0 {
		n += 1 + sovNetcap(uint64(m.Magic))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	if m.FragmentOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentOffset))
	}
	if m.FragmentNumber != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentNumber))
	}
	if m.TotalFragments != 0 {
		n += 1 + sovNetcap(uint64(m.TotalFragments))
	}
	l = len(m.ChannelName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Fragmented {
		n += 2
	}
	return n
}

func (m *MPLS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Label != 0 {
		n += 1 + sovNetcap(uint64(m.Label))
	}
	if m.TrafficClass != 0 {
		n += 1 + sovNetcap(uint64(m.TrafficClass))
	}
	if m.StackBottom {
		n += 2
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	return n
}

func (m *ModbusTCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TransactionIdentifier != 0 {
		n += 1 + sovNetcap(uint64(m.TransactionIdentifier))
	}
	if m.ProtocolIdentifier != 0 {
		n += 1 + sovNetcap(uint64(m.ProtocolIdentifier))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.UnitIdentifier != 0 {
		n += 1 + sovNetcap(uint64(m.UnitIdentifier))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *OSPFv2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.PacketLength != 0 {
		n += 1 + sovNetcap(uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		n += 1 + sovNetcap(uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		n += 1 + sovNetcap(uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.AuType != 0 {
		n += 1 + sovNetcap(uint64(m.AuType))
	}
	if m.Authentication != 0 {
		n += 1 + sovNetcap(uint64(m.Authentication))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.LSU != nil {
		l = m.LSU.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSR) > 0 {
		for _, e := range m.LSR {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.DbDesc != nil {
		l = m.DbDesc.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HelloV2 != nil {
		l = m.HelloV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *HelloPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		n += 1 + sovNetcap(uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		l = 0
		for _, e := range m.NeighborID {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *HelloPkgV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		n += 1 + sovNetcap(uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		l = 0
		for _, e := range m.NeighborID {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	if m.NetworkMask != 0 {
		n += 1 + sovNetcap(uint64(m.NetworkMask))
	}
	return n
}

func (m *DbDescPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.InterfaceMTU != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceMTU))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.DDSeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.DDSeqNumber))
	}
	if len(m.LSAinfo) > 0 {
		for _, e := range m.LSAinfo {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *OSPFv3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.PacketLength != 0 {
		n += 1 + sovNetcap(uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		n += 1 + sovNetcap(uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		n += 1 + sovNetcap(uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Instance != 0 {
		n += 1 + sovNetcap(uint64(m.Instance))
	}
	if m.Reserved != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved))
	}
	if m.Hello != nil {
		l = m.Hello.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.DbDesc != nil {
		l = m.DbDesc.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSR) > 0 {
		for _, e := range m.LSR {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.LSU != nil {
		l = m.LSU.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LSAheader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LSAge != 0 {
		n += 1 + sovNetcap(uint64(m.LSAge))
	}
	if m.LSType != 0 {
		n += 1 + sovNetcap(uint64(m.LSType))
	}
	if m.LinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.LinkStateID))
	}
	if m.AdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.AdvRouter))
	}
	if m.LSSeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.LSSeqNumber))
	}
	if m.LSChecksum != 0 {
		n += 1 + sovNetcap(uint64(m.LSChecksum))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.LSOptions != 0 {
		n += 1 + sovNetcap(uint64(m.LSOptions))
	}
	return n
}

func (m *LSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.RLSAV2 != nil {
		l = m.RLSAV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ASELSAV2 != nil {
		l = m.ASELSAV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.RLSA != nil {
		l = m.RLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NLSA != nil {
		l = m.NLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.InterAPrefixLSA != nil {
		l = m.InterAPrefixLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.IARouterLSA != nil {
		l = m.IARouterLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ASELSA != nil {
		l = m.ASELSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.LLSA != nil {
		l = m.LLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.IntraAPrefixLSA != nil {
		l = m.IntraAPrefixLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LSType != 0 {
		n += 1 + sovNetcap(uint64(m.LSType))
	}
	if m.LSID != 0 {
		n += 1 + sovNetcap(uint64(m.LSID))
	}
	if m.AdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.AdvRouter))
	}
	return n
}

func (m *LSUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfLSAs != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfLSAs))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *IntraAreaPrefixLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfPrefixes != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfPrefixes))
	}
	if m.RefLSType != 0 {
		n += 1 + sovNetcap(uint64(m.RefLSType))
	}
	if m.RefLinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.RefLinkStateID))
	}
	if m.RefAdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.RefAdvRouter))
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *ASExternalLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	if m.RefLSType != 0 {
		n += 1 + sovNetcap(uint64(m.RefLSType))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ForwardingAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ExternalRouteTag != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalRouteTag))
	}
	if m.RefLinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.RefLinkStateID))
	}
	return n
}

func (m *InterAreaPrefixLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *InterAreaRouterLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.DestinationRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DestinationRouterID))
	}
	return n
}

func (m *ASExternalLSAV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkMask != 0 {
		n += 1 + sovNetcap(uint64(m.NetworkMask))
	}
	if m.ExternalBit != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalBit))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.ForwardingAddress != 0 {
		n += 1 + sovNetcap(uint64(m.ForwardingAddress))
	}
	if m.ExternalRouteTag != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalRouteTag))
	}
	return n
}

func (m *RouterLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.NeighborInterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.NeighborInterfaceID))
	}
	if m.NeighborRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.NeighborRouterID))
	}
	return n
}

func (m *RouterLSAV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Links != 0 {
		n += 1 + sovNetcap(uint64(m.Links))
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *RouterV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.LinkID != 0 {
		n += 1 + sovNetcap(uint64(m.LinkID))
	}
	if m.LinkData != 0 {
		n += 1 + sovNetcap(uint64(m.LinkData))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	return n
}

func (m *NetworkLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if len(m.AttachedRouter) > 0 {
		l = 0
		for _, e := range m.AttachedRouter {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *LinkLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	l = len(m.LinkLocalAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NumOfPrefixes != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfPrefixes))
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LSAPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *BFD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Diagnostic != 0 {
		n += 1 + sovNetcap(uint64(m.Diagnostic))
	}
	if m.State != 0 {
		n += 1 + sovNetcap(uint64(m.State))
	}
	if m.Poll {
		n += 2
	}
	if m.Final {
		n += 2
	}
	if m.ControlPlaneIndependent {
		n += 2
	}
	if m.AuthPresent {
		n += 2
	}
	if m.Demand {
		n += 2
	}
	if m.Multipoint {
		n += 2
	}
	if m.DetectMultiplier != 0 {
		n += 1 + sovNetcap(uint64(m.DetectMultiplier))
	}
	if m.MyDiscriminator != 0 {
		n += 1 + sovNetcap(uint64(m.MyDiscriminator))
	}
	if m.YourDiscriminator != 0 {
		n += 1 + sovNetcap(uint64(m.YourDiscriminator))
	}
	if m.DesiredMinTxInterval != 0 {
		n += 1 + sovNetcap(uint64(m.DesiredMinTxInterval))
	}
	if m.RequiredMinRxInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RequiredMinRxInterval))
	}
	if m.RequiredMinEchoRxInterval != 0 {
		n += 2 + sovNetcap(uint64(m.RequiredMinEchoRxInterval))
	}
	if m.AuthHeader != nil {
		l = m.AuthHeader.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *BFDAuthHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthType != 0 {
		n += 1 + sovNetcap(uint64(m.AuthType))
	}
	if m.KeyID != 0 {
		n += 1 + sovNetcap(uint64(m.KeyID))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *GRE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ChecksumPresent {
		n += 2
	}
	if m.RoutingPresent {
		n += 2
	}
	if m.KeyPresent {
		n += 2
	}
	if m.SeqPresent {
		n += 2
	}
	if m.StrictSourceRoute {
		n += 2
	}
	if m.AckPresent {
		n += 2
	}
	if m.RecursionControl != 0 {
		n += 1 + sovNetcap(uint64(m.RecursionControl))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Offset != 0 {
		n += 1 + sovNetcap(uint64(m.Offset))
	}
	if m.Key != 0 {
		n += 1 + sovNetcap(uint64(m.Key))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	if m.Ack != 0 {
		n += 2 + sovNetcap(uint64(m.Ack))
	}
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *GRERouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressFamily != 0 {
		n += 1 + sovNetcap(uint64(m.AddressFamily))
	}
	if m.SREOffset != 0 {
		n += 1 + sovNetcap(uint64(m.SREOffset))
	}
	if m.SRELength != 0 {
		n += 1 + sovNetcap(uint64(m.SRELength))
	}
	l = len(m.RoutingInformation)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *FDDI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.FrameControl != 0 {
		n += 1 + sovNetcap(uint64(m.FrameControl))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EAP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovNetcap(uint64(m.Code))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.TypeData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EAPOL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	return n
}

func (m *EAPOLKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.KeyDescriptorType != 0 {
		n += 1 + sovNetcap(uint64(m.KeyDescriptorType))
	}
	if m.KeyDescriptorVersion != 0 {
		n += 1 + sovNetcap(uint64(m.KeyDescriptorVersion))
	}
	if m.KeyType != 0 {
		n += 1 + sovNetcap(uint64(m.KeyType))
	}
	if m.KeyIndex != 0 {
		n += 1 + sovNetcap(uint64(m.KeyIndex))
	}
	if m.Install {
		n += 2
	}
	if m.KeyACK {
		n += 2
	}
	if m.KeyMIC {
		n += 2
	}
	if m.Secure {
		n += 2
	}
	if m.MICError {
		n += 2
	}
	if m.Request {
		n += 2
	}
	if m.HasEncryptedKeyData {
		n += 2
	}
	if m.SMKMessage {
		n += 2
	}
	if m.KeyLength != 0 {
		n += 1 + sovNetcap(uint64(m.KeyLength))
	}
	if m.ReplayCounter != 0 {
		n += 1 + sovNetcap(uint64(m.ReplayCounter))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.IV)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.RSC != 0 {
		n += 2 + sovNetcap(uint64(m.RSC))
	}
	if m.ID != 0 {
		n += 2 + sovNetcap(uint64(m.ID))
	}
	l = len(m.MIC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.KeyDataLength != 0 {
		n += 2 + sovNetcap(uint64(m.KeyDataLength))
	}
	l = len(m.EncryptedKeyData)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *VRRPv2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.VirtualRtrID != 0 {
		n += 1 + sovNetcap(uint64(m.VirtualRtrID))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.CountIPAddr != 0 {
		n += 1 + sovNetcap(uint64(m.CountIPAddr))
	}
	if m.AuthType != 0 {
		n += 1 + sovNetcap(uint64(m.AuthType))
	}
	if m.AdverInt != 0 {
		n += 1 + sovNetcap(uint64(m.AdverInt))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if len(m.IPAddress) > 0 {
		for _, s := range m.IPAddress {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *CiscoDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *CiscoDiscoveryValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPVLANDialogue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.VLAN != 0 {
		n += 1 + sovNetcap(uint64(m.VLAN))
	}
	return n
}

func (m *CDPLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPPowerDialogue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.MgmtID != 0 {
		n += 1 + sovNetcap(uint64(m.MgmtID))
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *CDPSparePairPoE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PSEFourWire {
		n += 2
	}
	if m.PDArchShared {
		n += 2
	}
	if m.PDRequestOn {
		n += 2
	}
	if m.PSEOn {
		n += 2
	}
	return n
}

func (m *CiscoDiscoveryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CDPHello != nil {
		l = m.CDPHello.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.PortID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Capabilities != nil {
		l = m.Capabilities.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.IPPrefixes) > 0 {
		for _, e := range m.IPPrefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.VTPDomain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NativeVLAN != 0 {
		n += 1 + sovNetcap(uint64(m.NativeVLAN))
	}
	if m.FullDuplex {
		n += 2
	}
	if m.VLANReply != nil {
		l = m.VLANReply.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.VLANQuery != nil {
		l = m.VLANQuery.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PowerConsumption != 0 {
		n += 1 + sovNetcap(uint64(m.PowerConsumption))
	}
	if m.MTU != 0 {
		n += 2 + sovNetcap(uint64(m.MTU))
	}
	if m.ExtendedTrust != 0 {
		n += 2 + sovNetcap(uint64(m.ExtendedTrust))
	}
	if m.UntrustedCOS != 0 {
		n += 2 + sovNetcap(uint64(m.UntrustedCOS))
	}
	l = len(m.SysName)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysOID)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.MgmtAddresses) > 0 {
		for _, s := range m.MgmtAddresses {
			l = len(s)
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.PowerRequest != nil {
		l = m.PowerRequest.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.PowerAvailable != nil {
		l = m.PowerAvailable.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SparePairPoe != nil {
		l = m.SparePairPoe.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.EnergyWise != nil {
		l = m.EnergyWise.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.Unknown) > 0 {
		for _, e := range m.Unknown {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *CDPHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OUI)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ProtocolID != 0 {
		n += 1 + sovNetcap(uint64(m.ProtocolID))
	}
	l = len(m.ClusterMaster)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Unknown1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.SubVersion != 0 {
		n += 1 + sovNetcap(uint64(m.SubVersion))
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	if m.Unknown2 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown2))
	}
	l = len(m.ClusterCommander)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SwitchMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown3 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown3))
	}
	if m.ManagementVLAN != 0 {
		n += 1 + sovNetcap(uint64(m.ManagementVLAN))
	}
	return n
}

func (m *CDPEnergyWise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown1 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown1))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	l = len(m.ModelNumber)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown2 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown2))
	}
	l = len(m.HardwareID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Unknown3)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown2)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown3)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L3Router {
		n += 2
	}
	if m.TBBridge {
		n += 2
	}
	if m.SPBridge {
		n += 2
	}
	if m.L2Switch {
		n += 2
	}
	if m.IsHost {
		n += 2
	}
	if m.IGMPFilter {
		n += 2
	}
	if m.L1Repeater {
		n += 2
	}
	if m.IsPhone {
		n += 2
	}
	if m.RemotelyManaged {
		n += 2
	}
	return n
}

func (m *IPNet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IPMask)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *NortelDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SegmentID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Chassis != 0 {
		n += 1 + sovNetcap(uint64(m.Chassis))
	}
	if m.Backplane != 0 {
		n += 1 + sovNetcap(uint64(m.Backplane))
	}
	if m.State != 0 {
		n += 1 + sovNetcap(uint64(m.State))
	}
	if m.NumLinks != 0 {
		n += 1 + sovNetcap(uint64(m.NumLinks))
	}
	return n
}

func sovNetcap(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNetcap(x uint64) (n int) {
	return sovNetcap(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsPayloads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsPayloads = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsPayloads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsPayloads = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampFirst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPayloadSize", wireType)
			}
			m.AppPayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampLast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampFirst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPayloadSize", wireType)
			}
			m.AppPayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampLast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampFirst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampLast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampFirst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampLast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransportFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransportFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransportFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampFirst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampLast = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ethernet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ethernet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ethernet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetType", wireType)
			}
			m.EthernetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ARP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ARP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ARP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwAddressSize", wireType)
			}
			m.HwAddressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwAddressSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtAddressSize", wireType)
			}
			m.ProtAddressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtAddressSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcHwAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcHwAddress = append(m.SrcHwAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcHwAddress == nil {
				m.SrcHwAddress = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcProtAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcProtAddress = append(m.SrcProtAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcProtAddress == nil {
				m.SrcProtAddress = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstHwAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstHwAddress = append(m.DstHwAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DstHwAddress == nil {
				m.DstHwAddress = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstProtAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstProtAddress = append(m.DstProtAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DstProtAddress == nil {
				m.DstProtAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot1Q) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot1Q: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot1Q: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropEligible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropEligible = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANIdentifier", wireType)
			}
			m.VLANIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VLANIdentifier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationID", wireType)
			}
			m.DurationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentNumber", wireType)
			}
			m.FragmentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QOS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QOS == nil {
				m.QOS = &Dot11QOS{}
			}
			if err := m.QOS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTControl == nil {
				m.HTControl = &Dot11HTControl{}
			}
			if err := m.HTControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11QOS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11QOS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11QOS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TID", wireType)
			}
			m.TID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EOSP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EOSP = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckPolicy", wireType)
			}
			m.AckPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckPolicy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TXOP", wireType)
			}
			m.TXOP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TXOP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACConstraint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ACConstraint = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDGMorePPDU", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RDGMorePPDU = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VHT == nil {
				m.VHT = &Dot11HTControlVHT{}
			}
			if err := m.VHT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HT == nil {
				m.HT = &Dot11HTControlHT{}
			}
			if err := m.HT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlVHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlVHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlVHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MRQ = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsolicitedMFB", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnsolicitedMFB = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSI", wireType)
			}
			m.MSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MSI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFB == nil {
				m.MFB = &Dot11HTControlMFB{}
			}
			if err := m.MFB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedMSI", wireType)
			}
			m.CompressedMSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressedMSI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field STBCIndication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.STBCIndication = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFSI", wireType)
			}
			m.MFSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFSI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			m.GID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingType", wireType)
			}
			m.CodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FbTXBeamformed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FbTXBeamformed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAdapationControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkAdapationControl == nil {
				m.LinkAdapationControl = &Dot11LinkAdapationControl{}
			}
			if err := m.LinkAdapationControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalibrationPosition", wireType)
			}
			m.CalibrationPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CalibrationPosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalibrationSequence", wireType)
			}
			m.CalibrationSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CalibrationSequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSISteering", wireType)
			}
			m.CSISteering = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CSISteering |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDPAnnouncement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NDPAnnouncement = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEI", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEI = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlMFB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlMFB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlMFB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSTS", wireType)
			}
			m.NumSTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSTS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHTMCS", wireType)
			}
			m.VHTMCS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VHTMCS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BW", wireType)
			}
			m.BW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BW |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			m.SNR = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SNR |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11LinkAdapationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11LinkAdapationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11LinkAdapationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TRQ = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MRQ = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSI", wireType)
			}
			m.MSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MSI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFSI", wireType)
			}
			m.MFSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFSI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASEL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASEL == nil {
				m.ASEL = &Dot11ASEL{}
			}
			if err := m.ASEL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFB", wireType)
			}
			m.MFB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFB |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11ASEL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11ASEL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11ASEL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Data |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChassisID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChassisID == nil {
				m.ChassisID = &LLDPChassisID{}
			}
			if err := m.ChassisID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortID == nil {
				m.PortID = &LLDPPortID{}
			}
			if err := m.PortID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &LinkLayerDiscoveryValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPChassisID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPChassisID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPChassisID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPPortID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPPortID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPPortID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscoveryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscoveryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscoveryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetCTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetCTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetCTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCount", wireType)
			}
			m.SkipCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetCTPReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetCTPReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetCTPReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			m.Function = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Function |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptNumber", wireType)
			}
			m.ReceiptNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiptNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscoveryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SysCapabilities == nil {
				m.SysCapabilities = &LLDPSysCapabilities{}
			}
			if err := m.SysCapabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtAddress == nil {
				m.MgmtAddress = &LLDPMgmtAddress{}
			}
			if err := m.MgmtAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgTLVs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgTLVs = append(m.OrgTLVs, &LLDPOrgSpecificTLV{})
			if err := m.OrgTLVs[len(m.OrgTLVs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown = append(m.Unknown, &LinkLayerDiscoveryValue{})
			if err := m.Unknown[len(m.Unknown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPSysCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPSysCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPSysCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemCap == nil {
				m.SystemCap = &LLDPCapabilities{}
			}
			if err := m.SystemCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnabledCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnabledCap == nil {
				m.EnabledCap = &LLDPCapabilities{}
			}
			if err := m.EnabledCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Other = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Repeater = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bridge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WLANAP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WLANAP = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Router = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Phone = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocSis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DocSis = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StationOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StationOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CVLAN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CVLAN = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVLAN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SVLAN = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TMPR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TMPR = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPMgmtAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPMgmtAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPMgmtAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceSubtype", wireType)
			}
			m.InterfaceSubtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceSubtype |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceNumber", wireType)
			}
			m.InterfaceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPOrgSpecificTLV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPOrgSpecificTLV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPOrgSpecificTLV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUI", wireType)
			}
			m.OUI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OUI |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info[:0], dAtA[iNdEx:postIndex]...)
			if m.Info == nil {
				m.Info = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IHL", wireType)
			}
			m.IHL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IHL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOS", wireType)
			}
			m.TOS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TOS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragOffset", wireType)
			}
			m.FragOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Padding = append(m.Padding[:0], dAtA[iNdEx:postIndex]...)
			if m.Padding == nil {
				m.Padding = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &IPv4Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLabel", wireType)
			}
			m.FlowLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowLabel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHeader", wireType)
			}
			m.NextHeader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHeader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopLimit", wireType)
			}
			m.HopLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopByHop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HopByHop == nil {
				m.HopByHop = &IPv6HopByHop{}
			}
			if err := m.HopByHop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHeader", wireType)
			}
			m.NextHeader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHeader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentOffset", wireType)
			}
			m.FragmentOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved2", wireType)
			}
			m.Reserved2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreFragments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MoreFragments = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identification", wireType)
			}
			m.Identification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identification |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			m.TypeCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			m.TypeCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6NeighborAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6NeighborAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6NeighborAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6RouterAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6RouterAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6RouterAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopLimit", wireType)
			}
			m.HopLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterLifetime", wireType)
			}
			m.RouterLifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterLifetime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReachableTime", wireType)
			}
			m.ReachableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReachableTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTimer", wireType)
			}
			m.RetransTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTimer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckNum", wireType)
			}
			m.AckNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataOffset", wireType)
			}
			m.DataOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FIN = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SYN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SYN = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RST", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RST = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSH", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSH = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ACK = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.URG = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ECE", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ECE = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CWR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CWR = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Window", wireType)
			}
			m.Window = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Window |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urgent", wireType)
			}
			m.Urgent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Urgent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Padding = append(m.Padding[:0], dAtA[iNdEx:postIndex]...)
			if m.Padding == nil {
				m.Padding = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &TCPOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationTag", wireType)
			}
			m.VerificationTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QR = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AA", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AA = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TC = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RD = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RA", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RA = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QDCount", wireType)
			}
			m.QDCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QDCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ANCount", wireType)
			}
			m.ANCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ANCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NSCount", wireType)
			}
			m.NSCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NSCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ARCount", wireType)
			}
			m.ARCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ARCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &DNSQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answers = append(m.Answers, &DNSResourceRecord{})
			if err := m.Answers[len(m.Answers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authorities = append(m.Authorities, &DNSResourceRecord{})
			if err := m.Authorities[len(m.Authorities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additionals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Additionals = append(m.Additionals, &DNSResourceRecord{})
			if err := m.Additionals[len(m.Additionals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSResourceRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSResourceRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSResourceRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NS = append(m.NS[:0], dAtA[iNdEx:postIndex]...)
			if m.NS == nil {
				m.NS = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNAME", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CNAME = append(m.CNAME[:0], dAtA[iNdEx:postIndex]...)
			if m.CNAME == nil {
				m.CNAME = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PTR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PTR = append(m.PTR[:0], dAtA[iNdEx:postIndex]...)
			if m.PTR == nil {
				m.PTR = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SOA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SOA == nil {
				m.SOA = &DNSSOA{}
			}
			if err := m.SOA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SRV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SRV == nil {
				m.SRV = &DNSSRV{}
			}
			if err := m.SRV.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MX", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MX == nil {
				m.MX = &DNSMX{}
			}
			if err := m.MX.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TXTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TXTs = append(m.TXTs, make([]byte, postIndex-iNdEx))
			copy(m.TXTs[len(m.TXTs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSSOA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSSOA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSSOA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MName = append(m.MName[:0], dAtA[iNdEx:postIndex]...)
			if m.MName == nil {
				m.MName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RName = append(m.RName[:0], dAtA[iNdEx:postIndex]...)
			if m.RName == nil {
				m.RName = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			m.Serial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Serial |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			m.Refresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refresh |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			m.Minimum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minimum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSSRV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSSRV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSSRV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSMX) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSMX: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSMX: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preference", wireType)
			}
			m.Preference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Preference |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareType", wireType)
			}
			m.HardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareLen", wireType)
			}
			m.HardwareLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareOpts", wireType)
			}
			m.HardwareOpts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareOpts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xid", wireType)
			}
			m.Xid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secs", wireType)
			}
			m.Secs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Secs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YourClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextServerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextServerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayAgentIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayAgentIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientHWAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientHWAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = append(m.ServerName[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerName == nil {
				m.ServerName = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File[:0], dAtA[iNdEx:postIndex]...)
			if m.File == nil {
				m.File = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &DHCPOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopCount", wireType)
			}
			m.HopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = append(m.TransactionID[:0], dAtA[iNdEx:postIndex]...)
			if m.TransactionID == nil {
				m.TransactionID = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &DHCPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv6Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv6Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv6Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSAP", wireType)
			}
			m.DSAP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSAP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IG = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSAP", wireType)
			}
			m.SSAP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSAP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CR = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			m.Control = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Control |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeapIndicator", wireType)
			}
			m.LeapIndicator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeapIndicator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stratum", wireType)
			}
			m.Stratum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stratum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			m.Poll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Poll |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootDelay", wireType)
			}
			m.RootDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootDelay |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootDispersion", wireType)
			}
			m.RootDispersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootDispersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceID", wireType)
			}
			m.ReferenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceTimestamp", wireType)
			}
			m.ReferenceTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestamp", wireType)
			}
			m.OriginTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveTimestamp", wireType)
			}
			m.ReceiveTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmitTimestamp", wireType)
			}
			m.TransmitTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransmitTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionBytes = append(m.ExtensionBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtensionBytes == nil {
				m.ExtensionBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsResponse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IGMP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IGMP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IGMP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResponseTime", wireType)
			}
			m.MaxResponseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResponseTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAddress = append(m.GroupAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAddress == nil {
				m.GroupAddress = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupressRouterProcessing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupressRouterProcessing = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobustnessValue", wireType)
			}
			m.RobustnessValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobustnessValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalTime", wireType)
			}
			m.IntervalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddresses = append(m.SourceAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGroupRecords", wireType)
			}
			m.NumberOfGroupRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGroupRecords |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSources", wireType)
			}
			m.NumberOfSources = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSources |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupRecords = append(m.GroupRecords, &IGMPv3GroupRecord{})
			if err := m.GroupRecords[len(m.GroupRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IGMPv3GroupRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IGMPv3GroupRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IGMPv3GroupRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuxDataLen", wireType)
			}
			m.AuxDataLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuxDataLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSources", wireType)
			}
			m.NumberOfSources = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSources |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MulticastAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MulticastAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddresses = append(m.SourceAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &IPv6HopByHopOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHopOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHopOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHopOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualLength", wireType)
			}
			m.ActualLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionAlignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionAlignment == nil {
				m.OptionAlignment = &IPv6HopByHopOptionAlignment{}
			}
			if err := m.OptionAlignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHopOptionAlignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHopOptionAlignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHopOptionAlignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field One", wireType)
			}
			m.One = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.One |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Two", wireType)
			}
			m.Two = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Two |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNAP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNAP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNAP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalCode = append(m.OrganizationalCode[:0], dAtA[iNdEx:postIndex]...)
			if m.OrganizationalCode == nil {
				m.OrganizationalCode = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6Echo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6Echo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6Echo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			m.Identifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identifier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumber", wireType)
			}
			m.SeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6NeighborSolicitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6NeighborSolicitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6NeighborSolicitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6RouterSolicitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6RouterSolicitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6RouterSolicitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqCookies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqCookies = append(m.ReqCookies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqContentLength", wireType)
			}
			m.ReqContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqContentLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResContentLength", wireType)
			}
			m.ResContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResContentLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageLen", wireType)
			}
			m.MessageLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeType", wireType)
			}
			m.HandshakeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeLen", wireType)
			}
			m.HandshakeLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeVersion", wireType)
			}
			m.HandshakeVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Random = append(m.Random[:0], dAtA[iNdEx:postIndex]...)
			if m.Random == nil {
				m.Random = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIDLen", wireType)
			}
			m.SessionIDLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionIDLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = append(m.SessionID[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionID == nil {
				m.SessionID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuiteLen", wireType)
			}
			m.CipherSuiteLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CipherSuiteLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionLen", wireType)
			}
			m.ExtensionLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtensionLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSCP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OSCP = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CipherSuites = append(m.CipherSuites, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CipherSuites) == 0 {
					m.CipherSuites = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CipherSuites = append(m.CipherSuites, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompressMethods = append(m.CompressMethods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompressMethods) == 0 {
					m.CompressMethods = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompressMethods = append(m.CompressMethods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressMethods", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SignatureAlgs = append(m.SignatureAlgs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SignatureAlgs) == 0 {
					m.SignatureAlgs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SignatureAlgs = append(m.SignatureAlgs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgs", wireType)
			}
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedGroups = append(m.SupportedGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupportedGroups) == 0 {
					m.SupportedGroups = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedGroups = append(m.SupportedGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedGroups", wireType)
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedPoints = append(m.SupportedPoints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupportedPoints) == 0 {
					m.SupportedPoints = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedPoints = append(m.SupportedPoints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedPoints", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALPNs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ALPNs = append(m.ALPNs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ja3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Extensions = append(m.Extensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Extensions) == 0 {
					m.Extensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Extensions = append(m.Extensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecAH) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecAH: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecAH: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPI", wireType)
			}
			m.SPI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SPI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationData = append(m.AuthenticationData[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthenticationData == nil {
				m.AuthenticationData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecESP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecESP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecESP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPI", wireType)
			}
			m.SPI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SPI |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LenEncrypted", wireType)
			}
			m.LenEncrypted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LenEncrypted |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Geneve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Geneve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Geneve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionsLength", wireType)
			}
			m.OptionsLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionsLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OAMPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OAMPacket = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CriticalOption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CriticalOption = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &GeneveOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneveOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneveOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneveOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VXLAN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VXLAN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VXLAN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidIDFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidIDFlag = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPExtension = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPDontLearn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPDontLearn = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPApplied", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPApplied = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPGroupPolicyID", wireType)
			}
			m.GBPGroupPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GBPGroupPolicyID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferType", wireType)
			}
			m.TransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointNumber", wireType)
			}
			m.EndpointNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAddress", wireType)
			}
			m.DeviceAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceAddress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusID", wireType)
			}
			m.BusID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampSec", wireType)
			}
			m.TimestampSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampSec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUsec", wireType)
			}
			m.TimestampUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampUsec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Setup = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbLength", wireType)
			}
			m.UrbLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbDataLength", wireType)
			}
			m.UrbDataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbDataLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbInterval", wireType)
			}
			m.UrbInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbStartFrame", wireType)
			}
			m.UrbStartFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbStartFrame |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbCopyOfTransferFlags", wireType)
			}
			m.UrbCopyOfTransferFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbCopyOfTransferFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsoNumDesc", wireType)
			}
			m.IsoNumDesc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsoNumDesc |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USBRequestBlockSetup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USBRequestBlockSetup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USBRequestBlockSetup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LCM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LCM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LCM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			m.Magic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentOffset", wireType)
			}
			m.FragmentOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentNumber", wireType)
			}
			m.FragmentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFragments", wireType)
			}
			m.TotalFragments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFragments |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragmented", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fragmented = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MPLS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MPLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MPLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackBottom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StackBottom = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModbusTCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModbusTCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModbusTCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIdentifier", wireType)
			}
			m.TransactionIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIdentifier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolIdentifier", wireType)
			}
			m.ProtocolIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolIdentifier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitIdentifier", wireType)
			}
			m.UnitIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitIdentifier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSPFv2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSPFv2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSPFv2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketLength", wireType)
			}
			m.PacketLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterID", wireType)
			}
			m.RouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaID", wireType)
			}
			m.AreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuType", wireType)
			}
			m.AuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			m.Authentication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Authentication |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSAheader{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LSU == nil {
				m.LSU = &LSUpdate{}
			}
			if err := m.LSU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSR", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSR = append(m.LSR, &LSReq{})
			if err := m.LSR[len(m.LSR)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbDesc == nil {
				m.DbDesc = &DbDescPkg{}
			}
			if err := m.DbDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HelloV2 == nil {
				m.HelloV2 = &HelloPkgV2{}
			}
			if err := m.HelloV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloInterval", wireType)
			}
			m.HelloInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelloInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterDeadInterval", wireType)
			}
			m.RouterDeadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterDeadInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesignatedRouterID", wireType)
			}
			m.DesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesignatedRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupDesignatedRouterID", wireType)
			}
			m.BackupDesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupDesignatedRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NeighborID = append(m.NeighborID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NeighborID) == 0 {
					m.NeighborID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NeighborID = append(m.NeighborID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloPkgV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloPkgV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloPkgV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloInterval", wireType)
			}
			m.HelloInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelloInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterDeadInterval", wireType)
			}
			m.RouterDeadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterDeadInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesignatedRouterID", wireType)
			}
			m.DesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesignatedRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupDesignatedRouterID", wireType)
			}
			m.BackupDesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupDesignatedRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NeighborID = append(m.NeighborID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NeighborID) == 0 {
					m.NeighborID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NeighborID = append(m.NeighborID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborID", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMask", wireType)
			}
			m.NetworkMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDescPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DbDescPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DbDescPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMTU", wireType)
			}
			m.InterfaceMTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceMTU |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDSeqNumber", wireType)
			}
			m.DDSeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DDSeqNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAinfo = append(m.LSAinfo, &LSAheader{})
			if err := m.LSAinfo[len(m.LSAinfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSPFv3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSPFv3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSPFv3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketLength", wireType)
			}
			m.PacketLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterID", wireType)
			}
			m.RouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaID", wireType)
			}
			m.AreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hello == nil {
				m.Hello = &HelloPkg{}
			}
			if err := m.Hello.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbDesc == nil {
				m.DbDesc = &DbDescPkg{}
			}
			if err := m.DbDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSR", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSR = append(m.LSR, &LSReq{})
			if err := m.LSR[len(m.LSR)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LSU == nil {
				m.LSU = &LSUpdate{}
			}
			if err := m.LSU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSAheader{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSAheader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSAheader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSAheader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAge", wireType)
			}
			m.LSAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSAge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSType", wireType)
			}
			m.LSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkStateID", wireType)
			}
			m.LinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkStateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvRouter", wireType)
			}
			m.AdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvRouter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSSeqNumber", wireType)
			}
			m.LSSeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSSeqNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSChecksum", wireType)
			}
			m.LSChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSChecksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSOptions", wireType)
			}
			m.LSOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSOptions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &LSAheader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RLSAV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RLSAV2 == nil {
				m.RLSAV2 = &RouterLSAV2{}
			}
			if err := m.RLSAV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASELSAV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASELSAV2 == nil {
				m.ASELSAV2 = &ASExternalLSAV2{}
			}
			if err := m.ASELSAV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RLSA == nil {
				m.RLSA = &RouterLSA{}
			}
			if err := m.RLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NLSA == nil {
				m.NLSA = &NetworkLSA{}
			}
			if err := m.NLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterAPrefixLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterAPrefixLSA == nil {
				m.InterAPrefixLSA = &InterAreaPrefixLSA{}
			}
			if err := m.InterAPrefixLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IARouterLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IARouterLSA == nil {
				m.IARouterLSA = &InterAreaRouterLSA{}
			}
			if err := m.IARouterLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASELSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASELSA == nil {
				m.ASELSA = &ASExternalLSA{}
			}
			if err := m.ASELSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LLSA == nil {
				m.LLSA = &LinkLSA{}
			}
			if err := m.LLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntraAPrefixLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntraAPrefixLSA == nil {
				m.IntraAPrefixLSA = &IntraAreaPrefixLSA{}
			}
			if err := m.IntraAPrefixLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSType", wireType)
			}
			m.LSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSID", wireType)
			}
			m.LSID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvRouter", wireType)
			}
			m.AdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvRouter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfLSAs", wireType)
			}
			m.NumOfLSAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfLSAs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSA{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntraAreaPrefixLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntraAreaPrefixLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntraAreaPrefixLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPrefixes", wireType)
			}
			m.NumOfPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPrefixes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLSType", wireType)
			}
			m.RefLSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLSType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLinkStateID", wireType)
			}
			m.RefLinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLinkStateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAdvRouter", wireType)
			}
			m.RefAdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAdvRouter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &LSAPrefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ASExternalLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ASExternalLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ASExternalLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLSType", wireType)
			}
			m.RefLSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLSType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingAddress = append(m.ForwardingAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ForwardingAddress == nil {
				m.ForwardingAddress = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRouteTag", wireType)
			}
			m.ExternalRouteTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRouteTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLinkStateID", wireType)
			}
			m.RefLinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLinkStateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterAreaPrefixLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterAreaPrefixLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterAreaPrefixLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterAreaRouterLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterAreaRouterLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterAreaRouterLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRouterID", wireType)
			}
			m.DestinationRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ASExternalLSAV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ASExternalLSAV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ASExternalLSAV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMask", wireType)
			}
			m.NetworkMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalBit", wireType)
			}
			m.ExternalBit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalBit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingAddress", wireType)
			}
			m.ForwardingAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingAddress |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRouteTag", wireType)
			}
			m.ExternalRouteTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRouteTag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &Router{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborInterfaceID", wireType)
			}
			m.NeighborInterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeighborInterfaceID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborRouterID", wireType)
			}
			m.NeighborRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeighborRouterID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterLSAV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterLSAV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterLSAV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			m.Links = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Links |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &RouterV2{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkID", wireType)
			}
			m.LinkID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkData", wireType)
			}
			m.LinkData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkData |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttachedRouter = append(m.AttachedRouter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttachedRouter) == 0 {
					m.AttachedRouter = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttachedRouter = append(m.AttachedRouter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedRouter", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalAddress = append(m.LinkLocalAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.LinkLocalAddress == nil {
				m.LinkLocalAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPrefixes", wireType)
			}
			m.NumOfPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPrefixes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &LSAPrefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSAPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSAPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSAPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostic", wireType)
			}
			m.Diagnostic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diagnostic |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poll = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Final = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneIndependent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlPlaneIndependent = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthPresent = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Demand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Demand = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multipoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multipoint = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectMultiplier", wireType)
			}
			m.DetectMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectMultiplier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyDiscriminator", wireType)
			}
			m.MyDiscriminator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyDiscriminator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourDiscriminator", wireType)
			}
			m.YourDiscriminator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YourDiscriminator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredMinTxInterval", wireType)
			}
			m.DesiredMinTxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredMinTxInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredMinRxInterval", wireType)
			}
			m.RequiredMinRxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredMinRxInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredMinEchoRxInterval", wireType)
			}
			m.RequiredMinEchoRxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredMinEchoRxInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthHeader == nil {
				m.AuthHeader = &BFDAuthHeader{}
			}
			if err := m.AuthHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFDAuthHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFDAuthHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFDAuthHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			m.AuthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			m.KeyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChecksumPresent = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoutingPresent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyPresent = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SeqPresent = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictSourceRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictSourceRoute = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AckPresent = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionControl", wireType)
			}
			m.RecursionControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecursionControl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			m.Ack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ack |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &GRERouting{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRERouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRERouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRERouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			m.AddressFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressFamily |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SREOffset", wireType)
			}
			m.SREOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SREOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SRELength", wireType)
			}
			m.SRELength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SRELength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingInformation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingInformation = append(m.RoutingInformation[:0], dAtA[iNdEx:postIndex]...)
			if m.RoutingInformation == nil {
				m.RoutingInformation = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &GRERouting{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FDDI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FDDI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FDDI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameControl", wireType)
			}
			m.FrameControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameControl |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeData = append(m.TypeData[:0], dAtA[iNdEx:postIndex]...)
			if m.TypeData == nil {
				m.TypeData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAPOL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAPOL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAPOL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAPOLKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAPOLKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAPOLKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDescriptorType", wireType)
			}
			m.KeyDescriptorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDescriptorType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDescriptorVersion", wireType)
			}
			m.KeyDescriptorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDescriptorVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIndex", wireType)
			}
			m.KeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Install", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Install = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyACK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyACK = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyMIC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyMIC = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MICError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MICError = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Request = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEncryptedKeyData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEncryptedKeyData = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SMKMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SMKMessage = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLength", wireType)
			}
			m.KeyLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayCounter", wireType)
			}
			m.ReplayCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayCounter |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IV", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IV = append(m.IV[:0], dAtA[iNdEx:postIndex]...)
			if m.IV == nil {
				m.IV = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSC", wireType)
			}
			m.RSC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RSC |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MIC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MIC = append(m.MIC[:0], dAtA[iNdEx:postIndex]...)
			if m.MIC == nil {
				m.MIC = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDataLength", wireType)
			}
			m.KeyDataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDataLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKeyData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKeyData = append(m.EncryptedKeyData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedKeyData == nil {
				m.EncryptedKeyData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VRRPv2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VRRPv2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VRRPv2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRtrID", wireType)
			}
			m.VirtualRtrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRtrID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIPAddr", wireType)
			}
			m.CountIPAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountIPAddr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			m.AuthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdverInt", wireType)
			}
			m.AdverInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdverInt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = append(m.IPAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CiscoDiscoveryValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscoveryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscoveryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscoveryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPVLANDialogue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPVLANDialogue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPVLANDialogue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLAN", wireType)
			}
			m.VLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VLAN |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPPowerDialogue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPPowerDialogue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPPowerDialogue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtID", wireType)
			}
			m.MgmtID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPSparePairPoE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPSparePairPoE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPSparePairPoE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSEFourWire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSEFourWire = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDArchShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PDArchShared = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDRequestOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PDRequestOn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSEOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSEOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscoveryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CDPHello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CDPHello == nil {
				m.CDPHello = &CDPHello{}
			}
			if err := m.CDPHello.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capabilities == nil {
				m.Capabilities = &CDPCapabilities{}
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPPrefixes = append(m.IPPrefixes, &IPNet{})
			if err := m.IPPrefixes[len(m.IPPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VTPDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VTPDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVLAN", wireType)
			}
			m.NativeVLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVLAN |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullDuplex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullDuplex = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VLANReply == nil {
				m.VLANReply = &CDPVLANDialogue{}
			}
			if err := m.VLANReply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VLANQuery == nil {
				m.VLANQuery = &CDPVLANDialogue{}
			}
			if err := m.VLANQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerConsumption", wireType)
			}
			m.PowerConsumption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerConsumption |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTU", wireType)
			}
			m.MTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTU |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedTrust", wireType)
			}
			m.ExtendedTrust = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtendedTrust |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntrustedCOS", wireType)
			}
			m.UntrustedCOS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntrustedCOS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysOID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysOID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtAddresses = append(m.MgmtAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &CDPLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerRequest == nil {
				m.PowerRequest = &CDPPowerDialogue{}
			}
			if err := m.PowerRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerAvailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerAvailable == nil {
				m.PowerAvailable = &CDPPowerDialogue{}
			}
			if err := m.PowerAvailable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparePairPoe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparePairPoe == nil {
				m.SparePairPoe = &CDPSparePairPoE{}
			}
			if err := m.SparePairPoe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyWise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnergyWise == nil {
				m.EnergyWise = &CDPEnergyWise{}
			}
			if err := m.EnergyWise.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown = append(m.Unknown, &CiscoDiscoveryValue{})
			if err := m.Unknown[len(m.Unknown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUI", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OUI = append(m.OUI[:0], dAtA[iNdEx:postIndex]...)
			if m.OUI == nil {
				m.OUI = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolID", wireType)
			}
			m.ProtocolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterMaster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterMaster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubVersion", wireType)
			}
			m.SubVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown2", wireType)
			}
			m.Unknown2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterCommander", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterCommander = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown3", wireType)
			}
			m.Unknown3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown3 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementVLAN", wireType)
			}
			m.ManagementVLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManagementVLAN |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPEnergyWise) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPEnergyWise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPEnergyWise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedData = append(m.EncryptedData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedData == nil {
				m.EncryptedData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown1", wireType)
			}
			m.Unknown1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown1 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown2", wireType)
			}
			m.Unknown2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown3 = append(m.Unknown3[:0], dAtA[iNdEx:postIndex]...)
			if m.Unknown3 == nil {
				m.Unknown3 = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown1 = append(m.ReplyUnknown1[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown1 == nil {
				m.ReplyUnknown1 = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyPort", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyPort = append(m.ReplyPort[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyPort == nil {
				m.ReplyPort = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyAddress = append(m.ReplyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyAddress == nil {
				m.ReplyAddress = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown2 = append(m.ReplyUnknown2[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown2 == nil {
				m.ReplyUnknown2 = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown3 = append(m.ReplyUnknown3[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown3 == nil {
				m.ReplyUnknown3 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Router", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3Router = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TBBridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TBBridge = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPBridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SPBridge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Switch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L2Switch = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHost = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IGMPFilter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IGMPFilter = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Repeater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1Repeater = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhone = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotelyManaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemotelyManaged = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPNet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPNet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPNet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPMask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NortelDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NortelDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NortelDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentID = append(m.SegmentID[:0], dAtA[iNdEx:postIndex]...)
			if m.SegmentID == nil {
				m.SegmentID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			m.Chassis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chassis |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backplane", wireType)
			}
			m.Backplane = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Backplane |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLinks", wireType)
			}
			m.NumLinks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLinks |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetcap(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNetcap
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNetcap(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNetcap = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetcap   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("netcap.proto", fileDescriptor_netcap_96fb18cb63d9eadb) }

var fileDescriptor_netcap_96fb18cb63d9eadb = []byte{
	// 9196 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5f, 0x8c, 0x24, 0xc9,
	0x99, 0x97, 0xeb, 0x5f, 0x77, 0x55, 0x74, 0x55, 0x4f, 0x4e, 0xce, 0xec, 0x4c, 0xef, 0xec, 0x78,
	0x3c, 0x4e, 0xd6, 0xf6, 0x78, 0xbc, 0x5e, 0xef, 0xf6, 0xac, 0xe7, 0xfc, 0xef, 0x38, 0xaa, 0xab,
	0xba, 0xa7, 0xeb, 0xa6, 0xaa, 0x3a, 0x27, 0xb2, 0xba, 0x77, 0x7d, 0x48, 0xac, 0xb2, 0xab, 0xa2,
	0xbb, 0x93, 0xae, 0xce, 0xac, 0xc9, 0xcc, 0x9a, 0x99, 0xb6, 0x84, 0x04, 0x0f, 0x06, 0xdd, 0x09,
	0x61, 0x38, 0x9f, 0x0e, 0x09, 0xdd, 0x21, 0xf1, 0x82, 0xd0, 0xa1, 0x43, 0x3c, 0xdc, 0x0b, 0x48,
	0xf7, 0x08, 0x3e, 0x21, 0x21, 0x1d, 0x20, 0x24, 0xa4, 0x93, 0x10, 0xd8, 0x4f, 0x87, 0x04, 0x88,
	0x07, 0x84, 0x04, 0x12, 0x42, 0xdf, 0x17, 0x5f, 0x64, 0x46, 0x64, 0x55, 0x4f, 0xf7, 0xee, 0xd9,
	0x96, 0x90, 0xfc, 0x96, 0xdf, 0x2f, 0x22, 0xb3, 0x22, 0xbe, 0xf8, 0xe2, 0xfb, 0x17, 0x7f, 0x8a,
	0x35, 0x43, 0x91, 0x8e, 0xfd, 0xd9, 0xbb, 0xb3, 0x38, 0x4a, 0x23, 0xbb, 0x96, 0x9e, 0xcf, 0x44,
	0xe2, 0xfc, 0xe3, 0x12, 0x5b, 0xd9, 0x15, 0xfe, 0x44, 0xc4, 0xf6, 0x06, 0x5b, 0xed, 0xc4, 0xc2,
	0x4f, 0xc5, 0x64, 0xa3, 0x74, 0xbf, 0xf4, 0xa0, 0xc1, 0x15, 0x69, 0xdf, 0x67, 0x6b, 0xbd, 0x70,
	0x36, 0x4f, 0xbd, 0x68, 0x1e, 0x8f, 0xc5, 0x46, 0x19, 0x4b, 0x75, 0xc8, 0xfe, 0x1c, 0xab, 0x8e,
	0xce, 0x67, 0x62, 0xa3, 0x72, 0xbf, 0xf4, 0x60, 0x7d, 0x73, 0xed, 0x5d, 0xfc, 0xf8, 0xbb, 0x00,
	0x71, 0x2c, 0x80, 0x8f, 0x1f, 0x88, 0x38, 0x09, 0xa2, 0x70, 0xa3, 0x2a, 0x3f, 0x4e, 0xa4, 0xfd,
	0x90, 0x59, 0x9d, 0x28, 0x4c, 0xfd, 0x20, 0x4c, 0x5c, 0xff, 0x7c, 0x1a, 0xf9, 0x93, 0x64, 0xa3,
	0x76, 0xbf, 0xf4, 0xa0, 0xce, 0x17, 0x70, 0xe7, 0x9f, 0x96, 0x58, 0x6d, 0xcb, 0x4f, 0xc7, 0x27,
	0xf6, 0x1d, 0x56, 0xef, 0x4c, 0x03, 0x11, 0xa6, 0xbd, 0x2e, 0xb5, 0x36, 0xa3, 0xed, 0xaf, 0xb2,
	0xb5, 0x81, 0x48, 0x12, 0xff, 0x58, 0x60, 0x9b, 0xca, 0x8b, 0x6d, 0xd2, 0xcb, 0xed, 0xbb, 0xac,
	0x31, 0x8a, 0x52, 0x7f, 0xea, 0x05, 0xdf, 0x93, 0x1d, 0xa8, 0xf1, 0x1c, 0xb0, 0x6d, 0x56, 0xed,
	0xfa, 0xa9, 0x8f, 0xad, 0x6e, 0x72, 0x7c, 0xfe, 0x44, 0x4d, 0xfe, 0x5b, 0x55, 0x56, 0xdd, 0x99,
	0x46, 0x2f, 0xed, 0x2f, 0xb2, 0xf5, 0x51, 0x70, 0x26, 0x92, 0xd4, 0x3f, 0x9b, 0xed, 0x04, 0x71,
	0x92, 0x52, 0xbb, 0x0b, 0x28, 0x34, 0xa7, 0x1f, 0x84, 0xa7, 0x2e, 0x8c, 0x12, 0xb1, 0x3a, 0x07,
	0x6c, 0x87, 0x35, 0x87, 0x22, 0x7d, 0x19, 0xc5, 0x54, 0xa1, 0x82, 0x15, 0x0c, 0x0c, 0x7f, 0x29,
	0xf6, 0xc3, 0x64, 0x16, 0xc5, 0xa9, 0xac, 0x55, 0xa5, 0x5f, 0x32, 0x50, 0xe8, 0x46, 0x7b, 0x36,
	0x9b, 0x06, 0x63, 0x3f, 0x0d, 0xa2, 0x50, 0xd6, 0xac, 0x61, 0xcd, 0x05, 0xdc, 0xbe, 0xc5, 0x56,
	0xbc, 0x78, 0x3c, 0x68, 0x77, 0x36, 0x56, 0xb0, 0x06, 0x51, 0x80, 0x77, 0x93, 0x14, 0xf0, 0x55,
	0x89, 0x4b, 0xca, 0xbe, 0xc9, 0x6a, 0x5e, 0x3c, 0xee, 0xb9, 0x1b, 0x75, 0x84, 0x25, 0x01, 0x52,
	0xe0, 0xc5, 0x63, 0x37, 0x8a, 0xd3, 0x8d, 0x86, 0x94, 0x02, 0x22, 0xa1, 0x7e, 0x37, 0x49, 0x7b,
	0xee, 0x06, 0x93, 0xf5, 0x91, 0x80, 0xfa, 0xdd, 0x24, 0xc5, 0xfa, 0x6b, 0xb2, 0x3e, 0x91, 0xe6,
	0xa0, 0x35, 0x8b, 0x83, 0xf6, 0x45, 0xb6, 0xde, 0x9e, 0xcd, 0x68, 0x0c, 0xb0, 0x4a, 0x0b, 0xab,
	0x14, 0x50, 0xfb, 0x1e, 0x63, 0xc3, 0xf9, 0x99, 0xeb, 0x8f, 0x4f, 0x45, 0x9a, 0x6c, 0xac, 0x63,
	0x1d, 0x0d, 0xb1, 0x2d, 0x56, 0xd9, 0xef, 0x75, 0x37, 0xae, 0xe1, 0x6f, 0xc3, 0xa3, 0xfd, 0x36,
	0x6b, 0x65, 0xe3, 0xd5, 0xf7, 0x93, 0x74, 0xc3, 0xc2, 0x32, 0x13, 0x04, 0xe9, 0xec, 0xce, 0x63,
	0x64, 0xdf, 0xc6, 0xf5, 0xfb, 0xa5, 0x07, 0x15, 0x9e, 0xd1, 0xce, 0x6f, 0x55, 0x19, 0xeb, 0x44,
	0x61, 0x28, 0xc6, 0x40, 0xfe, 0x42, 0x2c, 0x7e, 0x21, 0x16, 0x28, 0x16, 0xbf, 0x51, 0x66, 0x75,
	0x18, 0xcf, 0x4f, 0xa4, 0x2b, 0x16, 0x7e, 0xb6, 0xbc, 0xec, 0x67, 0x6f, 0xb2, 0x9a, 0x2e, 0x15,
	0xb5, 0xe2, 0xd0, 0x55, 0x2f, 0x18, 0xba, 0x9a, 0x31, 0x74, 0x06, 0x6b, 0x57, 0xb0, 0xf5, 0x1a,
	0x6b, 0x4d, 0x96, 0xad, 0x62, 0xf1, 0x12, 0x96, 0xc1, 0xb0, 0x57, 0x25, 0xcb, 0x74, 0x66, 0x34,
	0x0a, 0xcc, 0xf8, 0xf5, 0x32, 0x5b, 0x23, 0xd9, 0xfd, 0xb9, 0xf1, 0x23, 0x13, 0xcd, 0xaa, 0x2e,
	0x9a, 0x99, 0x00, 0xd6, 0x74, 0x01, 0xfc, 0x79, 0xf2, 0xe2, 0x87, 0x65, 0xd6, 0xca, 0x66, 0xe8,
	0xcf, 0x8d, 0x1b, 0xda, 0x94, 0xac, 0xa2, 0xfc, 0x67, 0x53, 0x52, 0x9b, 0x7c, 0x35, 0x59, 0xb2,
	0x74, 0xf2, 0xfd, 0x8c, 0xb9, 0xf2, 0x2f, 0x4b, 0xac, 0xbe, 0x9d, 0x9e, 0x88, 0x38, 0x14, 0xf2,
	0x87, 0x55, 0x9f, 0x88, 0x17, 0x39, 0xa0, 0x09, 0x7a, 0xf9, 0x02, 0x41, 0xaf, 0x18, 0x82, 0xee,
	0xb0, 0xa6, 0xfa, 0x32, 0xfa, 0x0f, 0xb2, 0xff, 0x06, 0x06, 0x43, 0x40, 0x0a, 0x63, 0x3b, 0x4c,
	0xe3, 0x68, 0x76, 0x8e, 0xbc, 0x28, 0xf1, 0x02, 0x0a, 0x9e, 0x93, 0xae, 0x6e, 0x56, 0xf0, 0x53,
	0x3a, 0xe4, 0xfc, 0xe7, 0x32, 0xab, 0xb4, 0xb9, 0x7b, 0x49, 0x1f, 0xee, 0xb0, 0x7a, 0x7b, 0x32,
	0x89, 0x33, 0x7f, 0xa6, 0xc6, 0x33, 0x1a, 0xca, 0x70, 0xcc, 0xc6, 0xd1, 0x94, 0xdc, 0x97, 0x8c,
	0x06, 0x11, 0xd8, 0x7d, 0x09, 0x35, 0x45, 0x92, 0x60, 0x0b, 0x64, 0x67, 0x4c, 0xd0, 0x7e, 0xc0,
	0xae, 0xc1, 0x1b, 0x7a, 0x3d, 0x39, 0xb4, 0x45, 0x18, 0x5a, 0xb9, 0x37, 0x13, 0x34, 0x26, 0xb2,
	0x37, 0x39, 0x00, 0x9c, 0xf3, 0xe2, 0x71, 0xf6, 0x6d, 0x1c, 0xe4, 0x26, 0x37, 0x30, 0xe0, 0x1c,
	0x48, 0x52, 0xfe, 0x5d, 0x1c, 0xf1, 0x26, 0x2f, 0xa0, 0xf0, 0xad, 0x6e, 0x92, 0xe6, 0xdf, 0x6a,
	0xc8, 0x6f, 0xe9, 0x18, 0x7c, 0x0b, 0x64, 0x4f, 0xfb, 0x16, 0x93, 0xdf, 0x32, 0x51, 0xe7, 0x1f,
	0x94, 0x58, 0xad, 0x1b, 0xa5, 0xef, 0x3f, 0xbb, 0x9c, 0xcb, 0x6e, 0x1c, 0x44, 0x71, 0x90, 0x9e,
	0x2b, 0x2e, 0x2b, 0x1a, 0xdb, 0x13, 0x47, 0xb3, 0xed, 0x69, 0x70, 0x1c, 0x1c, 0x4e, 0xa5, 0xa3,
	0x58, 0xe7, 0x06, 0x06, 0xed, 0x39, 0xe8, 0xb7, 0x87, 0xbd, 0x89, 0x08, 0xd3, 0xe0, 0x28, 0x10,
	0x31, 0xb1, 0xbb, 0x80, 0x82, 0x4f, 0x89, 0x23, 0x29, 0x99, 0x8c, 0xcf, 0xce, 0x3f, 0xab, 0xc8,
	0x36, 0xbe, 0x7f, 0x49, 0x1b, 0xd5, 0xbb, 0xe5, 0xfc, 0x5d, 0x73, 0x0a, 0xd7, 0x34, 0x85, 0xb6,
	0x33, 0xf5, 0x8f, 0x13, 0x6a, 0x84, 0x24, 0x60, 0x1a, 0xaa, 0x49, 0xd4, 0xeb, 0x52, 0x0b, 0x34,
	0x44, 0x49, 0x9a, 0x48, 0x92, 0xf7, 0xc9, 0xa6, 0x67, 0xb4, 0x56, 0xb6, 0x49, 0x76, 0x3d, 0xa3,
	0xb5, 0xb2, 0x47, 0x64, 0xdc, 0x33, 0x5a, 0x2b, 0xfb, 0x80, 0x0c, 0x7c, 0x46, 0xa3, 0x3c, 0x88,
	0xe7, 0x73, 0x11, 0x8e, 0xc5, 0x70, 0x7e, 0x76, 0x28, 0x62, 0x1c, 0xc3, 0x1a, 0x2f, 0xa0, 0x50,
	0x6f, 0x27, 0xf6, 0x8f, 0xcf, 0x44, 0x98, 0x52, 0xbd, 0x35, 0x59, 0xcf, 0x44, 0x31, 0x30, 0x38,
	0x11, 0xe3, 0xd3, 0x64, 0x7e, 0x86, 0x0e, 0x40, 0x8b, 0x67, 0xb4, 0xfd, 0x79, 0x56, 0x79, 0xb6,
	0xe7, 0xa1, 0xd1, 0x5f, 0xdb, 0xbc, 0x46, 0x01, 0x01, 0x32, 0xfd, 0xd9, 0x9e, 0xc7, 0xa1, 0xcc,
	0x7e, 0xc4, 0x1a, 0xbb, 0x23, 0x70, 0xe2, 0xe3, 0x68, 0x8a, 0x96, 0x7f, 0x6d, 0xf3, 0x0d, 0xbd,
	0x62, 0x56, 0xc8, 0xf3, 0x7a, 0xce, 0x21, 0xab, 0xab, 0xaf, 0x80, 0x1a, 0x1b, 0x51, 0x4c, 0x52,
	0xe3, 0xf0, 0x08, 0x23, 0xb6, 0xbd, 0xe7, 0xb9, 0x38, 0x62, 0x75, 0x8e, 0xcf, 0x30, 0xc6, 0xed,
	0xf1, 0xa9, 0x1b, 0x4d, 0x83, 0xf1, 0xb9, 0x8a, 0x39, 0x32, 0x00, 0xc7, 0xf8, 0xa3, 0x3d, 0x97,
	0x06, 0x0e, 0x9f, 0x21, 0x50, 0x5b, 0x37, 0x5b, 0x00, 0x22, 0xd9, 0xee, 0x74, 0xa2, 0x30, 0x49,
	0x63, 0x3f, 0x08, 0xa5, 0x15, 0xa8, 0x73, 0x03, 0x03, 0x05, 0xc4, 0xbb, 0x4f, 0x06, 0x51, 0x2c,
	0x5c, 0xb7, 0xbb, 0x4f, 0x6d, 0xd0, 0x21, 0xfb, 0x21, 0xab, 0x1c, 0xec, 0x8e, 0xb0, 0x11, 0x6b,
	0x9b, 0x1b, 0x4b, 0xfb, 0x7a, 0xb0, 0x3b, 0xe2, 0x50, 0xc9, 0xfe, 0x12, 0x2b, 0xef, 0x8e, 0xb0,
	0x59, 0x6b, 0x9b, 0xb7, 0x97, 0x56, 0xdd, 0x1d, 0xf1, 0xf2, 0xee, 0xc8, 0xf9, 0x51, 0x99, 0x5d,
	0x5f, 0xf8, 0x06, 0xf0, 0x66, 0xc0, 0x9f, 0x51, 0x3b, 0xe1, 0x11, 0x46, 0x75, 0x3f, 0x4c, 0xa0,
	0xd7, 0x41, 0x2a, 0x26, 0x83, 0x9d, 0x2d, 0x6a, 0x61, 0x01, 0xc5, 0x37, 0xbd, 0x1e, 0x71, 0x0a,
	0x1e, 0xa1, 0xd9, 0x50, 0xbd, 0xfa, 0x9a, 0x66, 0x0f, 0x76, 0xb6, 0x38, 0x54, 0x02, 0x2d, 0xd8,
	0x89, 0xce, 0x66, 0x20, 0x70, 0x62, 0x02, 0xdf, 0x91, 0x62, 0x6f, 0x82, 0x28, 0x89, 0xa3, 0xad,
	0x4e, 0x2f, 0x9c, 0x90, 0x8b, 0x8b, 0xf2, 0x5f, 0xe7, 0x05, 0x14, 0x46, 0x67, 0xb0, 0xe3, 0xf5,
	0x70, 0x06, 0xd4, 0x38, 0x3e, 0x43, 0xfb, 0x9e, 0x90, 0xf1, 0xaa, 0x71, 0x78, 0x84, 0x79, 0xd6,
	0x89, 0x26, 0x41, 0x78, 0x8c, 0xb3, 0xb5, 0x21, 0xe7, 0x59, 0x8e, 0xa0, 0x3c, 0x1f, 0x8e, 0x3e,
	0xda, 0x12, 0xfe, 0xd9, 0x51, 0x14, 0x9f, 0x89, 0x09, 0xca, 0x7d, 0x9d, 0x17, 0x50, 0xe7, 0xf7,
	0xca, 0xcc, 0x2a, 0xb2, 0xd8, 0x1e, 0xb1, 0x9b, 0xe0, 0x2b, 0xb6, 0x27, 0xfe, 0x0c, 0xdb, 0xa4,
	0x04, 0xb6, 0x84, 0xdc, 0xb8, 0xaf, 0x73, 0x63, 0x59, 0x3d, 0xbe, 0xf4, 0x6d, 0xfb, 0x3d, 0x76,
	0xa3, 0xe3, 0x4f, 0x83, 0x43, 0xa9, 0x0b, 0xdc, 0x28, 0x09, 0x90, 0x0b, 0x52, 0xd3, 0x2c, 0x2b,
	0x2a, 0xbc, 0xa1, 0x66, 0x2c, 0x0d, 0xd3, 0xb2, 0x22, 0x90, 0xc7, 0x8e, 0xd7, 0xf3, 0x52, 0x21,
	0xe2, 0x20, 0x3c, 0x26, 0x09, 0xd7, 0x21, 0x30, 0x46, 0xc3, 0xae, 0xdb, 0x0e, 0xc3, 0x68, 0x1e,
	0x8e, 0x05, 0xcc, 0x6c, 0x8a, 0xad, 0x8b, 0x30, 0x30, 0xbd, 0xbb, 0xdd, 0xa3, 0x51, 0x82, 0x47,
	0x47, 0x14, 0xa5, 0x0e, 0x46, 0xff, 0x16, 0x5b, 0x19, 0xce, 0xcf, 0xbc, 0x91, 0x47, 0x93, 0x92,
	0x28, 0xc0, 0x0f, 0x76, 0x47, 0x83, 0x8e, 0x47, 0x3d, 0x24, 0xca, 0x5e, 0x67, 0xe5, 0xad, 0x0f,
	0xa9, 0x0f, 0xe5, 0xad, 0x0f, 0xe1, 0x67, 0xbc, 0x21, 0xa7, 0xa6, 0xc2, 0xa3, 0xf3, 0xbb, 0x25,
	0xf6, 0xe6, 0x85, 0xcc, 0x45, 0x0d, 0x90, 0x4b, 0xf9, 0x88, 0x3f, 0x53, 0x72, 0x5f, 0xce, 0xe5,
	0x7e, 0x51, 0x9e, 0x95, 0x54, 0x55, 0x35, 0xa9, 0x7a, 0x9b, 0x55, 0xdb, 0xde, 0x76, 0x1f, 0xfb,
	0xbf, 0xb6, 0x69, 0xe9, 0xc3, 0x0a, 0x38, 0xc7, 0x52, 0xfc, 0xd6, 0xce, 0x16, 0x59, 0x63, 0x78,
	0x74, 0xbe, 0xc9, 0x1a, 0x59, 0x25, 0x4c, 0xeb, 0x44, 0x67, 0x67, 0x7e, 0x38, 0xa1, 0xfe, 0x2b,
	0x32, 0x4b, 0x6d, 0x90, 0x29, 0x81, 0x67, 0xe7, 0x4f, 0x4a, 0xcc, 0x86, 0x5e, 0xf5, 0xfd, 0x73,
	0x11, 0x77, 0x83, 0x64, 0x1c, 0xbd, 0x10, 0xf1, 0xf9, 0x25, 0x36, 0x69, 0x93, 0x35, 0x3a, 0x27,
	0x7e, 0x92, 0x04, 0x49, 0xaf, 0x8b, 0x5f, 0x5b, 0xdb, 0xbc, 0x49, 0x8d, 0xed, 0xf7, 0xbb, 0x6e,
	0x56, 0xc6, 0xf3, 0x6a, 0xf6, 0x97, 0xd9, 0x0a, 0x38, 0x8d, 0xbd, 0x2e, 0x69, 0x9e, 0xeb, 0xda,
	0x0b, 0xb2, 0x80, 0x53, 0x05, 0x64, 0xe8, 0xa8, 0xaf, 0x06, 0x60, 0x34, 0xea, 0xdb, 0x8f, 0xd9,
	0xca, 0x81, 0x3f, 0x9d, 0x8b, 0x64, 0xa3, 0x76, 0xbf, 0xf2, 0x60, 0x6d, 0xf3, 0x9e, 0x7a, 0x79,
	0xa1, 0xe5, 0x58, 0x8d, 0x53, 0x6d, 0xe7, 0x9b, 0xac, 0x65, 0x34, 0x08, 0xdd, 0xdc, 0xf9, 0x21,
	0xbc, 0xac, 0x98, 0x43, 0x24, 0x48, 0x01, 0x75, 0xa6, 0xc9, 0xcb, 0xbd, 0xae, 0xf3, 0x98, 0xb1,
	0xbc, 0x69, 0x9f, 0xe0, 0xbd, 0xbf, 0xc8, 0x6e, 0x5f, 0xd0, 0xaa, 0xcc, 0x94, 0x97, 0x34, 0x53,
	0x7e, 0x8b, 0xad, 0xf4, 0x45, 0x78, 0x9c, 0x9e, 0x28, 0xa1, 0x94, 0x14, 0x18, 0x73, 0x7c, 0x09,
	0xb9, 0xd5, 0xe4, 0x92, 0x70, 0x7a, 0x6c, 0x4d, 0xb9, 0xa5, 0x9d, 0xd1, 0x65, 0x3e, 0xe4, 0x5d,
	0xd6, 0xf0, 0x4e, 0x83, 0x59, 0x27, 0x9a, 0x87, 0x29, 0x7d, 0x3d, 0x07, 0x9c, 0xbf, 0x5e, 0x62,
	0x96, 0xf6, 0x2d, 0x2e, 0x66, 0xd3, 0xf3, 0xcb, 0xdd, 0xa5, 0x9d, 0x79, 0x38, 0xd6, 0x94, 0x44,
	0x46, 0x83, 0xca, 0xe5, 0x62, 0x2c, 0x82, 0x99, 0xb2, 0xd6, 0x52, 0xd4, 0x4d, 0x70, 0x59, 0x72,
	0xcd, 0xf9, 0x3b, 0x15, 0x76, 0x6b, 0x91, 0x63, 0xbd, 0xf0, 0x28, 0xba, 0xa4, 0x39, 0xe0, 0xc5,
	0x46, 0x71, 0xda, 0x15, 0xc9, 0x38, 0x0e, 0x66, 0x59, 0xab, 0x1a, 0xbc, 0x08, 0xe3, 0xe8, 0x9d,
	0x27, 0x43, 0xff, 0x4c, 0x90, 0xeb, 0xaf, 0x48, 0xb4, 0x01, 0xe7, 0x89, 0xfe, 0x09, 0xca, 0x91,
	0x98, 0xa8, 0xdd, 0x65, 0xd7, 0xbc, 0xf3, 0xa4, 0xe3, 0xcf, 0xfc, 0xc3, 0x60, 0x1a, 0xa4, 0x81,
	0x48, 0x68, 0x92, 0xde, 0xd1, 0xc4, 0xb8, 0x50, 0x83, 0x17, 0x5f, 0xb1, 0xbf, 0xc1, 0xd6, 0x06,
	0xc7, 0x67, 0x99, 0xf3, 0xba, 0x82, 0x5f, 0xb8, 0xa5, 0x7d, 0x41, 0x2b, 0xe5, 0x7a, 0x55, 0xfb,
	0x11, 0x5b, 0xdd, 0x8b, 0x8f, 0x47, 0xfd, 0x03, 0x70, 0xb2, 0x61, 0x06, 0xbc, 0xa9, 0xbd, 0xb5,
	0x17, 0x1f, 0x7b, 0x33, 0x31, 0x0e, 0x8e, 0x82, 0xf1, 0xa8, 0x7f, 0xc0, 0x55, 0x4d, 0xfb, 0x1b,
	0x6c, 0x75, 0x3f, 0x3c, 0x0d, 0xa3, 0x97, 0xe1, 0x46, 0xfd, 0x4a, 0xd3, 0x46, 0x55, 0x77, 0xbe,
	0x5f, 0x62, 0x37, 0x96, 0xf4, 0xc8, 0xfe, 0x3a, 0x6b, 0x78, 0xe7, 0x49, 0x2a, 0xce, 0x3a, 0xfe,
	0x8c, 0x8c, 0xcf, 0x6d, 0x7d, 0xe2, 0xeb, 0xbd, 0xcf, 0x6b, 0xda, 0xbf, 0xc4, 0xd8, 0x76, 0xe8,
	0x1f, 0x4e, 0xc5, 0x04, 0xde, 0x2b, 0xbf, 0xfe, 0x3d, 0xad, 0xaa, 0xf3, 0x3b, 0x65, 0x66, 0x15,
	0x2b, 0xc0, 0xd4, 0xd8, 0x03, 0xc1, 0x25, 0x8d, 0x2b, 0x09, 0x10, 0x4e, 0x2e, 0x66, 0xc2, 0x4f,
	0x45, 0x4c, 0x8a, 0x37, 0xa3, 0x61, 0x92, 0x6d, 0xc5, 0xc1, 0xe4, 0x58, 0x79, 0xf1, 0x44, 0x01,
	0xfe, 0x61, 0xbf, 0x3d, 0x6c, 0x4b, 0xcf, 0xab, 0xce, 0x89, 0x02, 0x9c, 0x47, 0x73, 0xf8, 0x92,
	0xb4, 0x44, 0x44, 0xa1, 0xdf, 0x7d, 0x12, 0x85, 0x82, 0x4c, 0x90, 0x24, 0x30, 0xae, 0x8c, 0xc6,
	0x5e, 0x20, 0xe3, 0x9f, 0x3a, 0x27, 0x0a, 0x4c, 0x9f, 0x97, 0xa2, 0xa5, 0xd8, 0x0b, 0xa7, 0xe7,
	0xe8, 0x2b, 0xd4, 0xb9, 0x0e, 0xc1, 0xf7, 0x3a, 0x10, 0x2a, 0xa0, 0xbb, 0x50, 0xe7, 0x92, 0xc0,
	0xc4, 0x04, 0xa2, 0xd2, 0x41, 0x90, 0x04, 0x2a, 0x8f, 0x81, 0xcb, 0xd1, 0x0b, 0xae, 0x73, 0x7c,
	0x76, 0x7e, 0xbf, 0xc4, 0xae, 0x15, 0xc4, 0xe6, 0x35, 0x9a, 0x6a, 0x83, 0xad, 0x2a, 0xc9, 0x93,
	0xea, 0x4a, 0x91, 0xf6, 0x43, 0x66, 0xf5, 0xc2, 0x54, 0xc4, 0x47, 0xfe, 0x58, 0xa8, 0x97, 0xe5,
	0xfc, 0x5d, 0xc0, 0x61, 0xd6, 0x65, 0x18, 0x4d, 0xf5, 0x2a, 0xba, 0xdd, 0x45, 0x18, 0xd4, 0xf8,
	0x1e, 0x85, 0x1c, 0x0d, 0x0e, 0x8f, 0xce, 0x88, 0xd9, 0x8b, 0xf2, 0x8a, 0xf5, 0xf6, 0x7b, 0xd8,
	0xda, 0x16, 0x87, 0x47, 0xea, 0x83, 0x16, 0xf6, 0x28, 0x12, 0xb8, 0x00, 0x9a, 0x81, 0xb4, 0x22,
	0x3e, 0x3b, 0x3f, 0xaa, 0xb0, 0x6a, 0xcf, 0x7d, 0xf1, 0xc1, 0x25, 0xea, 0x42, 0x5b, 0x91, 0xa0,
	0x8f, 0xaa, 0x15, 0x09, 0x8b, 0x55, 0x7a, 0xbb, 0x7d, 0x65, 0x9c, 0x7b, 0xbb, 0x68, 0x62, 0x47,
	0x7b, 0x5e, 0x66, 0x81, 0xf6, 0x3c, 0x4d, 0x4f, 0xd7, 0x0c, 0x3d, 0x0d, 0xea, 0x7f, 0x42, 0xb6,
	0xb8, 0xdc, 0x9b, 0xe4, 0x41, 0xd8, 0x6a, 0x21, 0x08, 0x83, 0xb0, 0x65, 0xef, 0xe8, 0x28, 0x11,
	0x29, 0x79, 0x8d, 0x1a, 0xa2, 0x2c, 0x5e, 0x23, 0xb7, 0x78, 0x7a, 0x90, 0xcf, 0x0a, 0x41, 0xbe,
	0x1e, 0xf2, 0xc8, 0xa0, 0x28, 0x0f, 0x79, 0xb2, 0xac, 0x56, 0x73, 0x69, 0x56, 0xab, 0x55, 0x48,
	0xab, 0xba, 0xfe, 0x04, 0x3c, 0x54, 0x8c, 0x7c, 0x9a, 0x5c, 0x91, 0xf6, 0x57, 0xd8, 0xea, 0x1e,
	0x2a, 0xbe, 0x64, 0xe3, 0x1a, 0x6a, 0x0e, 0x65, 0xad, 0x81, 0xcf, 0xb2, 0x84, 0xab, 0x1a, 0x4b,
	0x72, 0x23, 0xd6, 0x55, 0x72, 0x23, 0xd7, 0x17, 0x73, 0x23, 0x33, 0xc6, 0xf2, 0x1f, 0x00, 0xa6,
	0xc9, 0x27, 0xcd, 0x68, 0x6a, 0x08, 0x84, 0x43, 0x92, 0x32, 0x0c, 0xa8, 0x81, 0xe5, 0xdf, 0x40,
	0xb3, 0x23, 0xa5, 0x46, 0x43, 0x9c, 0xff, 0x53, 0x46, 0xd9, 0x79, 0xfc, 0xa9, 0x65, 0xc7, 0x61,
	0xcd, 0x51, 0xec, 0x1f, 0x1d, 0x05, 0xe3, 0xce, 0xd4, 0x4f, 0x12, 0x12, 0x22, 0x03, 0x83, 0x6f,
	0xef, 0x4c, 0xa3, 0x97, 0x7d, 0xff, 0x50, 0x4c, 0x69, 0xb2, 0xe4, 0xc0, 0x85, 0x92, 0x75, 0x8f,
	0xb1, 0xa1, 0x78, 0x95, 0xca, 0xc5, 0x3a, 0x92, 0x30, 0x0d, 0x01, 0x29, 0xd8, 0x8d, 0x66, 0xfd,
	0xe0, 0x2c, 0x48, 0x49, 0xd8, 0x32, 0xfa, 0x82, 0xb4, 0x7b, 0x26, 0x05, 0x0d, 0x5d, 0x0a, 0x16,
	0x87, 0x8f, 0x5d, 0x65, 0xf8, 0xd6, 0x16, 0x86, 0xcf, 0xfe, 0x1a, 0xb6, 0x68, 0xeb, 0x7c, 0x37,
	0x9a, 0xa1, 0xf8, 0xad, 0x6d, 0xde, 0xc8, 0xc5, 0xe6, 0xb1, 0x2a, 0xe2, 0x59, 0x25, 0xe7, 0xff,
	0x96, 0x58, 0x13, 0x8a, 0x54, 0x48, 0x7f, 0xc9, 0x28, 0x98, 0x1c, 0x29, 0x2f, 0x70, 0xe4, 0x2e,
	0x6b, 0x70, 0x91, 0x88, 0xf8, 0x85, 0x98, 0xbc, 0xaf, 0x82, 0xec, 0x0c, 0xd0, 0x13, 0x0a, 0x34,
	0x0f, 0xab, 0x66, 0x42, 0x81, 0xe6, 0xa2, 0xf6, 0x95, 0x4d, 0x1a, 0x92, 0x1c, 0x00, 0x3f, 0x07,
	0x22, 0x69, 0xf5, 0x4e, 0x42, 0xa6, 0xc0, 0x04, 0xe1, 0xb7, 0x54, 0xfa, 0x87, 0x42, 0xcb, 0x55,
	0x1c, 0xf6, 0x02, 0xea, 0xfc, 0xd5, 0x12, 0x5b, 0xe9, 0x75, 0x06, 0x97, 0x2b, 0xaf, 0x3b, 0xac,
	0x0e, 0x32, 0xdf, 0x89, 0x26, 0x59, 0x3e, 0x50, 0xd1, 0x86, 0x3a, 0xa8, 0x14, 0xd4, 0x81, 0x54,
	0x4f, 0xd5, 0x4c, 0x3d, 0x41, 0x6c, 0x23, 0x9e, 0x53, 0xb7, 0xe0, 0xd1, 0xf9, 0x4b, 0xd4, 0x82,
	0xc7, 0x3f, 0x9b, 0x16, 0x38, 0xff, 0xb0, 0xc4, 0xde, 0x92, 0x3f, 0x30, 0x14, 0xc1, 0xf1, 0xc9,
	0x61, 0x14, 0xb7, 0x27, 0x2f, 0x44, 0x9c, 0x06, 0x89, 0xb8, 0xc2, 0x90, 0x67, 0xea, 0xb4, 0xac,
	0xab, 0xd3, 0xb7, 0x59, 0x6b, 0xe4, 0xc7, 0xc7, 0x22, 0xf3, 0xa4, 0x2a, 0x94, 0xe8, 0xd6, 0x41,
	0xfb, 0xab, 0xb9, 0x12, 0xab, 0xa2, 0x12, 0xcb, 0xa4, 0x11, 0x9b, 0x53, 0x50, 0x63, 0xce, 0xdf,
	0x2c, 0xb3, 0x37, 0x65, 0x89, 0xb4, 0xf6, 0x9f, 0xa4, 0x99, 0xfa, 0x5c, 0x2c, 0x2f, 0xce, 0x45,
	0xd9, 0x85, 0x8a, 0xde, 0x85, 0x2f, 0xb2, 0x75, 0xf9, 0x33, 0xfd, 0xe0, 0x48, 0xa4, 0xc1, 0x99,
	0xca, 0xd4, 0x16, 0x50, 0xe9, 0x57, 0xfb, 0xe3, 0x13, 0x70, 0x89, 0xe0, 0xf7, 0x70, 0xe8, 0x5a,
	0xdc, 0x04, 0x41, 0x0b, 0x71, 0x91, 0xc6, 0x7e, 0x98, 0x00, 0x29, 0xb5, 0x45, 0x8b, 0x1b, 0x98,
	0xce, 0x8e, 0xd5, 0x2b, 0xb0, 0xe3, 0x31, 0x6b, 0xea, 0x05, 0x4b, 0x83, 0x17, 0x3d, 0xa0, 0x54,
	0xee, 0xfc, 0x7f, 0x2f, 0xb1, 0xca, 0x7e, 0xd7, 0xbd, 0x5c, 0xa1, 0xaa, 0xe5, 0x86, 0xf2, 0x85,
	0xcb, 0x0d, 0x15, 0x73, 0xb9, 0x21, 0x57, 0x94, 0x55, 0x43, 0x51, 0xea, 0xd2, 0x57, 0x2b, 0xc8,
	0xff, 0xa2, 0x72, 0x5b, 0xb9, 0x8a, 0x72, 0x5b, 0x5d, 0x54, 0x6e, 0x68, 0x2c, 0x91, 0xa4, 0x04,
	0xb6, 0x22, 0x9d, 0x3f, 0xac, 0xb2, 0xca, 0xa8, 0xf3, 0x33, 0xea, 0xb1, 0x27, 0x9e, 0x0f, 0xe7,
	0x67, 0x64, 0x35, 0x88, 0x02, 0xbc, 0x3d, 0x3e, 0x1d, 0x52, 0x7f, 0x5b, 0x9c, 0x28, 0xcc, 0xf5,
	0xfa, 0xa9, 0x4f, 0xea, 0x8d, 0x4c, 0x46, 0x8e, 0xc0, 0xec, 0xdf, 0xe9, 0x0d, 0xc9, 0x4d, 0x85,
	0x47, 0xd4, 0x07, 0xdf, 0x1d, 0x92, 0x6f, 0x0a, 0x8f, 0x80, 0x70, 0x6f, 0x44, 0x1e, 0x29, 0x3c,
	0x02, 0xe2, 0x7a, 0xbb, 0xe4, 0x8d, 0xc2, 0x23, 0x20, 0xed, 0xce, 0x53, 0x72, 0x45, 0xe1, 0x11,
	0x17, 0x73, 0xf8, 0x13, 0xd4, 0xfa, 0x75, 0x0e, 0x8f, 0x80, 0x6c, 0x77, 0xb6, 0xd1, 0xe1, 0xa8,
	0x73, 0x78, 0x04, 0xa4, 0xf3, 0x21, 0x47, 0x57, 0xa3, 0xce, 0xe1, 0x11, 0xb4, 0xd3, 0xd0, 0xc3,
	0x65, 0xd5, 0x3a, 0x2f, 0x0f, 0xd1, 0xc9, 0xfa, 0x30, 0x08, 0x27, 0xd1, 0x4b, 0xf4, 0x20, 0x6a,
	0x9c, 0x28, 0x63, 0x84, 0xaf, 0x17, 0x46, 0xf8, 0x16, 0x5b, 0xd9, 0x8f, 0x8f, 0x45, 0x98, 0x6e,
	0xd8, 0xf2, 0x1d, 0x49, 0xe9, 0xce, 0xcd, 0x0d, 0xd3, 0xb9, 0x79, 0x98, 0x4f, 0x84, 0x9b, 0x38,
	0x11, 0x54, 0xa2, 0x65, 0xd4, 0x71, 0x2f, 0xf7, 0x6d, 0xde, 0xb8, 0x8a, 0xfc, 0xdc, 0x7a, 0xad,
	0xfc, 0xdc, 0x36, 0xe5, 0x27, 0x62, 0x8d, 0xec, 0x97, 0x7f, 0x2e, 0x4e, 0xcf, 0xdf, 0x2f, 0xb1,
	0xaa, 0x77, 0x79, 0xfe, 0xa0, 0x20, 0xb1, 0xad, 0x0b, 0x25, 0xb6, 0x95, 0x4b, 0xec, 0x03, 0x76,
	0xed, 0x40, 0xc4, 0x99, 0x81, 0x1b, 0xf9, 0xc7, 0x2a, 0x3a, 0x28, 0xc0, 0x0b, 0xb3, 0x56, 0xcb,
	0xdb, 0x3b, 0x3f, 0xac, 0xb2, 0x4a, 0x77, 0xe8, 0x5d, 0xd2, 0xbe, 0x3c, 0xf3, 0x02, 0xb6, 0xad,
	0x0b, 0xf4, 0x33, 0x4e, 0x11, 0x5e, 0xf9, 0x19, 0x07, 0xc9, 0xd8, 0x9b, 0xa1, 0xbd, 0x22, 0x7d,
	0x21, 0x29, 0xa8, 0xd7, 0x6e, 0x53, 0x64, 0x57, 0x6e, 0xb7, 0x81, 0x1e, 0x75, 0xc8, 0x8e, 0x97,
	0x47, 0x1d, 0xa0, 0x79, 0x97, 0x26, 0x49, 0x99, 0xe3, 0x77, 0x79, 0x9b, 0xa6, 0x48, 0x99, 0xb7,
	0xed, 0x26, 0x2b, 0xfd, 0x1a, 0xb9, 0xea, 0xa5, 0x5f, 0x93, 0xaa, 0x37, 0x99, 0x45, 0x61, 0x22,
	0x6d, 0xa3, 0x74, 0xd6, 0x0d, 0x0c, 0xf8, 0xf5, 0xac, 0x2b, 0xf3, 0x30, 0xd2, 0x6d, 0x52, 0x24,
	0xc6, 0x64, 0x43, 0x59, 0x22, 0x77, 0x2f, 0x28, 0x12, 0x4a, 0x86, 0x9e, 0x2c, 0x91, 0x9b, 0x16,
	0x14, 0x89, 0xef, 0x70, 0x59, 0xb2, 0x4e, 0xef, 0x48, 0xd2, 0x7e, 0x8f, 0x35, 0x9e, 0xcd, 0x45,
	0xa2, 0x3b, 0xee, 0xb6, 0x4a, 0x22, 0x0e, 0x3d, 0x55, 0xc4, 0xf3, 0x4a, 0xf6, 0x26, 0x5b, 0x6d,
	0x87, 0xc9, 0x4b, 0x11, 0x27, 0x1b, 0x16, 0xd6, 0xdf, 0xc8, 0xeb, 0x73, 0x91, 0xe0, 0x66, 0x2f,
	0x2e, 0xc6, 0x51, 0x3c, 0xe1, 0xaa, 0xa2, 0xfd, 0x2d, 0xb6, 0xd6, 0x9e, 0xa7, 0x27, 0x51, 0x2c,
	0xf3, 0x20, 0xd7, 0x2f, 0x79, 0x4f, 0xaf, 0x8c, 0xef, 0x4e, 0x26, 0x98, 0x4c, 0xf6, 0xa7, 0xc9,
	0x86, 0x7d, 0xe9, 0xbb, 0x79, 0x65, 0xe7, 0xdf, 0x95, 0xd9, 0xf5, 0x85, 0x2a, 0x60, 0x83, 0x30,
	0xb1, 0x53, 0x92, 0x36, 0x08, 0xb3, 0x3a, 0x17, 0xac, 0x99, 0xe9, 0x1e, 0xba, 0x24, 0xf4, 0x54,
	0x63, 0x4b, 0x06, 0x5e, 0xa4, 0x43, 0x0d, 0x97, 0x5c, 0x43, 0x32, 0x9b, 0xb7, 0xa2, 0xed, 0x0f,
	0x03, 0x49, 0x74, 0x69, 0x85, 0xac, 0xdc, 0x73, 0x49, 0xaf, 0x49, 0x33, 0x01, 0x7a, 0x0d, 0x7e,
	0x7b, 0xd8, 0x1e, 0x6c, 0xd3, 0xa2, 0xa6, 0x24, 0x50, 0xaf, 0x8e, 0x38, 0x2d, 0x61, 0xc2, 0xa3,
	0xfd, 0x39, 0x56, 0xf1, 0xf6, 0xda, 0x28, 0x23, 0x6b, 0x9b, 0xad, 0x9c, 0x2b, 0xde, 0x5e, 0x9b,
	0x43, 0x09, 0x56, 0xe0, 0x07, 0xe4, 0x5c, 0xeb, 0x15, 0xf8, 0x01, 0x87, 0x12, 0xfb, 0x2e, 0x2b,
	0x0f, 0x3e, 0xa2, 0x05, 0xaf, 0x66, 0x5e, 0x3e, 0xf8, 0x88, 0x97, 0x07, 0x1f, 0xc9, 0x75, 0xa6,
	0x51, 0xb2, 0xb1, 0x7e, 0xbf, 0x02, 0x6d, 0x87, 0x67, 0xe7, 0x9f, 0x94, 0xd8, 0x8a, 0xfc, 0x09,
	0x68, 0xe6, 0x40, 0xe3, 0xa5, 0x24, 0x00, 0xe5, 0x88, 0x4a, 0x2b, 0x2f, 0x09, 0x69, 0x9a, 0xe2,
	0xc0, 0x9f, 0x92, 0x06, 0x20, 0x0a, 0x84, 0x93, 0x8b, 0xa3, 0x58, 0x24, 0x27, 0xc4, 0x54, 0x45,
	0xe2, 0x77, 0x44, 0x1a, 0x9f, 0xd3, 0x6c, 0x97, 0x04, 0x7c, 0x67, 0xfb, 0xd5, 0x2c, 0x88, 0x05,
	0xf9, 0x2c, 0x44, 0xc1, 0x77, 0x06, 0x41, 0x18, 0x9c, 0xcd, 0xcf, 0xc8, 0x75, 0x56, 0xa4, 0x33,
	0x91, 0xed, 0xe5, 0x07, 0xc6, 0xf2, 0x6d, 0xa9, 0xb0, 0x7c, 0x0b, 0xa6, 0x04, 0xfc, 0x4d, 0x65,
	0x6d, 0x89, 0x02, 0x16, 0x68, 0x96, 0x16, 0x9f, 0x33, 0x11, 0xaa, 0xe6, 0x22, 0xe4, 0x7c, 0x9b,
	0xd5, 0x90, 0x6f, 0x20, 0x0f, 0x6e, 0x2c, 0x8e, 0x44, 0x8c, 0x2b, 0x1d, 0xa4, 0x90, 0x73, 0x24,
	0x7b, 0xb9, 0xac, 0xbd, 0xfc, 0x94, 0xad, 0x69, 0xf3, 0xed, 0xcf, 0x26, 0xa2, 0xce, 0xff, 0xaa,
	0xb0, 0x95, 0xee, 0x6e, 0xe7, 0xf2, 0x18, 0xc1, 0x58, 0xab, 0x2f, 0x2f, 0x59, 0xab, 0xdf, 0xf5,
	0xe3, 0xc9, 0x4b, 0x3f, 0x16, 0xa3, 0x3c, 0xbf, 0x63, 0x60, 0x60, 0xc5, 0x14, 0xdd, 0x17, 0xa1,
	0x5a, 0xac, 0xd1, 0x20, 0xfd, 0x2b, 0x7b, 0xb3, 0x34, 0xa1, 0xf9, 0x61, 0x60, 0x20, 0xd7, 0x1f,
	0x05, 0x13, 0x1a, 0x4f, 0x78, 0x84, 0xce, 0x7a, 0x62, 0xac, 0x72, 0x22, 0xf8, 0x9c, 0xbb, 0xc5,
	0x75, 0xdd, 0x2d, 0xce, 0xb7, 0x79, 0xaa, 0x28, 0x35, 0xa3, 0xe1, 0xb7, 0xbf, 0x1b, 0xcd, 0xe3,
	0xac, 0x5c, 0x6e, 0x11, 0x33, 0x30, 0xb9, 0x2f, 0xee, 0x55, 0xea, 0x41, 0xb4, 0x16, 0xf7, 0x5c,
	0xda, 0x2e, 0x66, 0x60, 0x52, 0x63, 0x4f, 0xfd, 0xf3, 0xf6, 0xb1, 0xfc, 0x8e, 0xcc, 0x94, 0x18,
	0x18, 0xd4, 0x91, 0xdf, 0xdc, 0xfd, 0x10, 0xc2, 0x09, 0xca, 0x9b, 0x18, 0x18, 0x48, 0x86, 0xfc,
	0x26, 0x0e, 0xae, 0xcc, 0xa0, 0x68, 0x08, 0xf4, 0x7a, 0x27, 0x98, 0x0a, 0xf4, 0x6f, 0x9a, 0x1c,
	0x9f, 0xf5, 0xc4, 0x8a, 0x65, 0x24, 0x56, 0x60, 0x84, 0x8b, 0x2e, 0x78, 0x9f, 0xb1, 0x1c, 0xfe,
	0x44, 0xab, 0x07, 0x4a, 0x49, 0x55, 0x34, 0xc7, 0xfc, 0x4f, 0x4b, 0x24, 0x47, 0x57, 0x48, 0x76,
	0x0c, 0x92, 0x63, 0x3d, 0xfb, 0x46, 0x24, 0x85, 0x39, 0xd2, 0xf4, 0x54, 0xb2, 0x30, 0x47, 0xda,
	0x9e, 0x3b, 0x72, 0x3b, 0x1b, 0x72, 0x4b, 0xe6, 0xd0, 0x33, 0x1a, 0x27, 0xaa, 0x80, 0x88, 0x6a,
	0x12, 0x53, 0x3a, 0x30, 0xa3, 0x31, 0x96, 0x83, 0x20, 0xc5, 0x1f, 0xd3, 0x16, 0x05, 0xa9, 0x58,
	0x4d, 0xf0, 0xe2, 0xe0, 0x45, 0xf6, 0xa8, 0xc8, 0xb9, 0x21, 0x6b, 0xea, 0x05, 0xc0, 0x0f, 0x34,
	0xce, 0xc4, 0x3b, 0x34, 0xca, 0x9f, 0x84, 0x77, 0xdf, 0x2f, 0xb1, 0x4a, 0xbf, 0xdf, 0xb9, 0x7c,
	0xab, 0x46, 0xd7, 0x6b, 0xbb, 0xd9, 0xfa, 0x9a, 0xd7, 0x46, 0x53, 0xd0, 0x7b, 0xa2, 0x9c, 0x92,
	0xde, 0x13, 0x9c, 0x0a, 0x5e, 0x3b, 0x5b, 0xea, 0xf7, 0xa8, 0x4e, 0x87, 0x2b, 0x87, 0xa4, 0xc3,
	0xe5, 0x0a, 0x9e, 0x5c, 0xe0, 0x5d, 0x51, 0x2b, 0x78, 0x72, 0xe3, 0xc1, 0xdf, 0xa8, 0xb2, 0xca,
	0xf0, 0x52, 0xc7, 0xed, 0x6d, 0xd6, 0xea, 0x0b, 0x7f, 0x46, 0x4b, 0xd8, 0x91, 0x4a, 0x95, 0x98,
	0xa0, 0x9e, 0xd3, 0xaa, 0x98, 0x39, 0x2d, 0x9b, 0x55, 0x07, 0xb9, 0xdb, 0x84, 0xcf, 0xe8, 0x0c,
	0xa6, 0xb1, 0x9f, 0x66, 0x31, 0x96, 0x22, 0xa5, 0x46, 0x9d, 0xaa, 0xa6, 0xe2, 0x33, 0xb4, 0xcf,
	0x8d, 0xc5, 0x38, 0x48, 0x54, 0xea, 0xa3, 0xc6, 0x73, 0x00, 0x33, 0x2c, 0x51, 0x94, 0x76, 0x61,
	0xc2, 0xe1, 0xf4, 0x6f, 0xf1, 0x1c, 0x90, 0x91, 0x71, 0x94, 0x76, 0x83, 0x64, 0x46, 0xcd, 0x6b,
	0xc8, 0xdc, 0x89, 0x89, 0xe2, 0x4e, 0x07, 0xa5, 0x85, 0x7b, 0x5d, 0xd4, 0x06, 0x2d, 0xae, 0x43,
	0xf6, 0xbb, 0xcc, 0xce, 0xc8, 0x9c, 0x5d, 0x6b, 0xb8, 0xe1, 0x6c, 0x49, 0x09, 0x38, 0xaf, 0x7b,
	0x71, 0x70, 0x1c, 0x84, 0x79, 0xe5, 0x26, 0x56, 0x2e, 0xc2, 0xf6, 0x43, 0x66, 0xe1, 0xc2, 0xd6,
	0x0b, 0xed, 0xbb, 0x2d, 0xac, 0xba, 0x80, 0xdb, 0xef, 0xb0, 0xeb, 0x28, 0xcb, 0x67, 0x41, 0x9a,
	0x57, 0x5e, 0xc7, 0xca, 0x8b, 0x05, 0xd0, 0xfb, 0xed, 0x57, 0xa9, 0x08, 0xa1, 0x8b, 0x5b, 0xe7,
	0xa9, 0x48, 0x48, 0x7d, 0x14, 0x50, 0xe7, 0x4f, 0x4a, 0xac, 0xe2, 0xf5, 0xdc, 0x4f, 0x9d, 0xb7,
	0xbc, 0xc5, 0x56, 0x06, 0x22, 0x3d, 0x89, 0x26, 0x34, 0xf8, 0x44, 0xc1, 0x1b, 0x32, 0x9b, 0x26,
	0x93, 0x26, 0x0d, 0xae, 0x48, 0x50, 0x77, 0xbd, 0x44, 0xb9, 0xb5, 0x24, 0xad, 0x1a, 0xb2, 0xe0,
	0x08, 0xaf, 0x2c, 0x71, 0x84, 0x61, 0x6c, 0x89, 0xf6, 0x52, 0x3f, 0x9d, 0x27, 0xe4, 0x34, 0x15,
	0x50, 0xe7, 0x37, 0xaa, 0xac, 0xda, 0x7b, 0x32, 0x70, 0x3f, 0xc5, 0xde, 0xa8, 0x07, 0xec, 0xda,
	0xc0, 0x7f, 0xa5, 0xbe, 0x87, 0x29, 0x93, 0x8a, 0x1c, 0xc4, 0x02, 0x6c, 0x44, 0x20, 0xd5, 0x42,
	0x54, 0xe9, 0xb0, 0xe6, 0x93, 0x38, 0x9a, 0xcf, 0x54, 0x82, 0xa9, 0x26, 0x77, 0xa3, 0xe9, 0x98,
	0xfd, 0x0d, 0x76, 0xdb, 0x9b, 0xe3, 0x7e, 0x12, 0x99, 0xb3, 0x71, 0xe3, 0x68, 0x2c, 0x92, 0x04,
	0x22, 0x4e, 0x19, 0x4c, 0x5c, 0x54, 0x0c, 0x6d, 0xe4, 0xd1, 0xe1, 0x3c, 0x49, 0x43, 0x91, 0x24,
	0x72, 0x99, 0x57, 0x4e, 0x92, 0x22, 0x0c, 0xed, 0xc0, 0x65, 0x95, 0x17, 0xfe, 0x14, 0xbb, 0x22,
	0x77, 0x4b, 0x1a, 0x18, 0x7c, 0x4d, 0x9e, 0xca, 0xa0, 0x86, 0x89, 0x64, 0xa3, 0x81, 0x43, 0x57,
	0x84, 0xed, 0x4d, 0x76, 0x53, 0xae, 0xcd, 0xec, 0x1d, 0x61, 0x4f, 0xa4, 0x0b, 0x9d, 0x50, 0xcc,
	0xb2, 0xb4, 0x0c, 0xb7, 0x67, 0x10, 0x2e, 0x3f, 0x97, 0x50, 0x0c, 0x53, 0x84, 0xed, 0xef, 0x10,
	0xcf, 0xd4, 0x57, 0x9b, 0x86, 0x73, 0x0f, 0xc3, 0xf9, 0xe2, 0x91, 0x56, 0x81, 0x1b, 0xb5, 0x75,
	0x51, 0x6d, 0x19, 0xa2, 0xea, 0xfc, 0xa8, 0xc4, 0xae, 0x2f, 0xbc, 0xbd, 0xd4, 0x1c, 0xde, 0x63,
	0xac, 0x3d, 0x7f, 0x45, 0xce, 0xba, 0x4a, 0x10, 0xe7, 0xc8, 0xb2, 0xbe, 0x54, 0x96, 0xf7, 0xe5,
	0x21, 0xb3, 0x06, 0xf3, 0x69, 0x1a, 0x8c, 0xfd, 0x24, 0x4b, 0x32, 0x4a, 0xab, 0xb6, 0x80, 0x2f,
	0xe3, 0x7f, 0x6d, 0x29, 0xff, 0x1d, 0x5f, 0xa6, 0xbb, 0x55, 0xfe, 0xfb, 0x12, 0xe9, 0x7e, 0x94,
	0xdb, 0xbc, 0xb2, 0xb1, 0xe6, 0xab, 0x7f, 0xa3, 0x68, 0xf9, 0xfe, 0x4b, 0x89, 0xd9, 0x8b, 0xe5,
	0x3f, 0x95, 0xb4, 0x82, 0xc3, 0x9a, 0xed, 0x71, 0x3a, 0xf7, 0xa7, 0x54, 0x87, 0x3c, 0x48, 0x1d,
	0x2b, 0xa4, 0x1e, 0xaa, 0xc5, 0xd4, 0x83, 0xdd, 0x67, 0xd7, 0x24, 0xd5, 0x9e, 0x06, 0xc7, 0x61,
	0xb6, 0xd9, 0x67, 0x6d, 0xd3, 0xb9, 0xb0, 0x6f, 0x59, 0x4d, 0x5e, 0x7c, 0xd5, 0x69, 0xb3, 0xb7,
	0x5e, 0x53, 0x1f, 0x17, 0x16, 0x43, 0xd5, 0x5b, 0x78, 0xc4, 0x70, 0xef, 0x65, 0x44, 0xbd, 0x83,
	0x47, 0xe7, 0x84, 0x55, 0xbd, 0x61, 0xfb, 0x32, 0x45, 0xf3, 0x2e, 0xb3, 0xf7, 0xe2, 0x63, 0x3f,
	0x0c, 0xbe, 0xe7, 0xcb, 0x68, 0x34, 0x4b, 0x83, 0x37, 0xf9, 0x92, 0x92, 0x4c, 0x38, 0x2b, 0xda,
	0x86, 0xcf, 0x13, 0xc6, 0x64, 0x42, 0x75, 0x7b, 0x7c, 0x12, 0x5d, 0xbe, 0xd2, 0xa1, 0x6d, 0x2a,
	0x25, 0x41, 0xd6, 0x36, 0x94, 0xde, 0x65, 0x0d, 0x99, 0x0a, 0xcc, 0x77, 0x5a, 0xe4, 0x80, 0xf3,
	0x83, 0x12, 0xbb, 0x63, 0xa6, 0xdc, 0x3d, 0xb9, 0xb7, 0x4e, 0x46, 0x02, 0x97, 0x3a, 0x0f, 0x66,
	0x6e, 0xbd, 0x7c, 0x49, 0x6e, 0xbd, 0x72, 0x85, 0x64, 0xf2, 0x31, 0xdb, 0xd0, 0x53, 0xeb, 0x9f,
	0xa0, 0x39, 0x5f, 0x2d, 0x4e, 0x82, 0xd7, 0xff, 0xd0, 0x6f, 0x57, 0x58, 0x75, 0x77, 0x74, 0xa9,
	0x87, 0x94, 0x6d, 0xa0, 0x2d, 0x17, 0x4e, 0x48, 0x68, 0x36, 0xb1, 0x91, 0xd9, 0x44, 0x9b, 0x55,
	0x77, 0xa3, 0x24, 0x25, 0x05, 0x80, 0xcf, 0xf0, 0xfd, 0xfd, 0x44, 0xc4, 0x18, 0x2f, 0x90, 0x4f,
	0x9b, 0x03, 0x14, 0x05, 0x8b, 0x98, 0x52, 0xf1, 0x0d, 0xae, 0x48, 0x18, 0x59, 0x2e, 0x9e, 0x77,
	0xa2, 0xe8, 0x34, 0x10, 0xd2, 0x97, 0x6d, 0x70, 0x0d, 0x91, 0x9e, 0xc5, 0x73, 0xf0, 0xf7, 0x44,
	0x98, 0xd2, 0x44, 0x93, 0x11, 0xd2, 0x02, 0x2e, 0x93, 0xae, 0x7d, 0x8a, 0x93, 0xe0, 0x51, 0xbe,
	0x9d, 0x98, 0x6f, 0x33, 0xf5, 0xb6, 0x89, 0xe3, 0xce, 0x3c, 0x09, 0xa0, 0xa8, 0xca, 0x48, 0x49,
	0x87, 0x30, 0xc0, 0x41, 0x7b, 0x8c, 0xd2, 0x2e, 0xf3, 0x53, 0x1a, 0x92, 0xaf, 0x32, 0xb6, 0x96,
	0xae, 0x32, 0xae, 0x6b, 0xab, 0x8c, 0xce, 0x7f, 0x5c, 0x61, 0xeb, 0xa3, 0xbe, 0x47, 0x01, 0x94,
	0x98, 0x4e, 0xa3, 0x4f, 0x61, 0xdb, 0x2f, 0x76, 0x59, 0xef, 0x31, 0x46, 0x47, 0xfc, 0xf2, 0xc0,
	0x55, 0x43, 0x70, 0x5f, 0xbc, 0x1f, 0x4e, 0x92, 0x13, 0xff, 0x54, 0x68, 0x5b, 0xb1, 0x4d, 0x50,
	0x46, 0xb7, 0x04, 0xc0, 0x77, 0x68, 0x19, 0x45, 0xc7, 0x80, 0xc5, 0x19, 0xad, 0x1a, 0x23, 0x8d,
	0xf7, 0x02, 0x8e, 0xfb, 0x48, 0xfc, 0x70, 0x12, 0x9d, 0x51, 0x2e, 0x88, 0x28, 0xdc, 0x37, 0x0f,
	0xae, 0x00, 0x84, 0x36, 0xf0, 0x3b, 0xd2, 0xc1, 0x35, 0x30, 0x39, 0xc5, 0x89, 0xa6, 0x1c, 0x51,
	0x0e, 0x80, 0x23, 0xd5, 0x09, 0x66, 0x27, 0x22, 0xf6, 0xe6, 0x41, 0x8a, 0x6d, 0xa5, 0xdd, 0xd1,
	0x26, 0x8a, 0x67, 0x1b, 0x94, 0xe3, 0x08, 0xb5, 0x9a, 0x74, 0xb6, 0x41, 0xc3, 0xe4, 0x7e, 0xc7,
	0x1e, 0x0d, 0x22, 0x3c, 0x02, 0xef, 0xf7, 0xbc, 0x8e, 0x4b, 0xa9, 0x7a, 0x7c, 0xc6, 0x88, 0x38,
	0xff, 0xb6, 0x4c, 0x2f, 0xd6, 0xb8, 0x81, 0x81, 0x25, 0x54, 0x5b, 0x6c, 0xe5, 0xd4, 0x91, 0x51,
	0x6e, 0x8d, 0x17, 0x61, 0x18, 0x0f, 0x2f, 0x38, 0x0e, 0xfd, 0x74, 0x1e, 0x8b, 0xf6, 0xf4, 0x58,
	0x66, 0x11, 0x6b, 0xdc, 0x04, 0xd1, 0xb2, 0xce, 0x67, 0xb3, 0x28, 0x4e, 0xc5, 0x04, 0x6d, 0xbf,
	0xcc, 0x18, 0xd6, 0x78, 0x11, 0x36, 0x6a, 0xba, 0x51, 0x10, 0xa6, 0xc9, 0xc6, 0x8d, 0x42, 0x4d,
	0x09, 0x83, 0x78, 0xb6, 0xfb, 0xee, 0x50, 0xe6, 0xfe, 0x1b, 0x5c, 0x12, 0xc0, 0x83, 0x5f, 0xf5,
	0x1f, 0x61, 0x72, 0xbf, 0xc1, 0xe1, 0x31, 0x17, 0xee, 0x5b, 0x4b, 0x85, 0xfb, 0xb6, 0xbe, 0x84,
	0x9e, 0x9f, 0x38, 0xd9, 0xb8, 0xe0, 0xc4, 0xc9, 0x9b, 0xc6, 0x89, 0x13, 0x2d, 0xb3, 0x7e, 0xe7,
	0xc2, 0xb5, 0xa0, 0xb7, 0xcc, 0xb5, 0xa0, 0x7b, 0x8c, 0x65, 0xa3, 0x96, 0x6c, 0xdc, 0xc5, 0xce,
	0x69, 0x88, 0xf3, 0x77, 0x4b, 0x6c, 0xb5, 0xe7, 0x7a, 0x62, 0xdc, 0xde, 0xbd, 0x7c, 0xb1, 0x52,
	0xad, 0x67, 0xab, 0xc5, 0x4a, 0x45, 0xa3, 0x2c, 0xb8, 0xd9, 0x3e, 0x55, 0xcf, 0xed, 0xa9, 0x15,
	0xe3, 0x6a, 0xb6, 0x62, 0x0c, 0xc6, 0xb0, 0x3d, 0x4f, 0x4f, 0xc0, 0x18, 0xc9, 0x74, 0x3e, 0xda,
	0x7a, 0xe9, 0x21, 0x2f, 0x29, 0x71, 0x66, 0xac, 0x8e, 0x0d, 0xdb, 0xf6, 0x2e, 0x53, 0xcb, 0xf4,
	0xeb, 0xe5, 0x85, 0x5f, 0xaf, 0xe4, 0xbf, 0xee, 0xb0, 0x66, 0x5f, 0x84, 0xdb, 0xe1, 0x38, 0x3e,
	0x9f, 0xa5, 0x42, 0xad, 0x6d, 0x1b, 0x98, 0xf3, 0xeb, 0x65, 0xb6, 0xf2, 0x44, 0x84, 0xe2, 0x85,
	0xf8, 0xd4, 0xf1, 0xd1, 0xdb, 0xac, 0x45, 0x36, 0xc5, 0xf0, 0x76, 0x4c, 0x10, 0x53, 0x6e, 0xed,
	0x81, 0x3c, 0xd1, 0x44, 0x7b, 0xc8, 0x72, 0x00, 0x27, 0x69, 0x1c, 0x00, 0x2f, 0xa6, 0xf2, 0x35,
	0x8a, 0x9a, 0x0a, 0xa8, 0xb1, 0xd7, 0x67, 0xa5, 0xb0, 0xd7, 0xc7, 0x62, 0x95, 0x83, 0x61, 0x8f,
	0x72, 0xa0, 0xf0, 0xa8, 0x5b, 0xc4, 0xba, 0x61, 0x11, 0x65, 0x8f, 0x8b, 0x16, 0xf1, 0x7b, 0xac,
	0xa9, 0x17, 0xe4, 0x49, 0xc6, 0x92, 0x9e, 0x07, 0xbf, 0x20, 0x1d, 0xb9, 0x64, 0xe1, 0xfa, 0xa2,
	0x55, 0x58, 0x95, 0x36, 0xa9, 0x69, 0x69, 0x93, 0xff, 0x5a, 0x62, 0xb5, 0x83, 0x8f, 0xfa, 0xed,
	0xe1, 0x25, 0xc3, 0x70, 0x9f, 0xad, 0x1d, 0xf8, 0xd3, 0x60, 0xd2, 0xeb, 0xc2, 0x6f, 0xa8, 0x43,
	0x0b, 0x1a, 0xa4, 0xd8, 0x50, 0xc9, 0xd9, 0x00, 0x11, 0xda, 0x96, 0x9b, 0x4d, 0x00, 0xe2, 0xbe,
	0x81, 0x51, 0x9d, 0x6e, 0x04, 0x36, 0xcf, 0x8f, 0x15, 0xfb, 0x0d, 0x0c, 0xe6, 0xd5, 0x93, 0x2d,
	0x17, 0x0f, 0xba, 0x8a, 0x09, 0x05, 0x6e, 0x1a, 0x02, 0xfa, 0xfe, 0xc9, 0x96, 0x8b, 0x6a, 0x46,
	0x9e, 0xd6, 0xe8, 0x75, 0x95, 0xbe, 0x2f, 0xe2, 0xce, 0x5f, 0xab, 0xb1, 0xca, 0xbe, 0xb7, 0x75,
	0xe5, 0x75, 0xab, 0x2a, 0xae, 0x5b, 0xdd, 0x65, 0x8d, 0xed, 0x17, 0xca, 0x0c, 0x93, 0x33, 0x97,
	0x01, 0xb4, 0xc1, 0x28, 0x4c, 0x8e, 0x44, 0xac, 0x9f, 0x4e, 0xd3, 0x31, 0xf8, 0x42, 0x37, 0x88,
	0xe5, 0x01, 0x63, 0xb5, 0x65, 0x25, 0x03, 0x30, 0xa5, 0x10, 0x4e, 0x66, 0xa0, 0xfe, 0xc8, 0x63,
	0x94, 0x42, 0x56, 0x40, 0x41, 0xe4, 0xbb, 0xe2, 0x45, 0x90, 0x05, 0x2c, 0xd4, 0x4d, 0x13, 0x04,
	0xa9, 0xd8, 0x9a, 0x27, 0xd9, 0xd9, 0x07, 0x49, 0x60, 0x2b, 0x55, 0x07, 0x3d, 0x31, 0xa6, 0xe3,
	0x7b, 0x06, 0x66, 0x1c, 0x4f, 0xdc, 0x4f, 0xc4, 0x98, 0x3c, 0x13, 0x13, 0x44, 0xbd, 0x2b, 0xd2,
	0xf9, 0x8c, 0x56, 0x97, 0x25, 0x91, 0x49, 0x97, 0x5c, 0x60, 0x96, 0xab, 0x2e, 0xa0, 0x75, 0x65,
	0x12, 0x41, 0x06, 0x8c, 0x44, 0xa1, 0x6b, 0x16, 0x1f, 0x92, 0x90, 0xae, 0xcb, 0xf4, 0x52, 0x06,
	0x40, 0x2b, 0xf6, 0xe3, 0x43, 0x6d, 0x89, 0xe7, 0x9a, 0xdc, 0x50, 0x61, 0x80, 0x20, 0x91, 0xfb,
	0xf1, 0xa1, 0x0a, 0xb3, 0x71, 0x39, 0xba, 0xc5, 0x75, 0x88, 0xbe, 0xe3, 0xa5, 0x7e, 0x9c, 0xee,
	0xc4, 0xfe, 0x99, 0xdc, 0xcf, 0x26, 0xbf, 0x93, 0x83, 0xf6, 0x63, 0x76, 0x6b, 0x3f, 0x3e, 0xec,
	0x44, 0xb3, 0xf3, 0xbd, 0x23, 0x35, 0x64, 0x72, 0x52, 0xd9, 0x58, 0xfd, 0x82, 0x52, 0x99, 0x6c,
	0x89, 0x86, 0xf3, 0xb3, 0xae, 0x48, 0xc6, 0xb8, 0x80, 0xdd, 0xe2, 0x1a, 0xa2, 0xaf, 0x26, 0xdf,
	0x34, 0x57, 0x93, 0xff, 0xa0, 0xc4, 0x6e, 0xee, 0x7b, 0x5b, 0x5c, 0x3c, 0x9f, 0x8b, 0x24, 0xdd,
	0x9a, 0x46, 0xe3, 0x53, 0xc9, 0xc2, 0x4b, 0xa7, 0x20, 0xbd, 0xa2, 0xe9, 0x01, 0x1d, 0x92, 0x3e,
	0x2d, 0x92, 0xca, 0xf9, 0x22, 0x32, 0xdf, 0xab, 0x4e, 0x07, 0xcf, 0x64, 0xea, 0xe2, 0x26, 0xab,
	0xf5, 0xc2, 0x89, 0x78, 0x45, 0x02, 0x29, 0x09, 0x4d, 0x7d, 0xac, 0xe8, 0xea, 0xc3, 0xf9, 0xc3,
	0x32, 0xab, 0xf4, 0x3b, 0x83, 0xcb, 0xfd, 0xf6, 0x81, 0x7f, 0x1c, 0x8c, 0xd5, 0x76, 0x20, 0x24,
	0x96, 0x1c, 0x29, 0xab, 0x2c, 0x3d, 0x52, 0x56, 0x58, 0xa4, 0xaf, 0x2e, 0x2e, 0xd2, 0x2f, 0xee,
	0x11, 0xab, 0x2d, 0xdd, 0x23, 0xb6, 0x78, 0x38, 0x6d, 0x65, 0xe9, 0xe1, 0xb4, 0x2f, 0xb2, 0x75,
	0x3c, 0x10, 0x9b, 0x6f, 0x17, 0x93, 0x73, 0xaa, 0x80, 0xa2, 0x2f, 0x7e, 0xe2, 0x87, 0xa1, 0x98,
	0xe2, 0x5a, 0x42, 0x9d, 0x7c, 0xf1, 0x1c, 0x52, 0x3b, 0x48, 0xa1, 0xba, 0x98, 0xd0, 0xee, 0x0c,
	0x0d, 0x71, 0x7e, 0xb3, 0xc4, 0xaa, 0x03, 0xb7, 0xef, 0x5d, 0xce, 0x40, 0xb9, 0x0d, 0x91, 0x18,
	0x28, 0xb7, 0x20, 0x5e, 0x65, 0x13, 0xa3, 0xdc, 0xcd, 0x3c, 0x3e, 0xdd, 0x8a, 0xd2, 0x34, 0x3a,
	0x23, 0x75, 0xab, 0x43, 0x6a, 0x2d, 0xb5, 0x96, 0x6d, 0x62, 0x75, 0xfe, 0xb4, 0xc4, 0x1a, 0x83,
	0x68, 0x72, 0x38, 0x4f, 0x2e, 0xdf, 0x1f, 0xf3, 0x01, 0x7b, 0x43, 0x4f, 0xf9, 0x17, 0xa3, 0xdf,
	0xe5, 0x85, 0xe0, 0x8b, 0x28, 0x53, 0xa9, 0xbd, 0x22, 0xdb, 0xbf, 0xa4, 0xe4, 0x42, 0xeb, 0x85,
	0xe7, 0xd2, 0x82, 0x54, 0xfb, 0x06, 0x0d, 0xbc, 0x89, 0xea, 0xf3, 0x6e, 0xc5, 0x9c, 0x77, 0x7f,
	0x54, 0x61, 0x2b, 0x7b, 0x9e, 0xbb, 0xf3, 0x62, 0xf3, 0x53, 0xfb, 0x1c, 0x4b, 0xb2, 0x06, 0x30,
	0x34, 0xd2, 0x9b, 0x30, 0x9a, 0x6d, 0x60, 0xe8, 0xd0, 0x61, 0x5c, 0x4d, 0xbb, 0xad, 0x5b, 0x3c,
	0xa3, 0x71, 0xab, 0x50, 0x2c, 0x7c, 0x5a, 0x57, 0x69, 0x71, 0xa2, 0x8c, 0xe4, 0xe7, 0xea, 0xe2,
	0x96, 0x9a, 0xf6, 0x1c, 0x5b, 0x22, 0x75, 0x3c, 0x51, 0x78, 0x9d, 0x82, 0xe1, 0xde, 0x91, 0x9a,
	0x2f, 0xa0, 0xf6, 0xdb, 0xac, 0xda, 0xf7, 0xda, 0xc9, 0x06, 0x33, 0x76, 0xd7, 0xf4, 0xbd, 0xf6,
	0x09, 0xa6, 0x92, 0x39, 0x96, 0xda, 0x9f, 0x67, 0x95, 0xbe, 0xb7, 0x4f, 0x8b, 0xdd, 0xd7, 0xb2,
	0x4a, 0xfb, 0xb3, 0x89, 0x9f, 0x0a, 0x0e, 0x65, 0xf6, 0x3d, 0xa8, 0xc2, 0x29, 0x91, 0xd8, 0xcc,
	0xaa, 0x70, 0xf1, 0x1c, 0xca, 0xb9, 0xfd, 0x80, 0xad, 0x74, 0x0f, 0x51, 0x43, 0xb6, 0xcc, 0x13,
	0x53, 0x08, 0xba, 0xa7, 0xc7, 0x9c, 0xca, 0xed, 0xaf, 0xb0, 0x55, 0x0c, 0x3a, 0x0f, 0x36, 0xe9,
	0x90, 0xa7, 0x5a, 0x77, 0x43, 0xd4, 0x3d, 0x3d, 0x3e, 0xd8, 0xe4, 0xaa, 0x86, 0xf3, 0xaf, 0xca,
	0xac, 0xae, 0x70, 0x79, 0x17, 0x0e, 0x6d, 0x6c, 0xa7, 0x73, 0x9e, 0x2d, 0xae, 0x43, 0xa8, 0x3a,
	0xd3, 0xb8, 0x70, 0x90, 0x58, 0x87, 0x60, 0xc8, 0xf3, 0x6c, 0x09, 0x2e, 0x66, 0xab, 0xfd, 0x45,
	0x10, 0x97, 0xc2, 0x2f, 0x65, 0x96, 0x46, 0x9d, 0xd7, 0xd6, 0x41, 0x5c, 0xc8, 0xc0, 0x01, 0xed,
	0x0a, 0x7f, 0x92, 0x55, 0x95, 0x43, 0xbd, 0xa4, 0x04, 0xea, 0x77, 0x45, 0x82, 0xa1, 0x94, 0x98,
	0x64, 0xa2, 0x21, 0x05, 0x60, 0x49, 0x89, 0xfd, 0x2d, 0xb6, 0xb1, 0xe5, 0x8f, 0x4f, 0xe7, 0xb3,
	0x25, 0x6f, 0x49, 0xcf, 0xf3, 0xc2, 0x72, 0xb9, 0x29, 0x57, 0x66, 0x99, 0xd0, 0x29, 0xa8, 0x80,
	0xa5, 0xca, 0x11, 0xe7, 0xbf, 0x95, 0x19, 0xcb, 0x99, 0xfc, 0x0b, 0x76, 0xfe, 0xd9, 0xd8, 0x09,
	0xdc, 0xa1, 0x8b, 0x32, 0x06, 0x7e, 0x72, 0x4a, 0x99, 0x03, 0x1d, 0x72, 0x7e, 0xbf, 0xc4, 0x1a,
	0xd9, 0x04, 0xd0, 0x79, 0x55, 0x32, 0x79, 0xa5, 0x96, 0x16, 0x80, 0xed, 0x83, 0xd1, 0xbe, 0x4a,
	0xf9, 0xea, 0xd8, 0x05, 0x21, 0xc0, 0x7d, 0xb6, 0xd6, 0xed, 0xe6, 0xf9, 0x47, 0xb9, 0xcf, 0x43,
	0x87, 0xec, 0x87, 0x6c, 0xb5, 0xef, 0xb5, 0x83, 0xf0, 0x28, 0xa2, 0x03, 0x7b, 0x8b, 0x4a, 0x40,
	0x55, 0x70, 0xfe, 0xb9, 0x52, 0x9c, 0x8f, 0xfe, 0xbf, 0x57, 0x9c, 0x77, 0x58, 0xbd, 0x17, 0x26,
	0xa9, 0x1f, 0x8e, 0x95, 0xea, 0xcc, 0x68, 0x23, 0xea, 0x6e, 0x14, 0xa2, 0xee, 0x2f, 0xb0, 0x1a,
	0x4a, 0x28, 0x7a, 0xc4, 0xb9, 0x32, 0x54, 0xd3, 0x86, 0xcb, 0x52, 0x4d, 0xdd, 0xad, 0x5d, 0xa2,
	0xee, 0x2e, 0x53, 0x9c, 0xa4, 0x7b, 0x5b, 0xaf, 0xd1, 0xbd, 0x4a, 0x89, 0xaf, 0xbf, 0x4e, 0x89,
	0x3b, 0xff, 0xa3, 0xc4, 0x1a, 0x19, 0x86, 0xde, 0x85, 0xd7, 0x3e, 0x56, 0x29, 0x77, 0x49, 0xa0,
	0xcd, 0xf5, 0x34, 0xaf, 0x92, 0x28, 0x10, 0xa3, 0x7e, 0x10, 0x9e, 0x82, 0xd7, 0x2e, 0xe8, 0x58,
	0x68, 0x8b, 0xeb, 0x10, 0x9e, 0x9a, 0x9f, 0xbc, 0xa0, 0xa3, 0x58, 0x74, 0x70, 0x22, 0x03, 0xf0,
	0x7d, 0x2f, 0x17, 0xc3, 0x1a, 0xbd, 0x9f, 0x43, 0x30, 0x99, 0xfa, 0x5e, 0x36, 0x5a, 0xb4, 0x1f,
	0x36, 0x47, 0x34, 0x6f, 0x60, 0xd5, 0xf0, 0x06, 0xee, 0x42, 0xa7, 0xf2, 0x20, 0x1b, 0xe3, 0xa9,
	0x0c, 0x70, 0xfe, 0x67, 0x05, 0xb8, 0xd7, 0x86, 0xe1, 0xa0, 0xa3, 0x08, 0x25, 0x63, 0x38, 0x72,
	0x1e, 0xa9, 0x9b, 0xd6, 0x1e, 0xb2, 0x15, 0xde, 0xf7, 0xda, 0x07, 0x9b, 0x74, 0xf6, 0x4d, 0x6d,
	0xca, 0xa3, 0xbd, 0xde, 0x50, 0xc2, 0xa9, 0x86, 0xbd, 0xc9, 0xea, 0x6d, 0x6f, 0x5b, 0xd6, 0xae,
	0x18, 0x07, 0x04, 0xdb, 0x1e, 0x44, 0xb6, 0x71, 0xe8, 0x4f, 0xe5, 0x1b, 0x59, 0x3d, 0x18, 0x2b,
	0x78, 0x9b, 0x0e, 0xc7, 0x5b, 0xc5, 0xaf, 0x73, 0x2c, 0xb5, 0xbf, 0xc0, 0xaa, 0x43, 0xa8, 0x55,
	0x33, 0x0c, 0x20, 0xa9, 0x0e, 0xac, 0x06, 0xc5, 0x76, 0x87, 0x0e, 0x78, 0xb5, 0xdd, 0x58, 0x1c,
	0x05, 0xaf, 0xe0, 0x0d, 0x79, 0x50, 0x31, 0x5b, 0x7e, 0xc2, 0xd2, 0x58, 0xf8, 0x59, 0x05, 0x5e,
	0x7c, 0xc3, 0xfe, 0x36, 0x5b, 0xeb, 0xb5, 0xb3, 0x06, 0x20, 0x7b, 0x97, 0x7c, 0x20, 0x6f, 0xa1,
	0x5e, 0xdb, 0x7e, 0x87, 0xad, 0xc8, 0xae, 0x21, 0xef, 0xf3, 0xb3, 0xc5, 0x06, 0x03, 0x38, 0xd5,
	0xb1, 0x1d, 0x56, 0xed, 0x43, 0xdd, 0x06, 0xd6, 0x5d, 0xd7, 0x8f, 0x38, 0x42, 0x9f, 0xfa, 0x79,
	0x9f, 0x62, 0x5f, 0xeb, 0x13, 0x2b, 0x36, 0x29, 0xf6, 0x17, 0xfb, 0xa4, 0xbf, 0xe1, 0x3c, 0x03,
	0xe9, 0xe6, 0xe2, 0xb9, 0x26, 0xd0, 0x25, 0x43, 0xa0, 0x6d, 0x98, 0x32, 0x14, 0xda, 0xb7, 0x38,
	0x3e, 0x9b, 0x22, 0x5c, 0x29, 0x88, 0xb0, 0xb3, 0xcb, 0xea, 0x6a, 0xd6, 0x41, 0xcd, 0xe1, 0xfc,
	0x6c, 0xef, 0x08, 0x67, 0x9d, 0xd4, 0xd5, 0x39, 0x60, 0xdf, 0xa3, 0xe9, 0x28, 0x17, 0x41, 0x58,
	0x2e, 0x6a, 0x34, 0x11, 0xff, 0x6d, 0x89, 0xd9, 0x8b, 0x9d, 0x00, 0x83, 0x88, 0xdf, 0x90, 0x88,
	0x50, 0x59, 0x1f, 0x13, 0x94, 0x47, 0x5e, 0x8e, 0x8c, 0x49, 0x9a, 0x03, 0x72, 0xd1, 0xfe, 0x68,
	0x71, 0xaa, 0x16, 0x50, 0xb9, 0x01, 0xe0, 0xa8, 0x38, 0x61, 0x0d, 0xcc, 0x7e, 0x87, 0xd5, 0xb3,
	0xa6, 0x2c, 0x58, 0x06, 0x59, 0xc2, 0xb3, 0x1a, 0xce, 0xbf, 0x2e, 0xb3, 0x96, 0x31, 0xe8, 0xb9,
	0x41, 0x2a, 0x15, 0x72, 0x52, 0x03, 0x91, 0xc6, 0x14, 0x17, 0xb6, 0x38, 0x51, 0x68, 0x03, 0x24,
	0x2b, 0x8c, 0x15, 0x4b, 0x1d, 0x03, 0x0e, 0x49, 0x3a, 0x3f, 0x2b, 0x82, 0x1c, 0x32, 0x40, 0x93,
	0x43, 0xb5, 0x22, 0x87, 0xde, 0x66, 0x2d, 0x4a, 0x8f, 0xc8, 0xb7, 0xd4, 0x1e, 0x26, 0x03, 0xb4,
	0xdf, 0x61, 0xd7, 0x77, 0xa2, 0xf8, 0xa5, 0x1f, 0x4f, 0x82, 0xf0, 0xd8, 0xbc, 0x32, 0x67, 0xb1,
	0xc0, 0x7e, 0xc8, 0x2c, 0xd5, 0x71, 0xe4, 0xdd, 0xc8, 0x3f, 0xa6, 0xbd, 0x32, 0x0b, 0xf8, 0x92,
	0x11, 0x6a, 0x2c, 0x1b, 0x21, 0xe7, 0x77, 0xa4, 0x90, 0x14, 0x66, 0xaf, 0xc6, 0xbe, 0xd2, 0x6b,
	0xd9, 0x57, 0xbe, 0x0a, 0xfb, 0x2a, 0xcb, 0xd8, 0xb7, 0xc0, 0xa0, 0xea, 0x12, 0x06, 0x39, 0xaf,
	0xb4, 0xd6, 0xe5, 0xda, 0xe0, 0x62, 0x0f, 0xe6, 0xa2, 0x61, 0x7f, 0x8f, 0xdd, 0xe8, 0x8a, 0x24,
	0x0d, 0x42, 0x0c, 0x47, 0x32, 0x0b, 0x2f, 0xa5, 0x76, 0x59, 0x91, 0xf3, 0xa3, 0x12, 0xbb, 0x56,
	0x50, 0xaf, 0x45, 0x4f, 0xab, 0xb4, 0xe0, 0x69, 0x41, 0x0d, 0xf5, 0xca, 0x56, 0x76, 0xf0, 0x47,
	0x87, 0xb4, 0x16, 0x56, 0x8c, 0x16, 0x2e, 0x15, 0x05, 0x39, 0x5f, 0xae, 0x28, 0x0a, 0xb5, 0xe5,
	0xa2, 0xe0, 0x4c, 0x58, 0x23, 0x67, 0xdd, 0xf2, 0xd9, 0xb2, 0xa1, 0x2f, 0xa9, 0x1a, 0x0c, 0xfd,
	0x12, 0x5b, 0x95, 0x2f, 0xab, 0x55, 0xdd, 0x96, 0x61, 0x4a, 0xb8, 0x2a, 0x75, 0xfe, 0xa0, 0xa4,
	0x4e, 0x48, 0x5f, 0xb4, 0x2d, 0x51, 0x1b, 0x98, 0x5a, 0xd6, 0xed, 0x82, 0xf3, 0x5f, 0x59, 0x74,
	0xfe, 0xdf, 0x63, 0x37, 0x32, 0x67, 0x57, 0xab, 0x29, 0x59, 0xb3, 0xac, 0x08, 0x98, 0xa3, 0xe0,
	0x82, 0x2f, 0xb7, 0x80, 0x3b, 0x13, 0xb6, 0xa6, 0x99, 0xdc, 0x0b, 0xd8, 0x03, 0x4e, 0x4c, 0x10,
	0x9e, 0x66, 0x47, 0xce, 0x90, 0xb0, 0xbf, 0x5c, 0x64, 0xcd, 0x35, 0x83, 0x35, 0x10, 0x3e, 0x2a,
	0xe6, 0xfc, 0x65, 0xe5, 0x55, 0x1e, 0x6c, 0x5e, 0xb8, 0x69, 0x33, 0x08, 0x4f, 0x33, 0x43, 0x41,
	0x94, 0xda, 0x41, 0x99, 0x6d, 0x3e, 0x6c, 0xf1, 0x8c, 0xd6, 0x38, 0x5a, 0xd5, 0x05, 0xc9, 0x19,
	0x42, 0xb8, 0xa0, 0x0c, 0xf8, 0x6b, 0xa6, 0x0a, 0x84, 0xee, 0x69, 0xea, 0x8f, 0x4f, 0x54, 0xa8,
	0x81, 0x86, 0xa4, 0xc5, 0x0b, 0xa8, 0xf3, 0x2f, 0x4a, 0x6c, 0x95, 0x4c, 0x67, 0x31, 0x10, 0x2b,
	0xbd, 0x36, 0x10, 0x2b, 0x48, 0xd2, 0x43, 0x66, 0xe1, 0x67, 0xa2, 0xb1, 0x3f, 0xd5, 0x0f, 0xe9,
	0x35, 0xf9, 0x02, 0xbe, 0x68, 0xa3, 0x64, 0x17, 0x0b, 0x36, 0xea, 0x93, 0x59, 0x8e, 0x1f, 0x4a,
	0xbf, 0x94, 0x34, 0x6f, 0x51, 0x91, 0x95, 0xae, 0xa2, 0xc8, 0xca, 0xcb, 0x14, 0x99, 0x39, 0xa1,
	0x73, 0xc9, 0xbe, 0x9a, 0x82, 0xfb, 0x61, 0x8d, 0x55, 0xb6, 0x76, 0xba, 0x9f, 0x3a, 0xce, 0xb9,
	0xc7, 0x58, 0x37, 0xf0, 0x8f, 0xc3, 0x28, 0x49, 0xb3, 0x16, 0x68, 0x08, 0xe6, 0xce, 0x41, 0xd5,
	0xab, 0x44, 0x2c, 0x12, 0xd9, 0x06, 0x4d, 0xb9, 0xfa, 0x21, 0x37, 0x68, 0x82, 0xe8, 0x07, 0xa1,
	0x3f, 0x55, 0x37, 0x19, 0x20, 0x61, 0x7f, 0x83, 0xdd, 0xa6, 0x9d, 0xa6, 0xee, 0xd4, 0x0f, 0x45,
	0x2f, 0x9c, 0x88, 0x99, 0x08, 0x27, 0x22, 0x4c, 0xe9, 0x38, 0xcc, 0x45, 0xc5, 0x20, 0x2b, 0xed,
	0x79, 0x7a, 0xe2, 0xc6, 0x22, 0x81, 0xda, 0x74, 0xd7, 0x81, 0x06, 0xe1, 0x5a, 0xa8, 0xc0, 0x5b,
	0x69, 0x1a, 0x74, 0x4b, 0x02, 0x52, 0xb8, 0x72, 0x3f, 0x9f, 0xa6, 0x01, 0xae, 0x44, 0xd0, 0x21,
	0x33, 0x0d, 0x01, 0x49, 0xea, 0x8a, 0x54, 0x8c, 0x53, 0x89, 0x4d, 0x83, 0xec, 0x26, 0xb0, 0x05,
	0x1c, 0xf7, 0xfe, 0x9d, 0x77, 0x83, 0x64, 0x1c, 0x07, 0x67, 0xa0, 0xe2, 0xa3, 0x98, 0x16, 0xbc,
	0x8b, 0x30, 0x28, 0xe0, 0xef, 0x46, 0xf3, 0xd8, 0xac, 0x2b, 0x97, 0x11, 0x16, 0x0b, 0xec, 0x4d,
	0x76, 0x13, 0x42, 0xf5, 0x58, 0x4c, 0x06, 0x41, 0x38, 0x7a, 0x95, 0xa5, 0x0c, 0xe4, 0xf1, 0x9b,
	0xa5, 0x65, 0xf6, 0x07, 0xec, 0x0d, 0x2e, 0x9e, 0xcf, 0xa9, 0x80, 0xe7, 0x2f, 0x5d, 0x93, 0xf9,
	0xcc, 0xa5, 0x85, 0xf6, 0x77, 0xd8, 0x9b, 0x5a, 0xc1, 0xf6, 0xf8, 0x24, 0xd2, 0xde, 0x94, 0x87,
	0xe2, 0x2e, 0xae, 0x60, 0x7f, 0xc0, 0x18, 0xb0, 0x9c, 0xa2, 0x92, 0xeb, 0x86, 0xf3, 0xbc, 0xb5,
	0xd3, 0xcd, 0xcb, 0xb8, 0x56, 0xcf, 0xf9, 0x2b, 0xac, 0x65, 0x14, 0xe2, 0xf5, 0x6d, 0xf3, 0xf4,
	0x44, 0x53, 0x5c, 0x19, 0x0d, 0x82, 0xf3, 0x54, 0x9c, 0x67, 0xe7, 0xae, 0x24, 0x71, 0xe5, 0x0c,
	0xfc, 0xb2, 0xfb, 0x5f, 0x7e, 0xb3, 0xca, 0x2a, 0x4f, 0xf8, 0xf6, 0xe5, 0x97, 0xbd, 0xa8, 0xb0,
	0x4d, 0x09, 0x99, 0x5c, 0x26, 0x2c, 0xc2, 0xea, 0x64, 0x6d, 0x10, 0x1e, 0xab, 0x8a, 0x72, 0xf7,
	0x75, 0x01, 0x05, 0xc1, 0x7b, 0x2a, 0xce, 0x55, 0x1d, 0x99, 0xcf, 0xd6, 0x10, 0xb9, 0xbd, 0xff,
	0xb9, 0x2a, 0xa7, 0xfd, 0xae, 0x39, 0x02, 0x22, 0xe4, 0xc1, 0xdc, 0xa7, 0x2b, 0xb1, 0x51, 0x81,
	0xd2, 0x74, 0x5a, 0x2c, 0xc0, 0xad, 0x89, 0xe3, 0x53, 0xf5, 0x35, 0x39, 0x9b, 0x34, 0x84, 0x76,
	0x14, 0xcf, 0x71, 0x9e, 0xab, 0xcd, 0xdf, 0xd9, 0xbe, 0x1f, 0x13, 0xcf, 0xed, 0x56, 0xa3, 0x60,
	0xd6, 0x95, 0xda, 0x60, 0xa6, 0xda, 0xd0, 0xd7, 0x97, 0xd7, 0x5e, 0x73, 0x97, 0x44, 0x73, 0x31,
	0x0f, 0x4c, 0xab, 0x20, 0xb4, 0xc0, 0x96, 0x1f, 0x23, 0x7d, 0x2a, 0xce, 0x69, 0x69, 0x0d, 0x1e,
	0xd5, 0x32, 0xbd, 0x5c, 0x4a, 0xc3, 0x65, 0x7a, 0x8b, 0x55, 0xda, 0xe3, 0x53, 0x5a, 0x38, 0x83,
	0x47, 0xfb, 0x2b, 0xd2, 0x82, 0x06, 0xe1, 0x31, 0x49, 0xa6, 0x8a, 0x40, 0x9f, 0xf0, 0x6d, 0x2a,
	0xe0, 0xaa, 0x06, 0xd8, 0x21, 0x96, 0xe3, 0x9a, 0x7a, 0xdd, 0xf1, 0xcf, 0x82, 0xa9, 0x32, 0x46,
	0x26, 0x88, 0x5b, 0x66, 0xf8, 0x36, 0x35, 0x59, 0x5d, 0x78, 0xa4, 0x00, 0x2a, 0x35, 0x22, 0x81,
	0x1c, 0x50, 0x39, 0xc1, 0x20, 0x3c, 0xee, 0x85, 0x47, 0x51, 0x7c, 0xe6, 0x67, 0x97, 0x01, 0x35,
	0xf9, 0x92, 0x12, 0x0c, 0xa6, 0xc5, 0xab, 0xb4, 0x10, 0x4c, 0x6b, 0x5d, 0xc1, 0x62, 0xe7, 0xb7,
	0x4a, 0xac, 0xba, 0xd3, 0xed, 0xf6, 0x2e, 0x91, 0x6e, 0x87, 0x35, 0x71, 0xbd, 0x50, 0x8d, 0x3c,
	0x79, 0xda, 0x3a, 0x66, 0x9c, 0x76, 0xaa, 0x2c, 0x9e, 0x76, 0xfa, 0x24, 0x77, 0xfb, 0x3a, 0x3f,
	0x28, 0xb1, 0xca, 0x76, 0xfb, 0x0a, 0xdb, 0xab, 0xb5, 0xe3, 0xfe, 0x55, 0x75, 0x78, 0xb2, 0xa7,
	0xf6, 0x8c, 0x97, 0x7b, 0x93, 0xd7, 0x6d, 0x07, 0x28, 0x5e, 0x79, 0xa9, 0xae, 0x10, 0xd0, 0x8e,
	0xcf, 0x65, 0xb4, 0x73, 0xca, 0x6a, 0xdb, 0x6d, 0x77, 0xaf, 0xff, 0x53, 0xcd, 0x01, 0x5e, 0xd0,
	0x38, 0xe7, 0xef, 0xd5, 0x58, 0x1d, 0x7f, 0x0d, 0x64, 0xf7, 0xf5, 0x3f, 0xf8, 0x0e, 0xbb, 0xfe,
	0x54, 0x9c, 0xab, 0xab, 0xa0, 0x22, 0xfd, 0x46, 0xd6, 0xc5, 0x02, 0x30, 0x14, 0x06, 0x68, 0xee,
	0x56, 0x5b, 0x5a, 0x06, 0x5d, 0x7a, 0x2a, 0xce, 0xb5, 0xb5, 0x7d, 0x45, 0x02, 0xbf, 0x40, 0xbd,
	0x6a, 0x8b, 0xa8, 0x19, 0x0d, 0x6f, 0x61, 0x6a, 0x71, 0xaa, 0x4c, 0xb8, 0x22, 0xa1, 0xd3, 0x4f,
	0xc5, 0x79, 0xbb, 0xf3, 0x54, 0x5d, 0x47, 0x24, 0x29, 0xc2, 0x07, 0xbd, 0x0e, 0x59, 0x67, 0xa2,
	0xe4, 0x49, 0xbe, 0xf1, 0x3c, 0x16, 0xca, 0x30, 0x4b, 0x0a, 0x7e, 0x7d, 0xd0, 0xeb, 0x6c, 0xc7,
	0x71, 0x14, 0x93, 0x59, 0xce, 0x68, 0x7d, 0x2d, 0x58, 0x2e, 0xd3, 0x67, 0x6b, 0xc1, 0xef, 0xb1,
	0x1b, 0xbb, 0x7e, 0x92, 0x6d, 0xc5, 0x81, 0x1e, 0xe7, 0xeb, 0xf6, 0xcb, 0x8a, 0x50, 0xcf, 0x0e,
	0x9e, 0xd2, 0x5e, 0x3d, 0x3a, 0x2f, 0xae, 0x21, 0x30, 0x3e, 0x4f, 0xc5, 0xb9, 0xb6, 0x9c, 0x5f,
	0xe3, 0x39, 0x20, 0xef, 0x47, 0x98, 0x4d, 0xfd, 0x73, 0x3c, 0x85, 0x24, 0x62, 0xd4, 0x41, 0x55,
	0x6e, 0x82, 0xa0, 0x31, 0x87, 0x51, 0x38, 0x16, 0xa8, 0x8f, 0x9a, 0x5c, 0x12, 0x28, 0xcb, 0x07,
	0xa8, 0x8c, 0x9a, 0xbc, 0xdc, 0x3b, 0x90, 0x47, 0xdf, 0x3b, 0xb8, 0x32, 0x5f, 0xe5, 0xf0, 0x48,
	0x5b, 0x35, 0x6e, 0x64, 0x5b, 0x35, 0x2c, 0x56, 0x01, 0x06, 0xca, 0x25, 0x77, 0x78, 0x84, 0xdf,
	0xa7, 0x8e, 0x50, 0x0b, 0xdf, 0x90, 0x9a, 0xc9, 0x00, 0x31, 0x82, 0x2b, 0xb2, 0xe4, 0x96, 0x74,
	0x87, 0x8b, 0xb8, 0xf3, 0x8f, 0xca, 0x6c, 0xe5, 0x80, 0x73, 0xf7, 0xa7, 0xbf, 0x90, 0x78, 0x10,
	0xc4, 0xe9, 0xdc, 0x9f, 0xf2, 0x34, 0xa6, 0x90, 0xaa, 0xc6, 0x0d, 0xcc, 0x50, 0x31, 0xb5, 0x82,
	0x8a, 0xc1, 0xed, 0xa2, 0xf3, 0x30, 0xed, 0xb9, 0x78, 0x8c, 0x8b, 0x6e, 0x36, 0xd6, 0x20, 0xc3,
	0x6d, 0x58, 0x2d, 0xb8, 0x0d, 0x78, 0x23, 0xec, 0x0b, 0x01, 0x91, 0x9b, 0xca, 0x8c, 0x2b, 0xda,
	0x30, 0x41, 0x8d, 0x82, 0x09, 0xba, 0xcb, 0x1a, 0xf2, 0xeb, 0xf2, 0xb2, 0xdf, 0x0a, 0x70, 0x20,
	0x03, 0x9c, 0xdf, 0x2b, 0xb1, 0xf5, 0x4e, 0x90, 0x8c, 0xa3, 0xab, 0x5e, 0x5c, 0xf8, 0xda, 0x3b,
	0xa0, 0x46, 0xa3, 0xec, 0x0e, 0x28, 0xba, 0x81, 0xe9, 0xc2, 0xe3, 0x21, 0x9b, 0x85, 0xfb, 0x08,
	0xd5, 0x2d, 0x70, 0x66, 0x63, 0xcc, 0xbb, 0x08, 0x3f, 0x64, 0x37, 0x96, 0x14, 0xff, 0x14, 0x2e,
	0x05, 0xfc, 0x3a, 0xbb, 0xd6, 0xe9, 0xba, 0x07, 0xfd, 0xf6, 0xb0, 0x1b, 0xf8, 0xd3, 0xe8, 0x78,
	0xae, 0x2e, 0x25, 0x2c, 0x65, 0x47, 0xe3, 0x6d, 0x56, 0xc5, 0x1b, 0xc5, 0x48, 0x93, 0xc3, 0xb3,
	0xf3, 0xcb, 0x6c, 0xad, 0xd3, 0x75, 0x21, 0x12, 0xbb, 0xf0, 0x78, 0x21, 0x44, 0xa4, 0x54, 0x4e,
	0x3b, 0xa5, 0x33, 0xda, 0xe1, 0xcc, 0xea, 0x74, 0x5d, 0x37, 0x7a, 0x29, 0xe2, 0x0b, 0x7f, 0x16,
	0xa2, 0xa5, 0xe3, 0xb3, 0x34, 0xf3, 0x16, 0x89, 0xc2, 0x9b, 0x38, 0x25, 0xfb, 0x2a, 0x18, 0x85,
	0x2a, 0x16, 0xfd, 0xa0, 0x84, 0x5d, 0xf1, 0x66, 0x7e, 0x2c, 0x5c, 0x3f, 0x88, 0xdd, 0x68, 0x1b,
	0x37, 0x6d, 0x78, 0xdb, 0x3b, 0xd1, 0x3c, 0xfe, 0x30, 0x88, 0x05, 0xdd, 0xf9, 0xa6, 0x43, 0x18,
	0xdd, 0x75, 0xdb, 0xf1, 0xf8, 0xc4, 0x3b, 0xf1, 0x63, 0xda, 0xd3, 0x58, 0xe7, 0x06, 0x86, 0x5f,
	0xe9, 0x92, 0x8e, 0xda, 0x0b, 0xc9, 0x23, 0xd4, 0x21, 0xdc, 0x12, 0xee, 0x6d, 0xef, 0xa9, 0x8d,
	0x64, 0x92, 0x70, 0xfe, 0x4d, 0x9d, 0xd9, 0xe6, 0xa8, 0x5d, 0xe1, 0x62, 0xc2, 0xaf, 0xb0, 0x7a,
	0xa7, 0xeb, 0xca, 0x15, 0x9d, 0xb2, 0xb1, 0xc4, 0xa2, 0x60, 0x9e, 0x55, 0xc0, 0x4b, 0xcf, 0x71,
	0x83, 0x15, 0x25, 0x44, 0x1a, 0x3c, 0xa3, 0x65, 0xf2, 0x58, 0x9d, 0x29, 0x91, 0xc7, 0xb1, 0x72,
	0x00, 0xb8, 0x48, 0x37, 0x6a, 0x92, 0x71, 0xa7, 0xbb, 0x2a, 0xbf, 0xc5, 0x9a, 0xc6, 0x45, 0x85,
	0xe6, 0x35, 0x83, 0x9d, 0xc2, 0x75, 0x7b, 0x46, 0x5d, 0x7d, 0x82, 0xac, 0x9a, 0x7f, 0xdb, 0x02,
	0xba, 0x61, 0xea, 0xa7, 0xe0, 0x01, 0xa9, 0xfb, 0x9e, 0x15, 0x6d, 0xbf, 0xc3, 0x58, 0xcf, 0xcd,
	0xa2, 0xf3, 0x86, 0xb1, 0xea, 0xd4, 0x73, 0x87, 0x22, 0xe5, 0x5a, 0x39, 0xf4, 0xea, 0x60, 0xe4,
	0x76, 0xa3, 0x33, 0x3f, 0x08, 0xe9, 0x10, 0x6f, 0x0e, 0xe0, 0x02, 0xa8, 0x9f, 0x06, 0x2f, 0x04,
	0x0a, 0xec, 0x1a, 0x5d, 0xf2, 0x94, 0x21, 0xb8, 0x11, 0x66, 0x3e, 0x9d, 0x76, 0xe7, 0xb3, 0xa9,
	0x78, 0x45, 0x76, 0x45, 0x43, 0xec, 0x0f, 0x58, 0x03, 0xea, 0xe1, 0x7d, 0x96, 0xb4, 0xc0, 0xa5,
	0x75, 0x5d, 0x9f, 0x25, 0x3c, 0xaf, 0xa8, 0xde, 0x7a, 0x36, 0x17, 0xf1, 0x39, 0xed, 0x10, 0x78,
	0xed, 0x5b, 0x58, 0x11, 0xd4, 0x3a, 0x4e, 0x80, 0x4e, 0x14, 0x26, 0xf3, 0x33, 0xb9, 0xc5, 0x53,
	0x86, 0x77, 0x0b, 0x38, 0x9a, 0x8e, 0xd1, 0xbe, 0x72, 0x88, 0x07, 0xa3, 0x7d, 0x30, 0x1d, 0xb8,
	0x55, 0x71, 0x22, 0x26, 0xa3, 0x78, 0x9e, 0xa4, 0x74, 0xb5, 0x89, 0x09, 0x82, 0x74, 0xef, 0x87,
	0x29, 0x3c, 0x8a, 0x49, 0x67, 0xcf, 0xa3, 0x5b, 0x4e, 0x0c, 0x4c, 0xbf, 0xdf, 0xf2, 0x86, 0x79,
	0xbf, 0x25, 0x18, 0xf7, 0xf3, 0x64, 0xaf, 0xd7, 0x45, 0x9b, 0x05, 0x8e, 0x21, 0x52, 0x78, 0x8d,
	0x55, 0x7e, 0x69, 0xa0, 0x48, 0x36, 0xde, 0x40, 0xe9, 0x32, 0x41, 0xfb, 0x5d, 0x6d, 0xfe, 0xdf,
	0x32, 0x56, 0xae, 0x34, 0xcd, 0x91, 0xeb, 0x04, 0xfb, 0xdb, 0xac, 0x89, 0xfd, 0x56, 0xbe, 0xc1,
	0x6d, 0xe3, 0xa6, 0xc7, 0xa2, 0xba, 0xe0, 0x46, 0x65, 0xfb, 0x57, 0xd8, 0x3a, 0xd2, 0xed, 0x17,
	0x7e, 0x30, 0xf5, 0x0f, 0xa7, 0x02, 0x37, 0x53, 0xbf, 0xe6, 0xf5, 0x42, 0x75, 0x90, 0x7b, 0x4d,
	0x73, 0x08, 0xdc, 0x73, 0x6d, 0x0c, 0xa3, 0xae, 0x57, 0xb8, 0x51, 0x17, 0x22, 0xe7, 0xed, 0x50,
	0xc4, 0xc7, 0xe7, 0x1f, 0x06, 0x89, 0xc0, 0x4d, 0xd9, 0x79, 0xe4, 0xdc, 0xe9, 0xba, 0x79, 0x19,
	0xd7, 0xea, 0xd9, 0x1f, 0xe4, 0x17, 0x6c, 0xbe, 0x75, 0xa9, 0x1d, 0xc8, 0x2e, 0xd7, 0xfc, 0xdf,
	0xe5, 0x5c, 0x3f, 0xe8, 0x97, 0x1f, 0x36, 0xe5, 0xe5, 0x87, 0x78, 0xe1, 0x00, 0x6d, 0x5c, 0x52,
	0x8a, 0x53, 0x43, 0xf0, 0x72, 0xeb, 0x29, 0x0c, 0x7d, 0x3c, 0xf0, 0x13, 0xb5, 0xaa, 0xd4, 0xe0,
	0x26, 0x08, 0xd3, 0x95, 0x7e, 0xef, 0x7d, 0x75, 0x1c, 0x5b, 0xd1, 0xfa, 0x24, 0xaf, 0x2d, 0x24,
	0x98, 0xbc, 0xf9, 0xa1, 0x2a, 0xa4, 0x05, 0xd3, 0x1c, 0xd1, 0xb6, 0x5c, 0xae, 0x1a, 0x5b, 0x2e,
	0xf3, 0x5f, 0xdb, 0x54, 0xe6, 0x5d, 0xd1, 0xf8, 0xe7, 0x49, 0xb2, 0x69, 0x74, 0x0f, 0xb1, 0x88,
	0xe9, 0xc8, 0xca, 0x02, 0x8e, 0x31, 0xda, 0xcb, 0x20, 0x1d, 0x9f, 0x40, 0xc8, 0x42, 0xaa, 0x21,
	0x03, 0xb4, 0x5f, 0x79, 0xa4, 0xe2, 0x58, 0x45, 0x43, 0xd4, 0x3f, 0xf0, 0x43, 0xff, 0x18, 0x6f,
	0xeb, 0x42, 0xd5, 0x21, 0xa3, 0xd9, 0x02, 0xea, 0x7c, 0xbf, 0xca, 0x5a, 0xc6, 0x80, 0xe2, 0x34,
	0x54, 0x3e, 0x18, 0x3a, 0x66, 0x72, 0x2c, 0x4c, 0xd0, 0xe0, 0xa7, 0xcc, 0x75, 0xe6, 0xfc, 0x5c,
	0x9e, 0xfd, 0x68, 0x2d, 0xdb, 0x7f, 0x38, 0x88, 0x26, 0x62, 0xaa, 0xed, 0x9b, 0x68, 0x70, 0x1d,
	0x32, 0xf8, 0x58, 0x2b, 0xf0, 0xf1, 0x1e, 0x63, 0xea, 0x9a, 0x05, 0xda, 0x94, 0xd0, 0xe0, 0x1a,
	0x22, 0x0f, 0x8c, 0xc4, 0x81, 0x0f, 0xdf, 0x22, 0xe5, 0x9d, 0x03, 0x06, 0xef, 0xe4, 0x61, 0x94,
	0x9c, 0x77, 0x36, 0xab, 0xf2, 0x68, 0x2a, 0x68, 0x54, 0xf0, 0x59, 0x5e, 0x6a, 0xaa, 0x69, 0x68,
	0xa2, 0xb2, 0xbb, 0x2c, 0xe4, 0x71, 0x21, 0x79, 0x97, 0x05, 0xf9, 0xe0, 0xe7, 0x19, 0x83, 0x9a,
	0x92, 0x83, 0x06, 0x28, 0x97, 0xd0, 0x66, 0xd3, 0x73, 0x3c, 0xdc, 0xd0, 0x92, 0x07, 0x5a, 0x32,
	0x40, 0x2e, 0x1e, 0xce, 0xa6, 0xe7, 0xca, 0xd7, 0x93, 0xd7, 0x29, 0x18, 0x58, 0xf1, 0x77, 0x36,
	0xe9, 0x68, 0xb4, 0x09, 0x16, 0x6b, 0x3d, 0x22, 0x9f, 0xdf, 0x04, 0x9d, 0xdf, 0x2d, 0xa3, 0xab,
	0x61, 0x18, 0x3f, 0x70, 0x77, 0x1e, 0x51, 0x7a, 0x5c, 0xfa, 0x19, 0x19, 0x8d, 0xb1, 0xeb, 0x16,
	0x5d, 0x22, 0x4b, 0xd7, 0xcb, 0x2a, 0x1a, 0xca, 0x3c, 0xd7, 0xb8, 0x60, 0x36, 0xa3, 0xf1, 0x9b,
	0x9b, 0x52, 0x84, 0xc9, 0xb3, 0xc8, 0x68, 0xe0, 0x71, 0x2f, 0xc1, 0x93, 0x65, 0x74, 0xcd, 0xac,
	0xa4, 0x70, 0xf3, 0xef, 0x93, 0x81, 0xbb, 0x13, 0x4c, 0x53, 0xda, 0x59, 0x5a, 0xe7, 0x1a, 0x82,
	0xdb, 0x1a, 0xde, 0xcf, 0x2e, 0xbb, 0xa5, 0x5c, 0x52, 0x8e, 0x60, 0x6c, 0x98, 0xc8, 0x8b, 0x6a,
	0xeb, 0x14, 0x1b, 0x4a, 0x12, 0x0f, 0x1e, 0x8b, 0xb3, 0x28, 0x15, 0xd3, 0x73, 0x39, 0x2f, 0x54,
	0x36, 0xb6, 0x08, 0x3b, 0x5f, 0x63, 0x35, 0xb4, 0xdc, 0x74, 0xb7, 0x4d, 0x29, 0xbb, 0xdb, 0x06,
	0x1a, 0xed, 0xe2, 0x8a, 0x18, 0xfd, 0xbb, 0x8a, 0xa4, 0x9c, 0x7f, 0x5f, 0x62, 0xd7, 0x86, 0x51,
	0x9c, 0x8a, 0xe9, 0x55, 0x9d, 0x71, 0xc3, 0xb7, 0xa7, 0x7f, 0xb8, 0xca, 0x00, 0x29, 0xce, 0xb8,
	0xbb, 0x95, 0x1c, 0x23, 0x3c, 0xff, 0x44, 0x00, 0x5e, 0x91, 0x20, 0x2f, 0xf5, 0x56, 0x41, 0x33,
	0x91, 0xf0, 0xde, 0x96, 0x3f, 0x3e, 0x9d, 0x4d, 0xfd, 0x30, 0x5b, 0xa9, 0xcd, 0x80, 0x3c, 0x43,
	0xbe, 0xa2, 0x67, 0xc8, 0xef, 0xb0, 0xfa, 0x70, 0x7e, 0x26, 0x57, 0x7d, 0x28, 0x72, 0x51, 0xf4,
	0xc3, 0xdf, 0x6e, 0x49, 0xc7, 0xd8, 0x6e, 0xb1, 0xc6, 0xb0, 0xf3, 0xb1, 0x4c, 0x91, 0x5a, 0x9f,
	0xb1, 0x9b, 0xac, 0x3e, 0xec, 0x7c, 0x8c, 0x7f, 0x4e, 0x67, 0x95, 0xec, 0x35, 0xb6, 0x3a, 0xec,
	0x7c, 0xbc, 0x33, 0x8d, 0x5e, 0x5a, 0x65, 0xfb, 0x3a, 0x6b, 0x0d, 0x3b, 0x1f, 0xe7, 0xff, 0xf9,
	0x65, 0x55, 0xec, 0x6b, 0x6c, 0x6d, 0xd8, 0xf9, 0x58, 0xfd, 0xdf, 0x93, 0x55, 0xb5, 0x6d, 0xb6,
	0x3e, 0xec, 0x7c, 0xac, 0xfd, 0xe7, 0x91, 0x55, 0xb3, 0x6f, 0x32, 0x6b, 0xd8, 0xf9, 0xd8, 0xf8,
	0xef, 0x1f, 0x6b, 0x85, 0x5e, 0x55, 0x57, 0x75, 0x5b, 0xab, 0x36, 0x63, 0x2b, 0xc3, 0xce, 0xc7,
	0x6d, 0xee, 0x5a, 0x75, 0x6a, 0x05, 0xfe, 0xd7, 0x89, 0xd5, 0xd0, 0xa8, 0xf7, 0x2d, 0x46, 0x2f,
	0xaa, 0x3f, 0xaa, 0xb0, 0xd6, 0xec, 0x37, 0xd8, 0x75, 0x05, 0x64, 0x17, 0xe6, 0x5b, 0x4d, 0x7b,
	0x83, 0xdd, 0x5c, 0x80, 0x0f, 0x76, 0x47, 0x56, 0xcb, 0xbe, 0xcd, 0x6e, 0x2c, 0x94, 0xec, 0x8e,
	0xac, 0xf5, 0xa5, 0xaf, 0x0c, 0x76, 0xb6, 0xac, 0x6b, 0xf6, 0x7d, 0x76, 0x57, 0x95, 0x2c, 0xbb,
	0x2c, 0xdf, 0xb2, 0x6c, 0x8b, 0x35, 0x55, 0x8d, 0xb6, 0xb7, 0xdd, 0xb7, 0xae, 0xdb, 0x6f, 0xb2,
	0x37, 0x88, 0x39, 0xe6, 0xa5, 0xd4, 0x96, 0x4d, 0x2c, 0x31, 0xee, 0x70, 0xb7, 0x6e, 0x10, 0x83,
	0xf3, 0xeb, 0xd9, 0xad, 0x9b, 0xf6, 0x3d, 0x76, 0x67, 0xe9, 0x37, 0xd0, 0xf6, 0x5a, 0x6f, 0x10,
	0xbf, 0xb5, 0x0b, 0xcf, 0xad, 0x5b, 0xd4, 0xbd, 0xe2, 0x25, 0xe8, 0xd6, 0x6d, 0xfb, 0xb3, 0xec,
	0xcd, 0xa5, 0x1f, 0x03, 0xdf, 0xdf, 0xda, 0xb0, 0xef, 0xb0, 0x5b, 0xf4, 0xf3, 0x85, 0xfb, 0xb1,
	0xad, 0x37, 0xe9, 0x9b, 0xc5, 0x3b, 0xab, 0xad, 0x3b, 0xf6, 0x2d, 0x66, 0x53, 0x81, 0xe6, 0x63,
	0x59, 0x6f, 0xa9, 0xce, 0x2f, 0x5c, 0x8b, 0x6c, 0xdd, 0x25, 0xa1, 0xea, 0xb9, 0x2f, 0x3e, 0xb0,
	0x3e, 0x4b, 0x7d, 0xce, 0xaf, 0xc7, 0xb5, 0xee, 0xe5, 0xe5, 0x8f, 0xad, 0xcf, 0x91, 0x78, 0xca,
	0xcb, 0x44, 0xad, 0xfb, 0x3a, 0xf9, 0xd8, 0xfa, 0xbc, 0xed, 0xb0, 0x7b, 0x19, 0xb9, 0xf4, 0x1e,
	0x4e, 0xcb, 0xa1, 0xa1, 0xbb, 0xf0, 0x0a, 0x4c, 0xeb, 0xcf, 0xd9, 0x37, 0xd8, 0xb5, 0xac, 0x06,
	0xb5, 0xe2, 0x6d, 0x12, 0xc7, 0xfd, 0xae, 0x6b, 0x7d, 0x81, 0x9e, 0x47, 0x1d, 0xd7, 0xfa, 0x22,
	0x8d, 0x73, 0x76, 0xb3, 0x9d, 0xf5, 0x25, 0x6a, 0xaf, 0x07, 0xcc, 0x7f, 0x40, 0x55, 0xbb, 0x43,
	0xcf, 0xfa, 0xb2, 0x12, 0xa7, 0xe2, 0xdd, 0x5e, 0xd6, 0x43, 0xea, 0x86, 0xbc, 0x9f, 0xca, 0xfa,
	0x8a, 0x46, 0xf2, 0x03, 0xeb, 0x1d, 0x25, 0xef, 0x43, 0x6f, 0xf0, 0x91, 0xf5, 0x55, 0x1a, 0x62,
	0xed, 0xe2, 0x25, 0xeb, 0x5d, 0xf5, 0x02, 0x5e, 0x9f, 0x64, 0x7d, 0x8d, 0x98, 0x98, 0x5f, 0xaa,
	0x63, 0xbd, 0xa7, 0xd7, 0x78, 0x6c, 0xbd, 0x4f, 0x5d, 0xd4, 0x2f, 0x8f, 0xb1, 0x36, 0xa9, 0xad,
	0xfd, 0x7e, 0xc7, 0x7a, 0x44, 0xcf, 0xc3, 0x91, 0x6b, 0x7d, 0x40, 0xcf, 0x5e, 0xcf, 0xb5, 0xbe,
	0xae, 0x06, 0xe3, 0xc9, 0xc0, 0xb5, 0x1e, 0x53, 0x87, 0x16, 0x2e, 0x2d, 0xb0, 0x7e, 0x49, 0xb1,
	0x50, 0x3b, 0xb5, 0x6e, 0x7d, 0x83, 0x64, 0x60, 0xf1, 0x28, 0xbb, 0xf5, 0x4d, 0x35, 0x70, 0x17,
	0x9f, 0x72, 0xb7, 0xbe, 0xa5, 0xf8, 0x3a, 0x6c, 0xbb, 0xd6, 0xb7, 0x95, 0x9c, 0x64, 0x27, 0xcd,
	0xad, 0xef, 0xd8, 0x9f, 0x67, 0x9f, 0x5d, 0x18, 0x7c, 0xfd, 0x08, 0xb6, 0xf5, 0xcb, 0xf6, 0xe7,
	0xd8, 0x5b, 0x85, 0xb1, 0x37, 0x2a, 0xfc, 0x79, 0xfa, 0x8d, 0xdd, 0xd1, 0xc8, 0xb5, 0x7e, 0x85,
	0x14, 0x89, 0x79, 0x9c, 0xd7, 0xfa, 0x0b, 0xf6, 0x3a, 0x63, 0xd8, 0x56, 0x3c, 0x84, 0x68, 0xb5,
	0x49, 0x01, 0xa9, 0xb3, 0x7f, 0xd6, 0x16, 0xf1, 0x5a, 0x1e, 0x47, 0xb3, 0x3a, 0x1a, 0x2f, 0xd4,
	0x41, 0x06, 0xab, 0x4b, 0x63, 0x8a, 0xa7, 0xc6, 0xac, 0x6d, 0x25, 0x5c, 0xde, 0x96, 0xb5, 0xa3,
	0x46, 0xa1, 0x33, 0xb0, 0x9e, 0x50, 0x73, 0x06, 0x6e, 0xdf, 0xb3, 0x76, 0x49, 0xd2, 0xb2, 0x83,
	0x06, 0x56, 0x8f, 0x7e, 0x48, 0x6e, 0xc7, 0xb7, 0x7e, 0x55, 0x27, 0x1f, 0x59, 0x4f, 0xe9, 0x43,
	0x5b, 0x3b, 0x5d, 0xab, 0x4f, 0xcf, 0x4f, 0xf8, 0xb6, 0x35, 0x50, 0x4a, 0xbc, 0xdb, 0xed, 0x59,
	0x43, 0x2a, 0xd8, 0x6e, 0xbb, 0xd6, 0x1e, 0xbd, 0x2f, 0x93, 0x72, 0x96, 0x4b, 0x4d, 0xc4, 0x04,
	0xb2, 0xf5, 0x4c, 0xe9, 0x67, 0x4a, 0x27, 0x5b, 0x9c, 0xb8, 0x63, 0x86, 0x00, 0x96, 0x47, 0x83,
	0xbc, 0x98, 0x4c, 0xb0, 0x46, 0xf6, 0x5b, 0xec, 0xb6, 0xec, 0xe5, 0xc2, 0xa9, 0x1d, 0x6b, 0x9f,
	0x14, 0x47, 0xc1, 0xb4, 0x5a, 0x07, 0x5b, 0x1b, 0x7f, 0xf4, 0xe3, 0x7b, 0xa5, 0x3f, 0xfe, 0xf1,
	0xbd, 0xd2, 0x7f, 0xfa, 0xf1, 0xbd, 0xd2, 0xdf, 0xfe, 0xc9, 0xbd, 0xcf, 0xfc, 0xf1, 0x4f, 0xee,
	0x7d, 0xe6, 0x3f, 0xfc, 0xe4, 0xde, 0x67, 0x0e, 0x57, 0xf0, 0x1f, 0x5f, 0x1f, 0xfd, 0xbf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x4f, 0xa6, 0x6d, 0x96, 0x01, 0x76, 0x00, 0x00,
}
